local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/GoldDoomOwner/GoldField/refs/heads/main/SpazamX%20ui"))() -- loadstring(game:HttpGet("https://raw.githubusercontent.com/GoldDoomOwner/GoldField/refs/heads/main/GoldField%20Loader"))()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local TextChatService = game:GetService("TextChatService")
local ToolModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/GoldDoomOwner/Gold-Doom-Script/refs/heads/main/Tool%20Giver"))()
local UserInputService = game:GetService("UserInputService")

local Custom_PowerTools = {"Awaken", "Oblivious","Titanium", "Drug Abused", "Soul Monarch", "Creation", "AkazaDash", "ESPER RAGE", "GOLDEN MONARCH", "VOID WALKER", "STORM BREAKER", "CRIMSON REAPER", "CELESTIAL WRATH", "SHADOW ASSASSIN", "INFERNO KING", "FROZEN DOMAIN", "GRAVITY TITAN", "PLASMA SURGE", "TOXIC VENOM", "TIME WARP", "CRYSTAL FORTRESS", "BLOOD MOON", "DRAGON SPIRIT", "NEBULA VOID", "EARTH SHAKER", "WIND DANCER", "CHAOS BREAKER"}
-- game.Workspace.GlassBridge.GlassHuolder:GetChildren()
if localPlayer then
	-- Wait for TextChatService to be ready
	local textChannel = TextChatService:WaitForChild("TextChannels"):WaitForChild("RBXGeneral")

	textChannel:DisplaySystemMessage("[DAHEN HUB]: LOADING SCRIPT...")
	task.wait()
	textChannel:DisplaySystemMessage("[DAHEN HUB]: DAHEN HUB | INK GAMES")
	task.wait()
	textChannel:DisplaySystemMessage("[DAHEN HUB]: LOADED")
end

-- Create main window
local Window = Library:LoadWindow(
	"DAHEH HUB INK GAME: https://discord.gg/golddoom, https://discord.gg/ringta",  
	"DAHEN HUB TESTING | INK GAMES", 
	"1.2.0", 
	nil, 
	"DAHEN HUB | Ink Games", 
	"Disabled"
)

Library:Notify("Test", "Loading", 4, "Info")

-- Create tabs
local MainTab = Window:NewTab("Main")
local PlayerTab = Window:NewTab("Player")
local GameTab = Window:NewTab("Game")
local MiscTab = Window:NewTab("Misc")

-- Player Teleport System Variables
local selectedPlayer = nil

-- Function to get all players except local player
local function CreateGlassBridgeCover()
	local glassHolder = game.Workspace:FindFirstChild("GlassBridge")
	if not glassHolder then
		warn("GlassBridge not found in Workspace")
		return
	end

	glassHolder = glassHolder:FindFirstChild("GlassHolder")
	if not glassHolder then
		warn("GlassHolder not found in GlassBridge")
		return
	end

	local models = glassHolder:GetChildren()

	if #models == 0 then
		warn("No models found in GlassHolder")
		return
	end

	-- Calculate the bounding box that encompasses all models
	local minX, minY, minZ = math.huge, math.huge, math.huge
	local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge

	for _, model in ipairs(models) do
		if model:IsA("Model") or model:IsA("BasePart") then
			local cframe, size

			if model:IsA("Model") then
				cframe, size = model:GetBoundingBox()
			else
				cframe = model.CFrame
				size = model.Size
			end

			-- Calculate the corners of this model's bounding box
			local halfSize = size / 2
			local corners = {
				cframe * CFrame.new(-halfSize.X, -halfSize.Y, -halfSize.Z),
				cframe * CFrame.new(halfSize.X, -halfSize.Y, -halfSize.Z),
				cframe * CFrame.new(-halfSize.X, halfSize.Y, -halfSize.Z),
				cframe * CFrame.new(halfSize.X, halfSize.Y, -halfSize.Z),
				cframe * CFrame.new(-halfSize.X, -halfSize.Y, halfSize.Z),
				cframe * CFrame.new(halfSize.X, -halfSize.Y, halfSize.Z),
				cframe * CFrame.new(-halfSize.X, halfSize.Y, halfSize.Z),
				cframe * CFrame.new(halfSize.X, halfSize.Y, halfSize.Z),
			}

			-- Find min and max positions
			for _, corner in ipairs(corners) do
				local pos = corner.Position
				minX = math.min(minX, pos.X)
				minY = math.min(minY, pos.Y)
				minZ = math.min(minZ, pos.Z)
				maxX = math.max(maxX, pos.X)
				maxY = math.max(maxY, pos.Y)
				maxZ = math.max(maxZ, pos.Z)
			end
		end
	end

	-- Create the covering part
	local coverPart = Instance.new("Part")
	coverPart.Name = "GlassBridgeCover"
	coverPart.Anchored = true
	coverPart.CanCollide = true
	coverPart.Material = Enum.Material.SmoothPlastic
	coverPart.Color = Color3.fromRGB(100, 100, 255)
	coverPart.Transparency = 0.3

	-- Calculate size and position
	local sizeX = maxX - minX + 2 -- Add 2 studs padding
	local sizeY = maxY - minY + 2
	local sizeZ = maxZ - minZ + 2

	local centerX = (minX + maxX) / 2
	local centerY = (minY + maxY) / 2
	local centerZ = (minZ + maxZ) / 2

	coverPart.Size = Vector3.new(sizeX, sizeY, sizeZ)
	coverPart.CFrame = CFrame.new(centerX, centerY, centerZ)
	coverPart.Parent = workspace

	print("Glass Bridge Cover created!")
	print("Size:", coverPart.Size)
	print("Position:", coverPart.Position)

	return coverPart
end

local function getPlayerList()
	local playerList = {}
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= localPlayer then
			table.insert(playerList, player.DisplayName)
		end
	end
	return #playerList > 0 and playerList or {"No Players"}
end

-- Function to get player by display name
local function getPlayerByDisplayName(displayName)
	for _, player in pairs(Players:GetPlayers()) do
		if player.DisplayName == displayName then
			return player
		end
	end
	return nil
end

-- Function to teleport to selected player
local function teleportToPlayer(targetPlayer)
	if not targetPlayer or not targetPlayer.Character then
		return
	end

	local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
	local localRoot = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")

	if targetRoot and localRoot then
		localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, 3)
	end
end

-- Function to teleport to random player
local function teleportToRandomPlayer()
	local players = {}
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= localPlayer and player.Character then
			table.insert(players, player)
		end
	end

	if #players > 0 then
		local randomPlayer = players[math.random(1, #players)]
		teleportToPlayer(randomPlayer)
	end
end

MainTab:NewButton("Custom Emotes", function()
	loadstring(game:HttpGet("https://pastebin.com/raw/1p6xnBNf"))()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/GoldDoomOwner/Gold-Doom-Script/refs/heads/main/jerk"))()
end)

MainTab:NewButton("Custom Emotes 2", function()
	-- Feel free to modify, contact pystyt on discord if u want to show me the modifications you did to the script, thanks alot
	-- Detect R6 or R15
	local player = game.Players.LocalPlayer
	local character = player.Character or player.CharacterAdded:Wait()
	local isR6 = character:FindFirstChild("Torso") ~= nil

	-- Notification Function
	local function showNotification(message)
		local notificationGui = Instance.new("ScreenGui")
		notificationGui.Name = "NotificationGui"
		notificationGui.Parent = game.CoreGui

		local notificationFrame = Instance.new("Frame")
		notificationFrame.Size = UDim2.new(0, 300, 0, 50)
		notificationFrame.Position = UDim2.new(0.5, -150, 1, -60)
		notificationFrame.AnchorPoint = Vector2.new(0.5, 1)
		notificationFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
		notificationFrame.BorderSizePixel = 0
		notificationFrame.Parent = notificationGui

		local uicorner = Instance.new("UICorner")
		uicorner.CornerRadius = UDim.new(0, 10)
		uicorner.Parent = notificationFrame

		local textLabel = Instance.new("TextLabel")
		textLabel.Size = UDim2.new(1, -20, 1, 0)
		textLabel.Position = UDim2.new(0, 10, 0, 0)
		textLabel.BackgroundTransparency = 1
		textLabel.Text = message .. " | by nikos_YT7"
		textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		textLabel.Font = Enum.Font.SourceSansSemibold
		textLabel.TextSize = 18
		textLabel.TextXAlignment = Enum.TextXAlignment.Left
		textLabel.Parent = notificationFrame

		notificationFrame.BackgroundTransparency = 1
		textLabel.TextTransparency = 1

		game:GetService("TweenService"):Create(
			notificationFrame,
			TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.Out),
			{BackgroundTransparency = 0}
		):Play()

		game:GetService("TweenService"):Create(
			textLabel,
			TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.Out),
			{TextTransparency = 0}
		):Play()

		task.delay(5, function()
			game:GetService("TweenService"):Create(
				notificationFrame,
				TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.In),
				{BackgroundTransparency = 1}
			):Play()

			game:GetService("TweenService"):Create(
				textLabel,
				TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.In),
				{TextTransparency = 1}
			):Play()

			task.delay(0.5, function()
				notificationGui:Destroy()
			end)
		end)
	end

	-- Show notification based on rig type
	if isR6 then
		showNotification("R6 detected")
	else
		showNotification("R15 detected")
	end

	-- Create Screen GUI
	local gui = Instance.new("ScreenGui")
	gui.Name = "BangGui"
	gui.Parent = game.CoreGui

	-- Main Frame
	local mainFrame = Instance.new("Frame")
	mainFrame.Size = UDim2.new(0, 300, 0, 300)
	mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	mainFrame.BorderSizePixel = 0
	mainFrame.Parent = gui

	local uicorner = Instance.new("UICorner")
	uicorner.CornerRadius = UDim.new(0, 20)
	uicorner.Parent = mainFrame

	-- Title
	local title = Instance.new("TextLabel")
	title.Size = UDim2.new(1, -60, 0, 30)
	title.Position = UDim2.new(0, 10, 0, 0)
	title.BackgroundTransparency = 1
	title.Text = "Choose"
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.Font = Enum.Font.SourceSansSemibold
	title.TextSize = 24
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = mainFrame

    -- Dahen Hub Minimize/Restore System (Fixed)
local minimized = false

-- Main Dahen Hub restore button (appears when minimized)
local restoreBtn = Instance.new("TextButton")
restoreBtn.Size = UDim2.new(0, 120, 0, 36)
restoreBtn.Position = UDim2.new(0, 12, 0, 12)
restoreBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
restoreBtn.Text = "Dahen Hub"
restoreBtn.Font = Enum.Font.SourceSansBold
restoreBtn.TextSize = 18
restoreBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
restoreBtn.Visible = false
restoreBtn.Parent = screenGui

Instance.new("UICorner", restoreBtn).CornerRadius = UDim.new(0, 8)

-- Existing minimize button setup
local miniBtn = Instance.new("TextButton")
miniBtn.Size = UDim2.new(0, 36, 0, 36)
miniBtn.Position = UDim2.new(1, -76, 0, 12)
miniBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
miniBtn.Text = "-"
miniBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
miniBtn.TextScaled = true
miniBtn.Parent = mainFrame

Instance.new("UICorner", miniBtn).CornerRadius = UDim.new(0, 8)

-- Minimize behavior
miniBtn.MouseButton1Click:Connect(function()
	if minimized then return end
	minimized = true

	-- Tween out smoothly
	mainFrame:TweenSize(UDim2.new(0, 300, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.3, true, function()
		mainFrame.Visible = false
		restoreBtn.Visible = true
	end)
end)

-- Restore behavior
restoreBtn.MouseButton1Click:Connect(function()
	if not minimized then return end
	minimized = false

	restoreBtn.Visible = false
	mainFrame.Visible = true

	-- Tween back to normal size
	mainFrame:TweenSize(UDim2.new(0, 300, 0, 300), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.3, true)
end)

	-- Close Button
	local closeButton = Instance.new("TextButton")
	closeButton.Size = UDim2.new(0, 30, 0, 30)
	closeButton.Position = UDim2.new(1, -40, 0, 0)
	closeButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
	closeButton.Text = "X"
	closeButton.Font = Enum.Font.SourceSansBold
	closeButton.TextSize = 20
	closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	closeButton.Parent = mainFrame

	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 10)
	closeCorner.Parent = closeButton

	closeButton.MouseButton1Click:Connect(function()
		gui:Destroy()
	end)

-- Dahen Hub Minimize/Restore System

-- MainFrame, minimizeButton, and closeButton should already exist
local player = game.Players.LocalPlayer
local gui = player:WaitForChild("PlayerGui")

-- Create the Dahen Hub restore button
local restoreButton = Instance.new("TextButton")
restoreButton.Name = "RestoreButton"
restoreButton.Text = "Dahen Hub"
restoreButton.Font = Enum.Font.SourceSansBold
restoreButton.TextSize = 20
restoreButton.TextColor3 = Color3.fromRGB(255, 255, 255)
restoreButton.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
restoreButton.Size = UDim2.new(0, 150, 0, 40)
restoreButton.Position = UDim2.new(0.5, -75, 0, 10) -- top center
restoreButton.Visible = false
restoreButton.Parent = gui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 10)
corner.Parent = restoreButton

local minimized = false

minimizeButton.MouseButton1Click:Connect(function()
	minimized = true
	mainFrame.Visible = false
	restoreButton.Visible = true
end)

restoreButton.MouseButton1Click:Connect(function()
	minimized = false
	mainFrame.Visible = true
	restoreButton.Visible = false
end)

closeButton.MouseButton1Click:Connect(function()
	mainFrame.Visible = false
	restoreButton.Visible = false
end)

-- optional: close button behavior (keeps it visible and reliable)
closeButton.MouseButton1Click:Connect(function()
    mainFrame.Visible = false
end)

-- Example Content
local content = Instance.new("Frame")
content.Size = UDim2.new(1, 0, 1, -30)
content.Position = UDim2.new(0, 0, 0, 30)
content.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
content.Parent = mainFrame

local label = Instance.new("TextLabel")
label.Size = UDim2.new(1, 0, 0, 40)
label.Position = UDim2.new(0, 0, 0, 10)
label.BackgroundTransparency = 1
label.Text = "Welcome to Dahen Hub!"
label.Font = Enum.Font.SourceSansBold
label.TextSize = 22
label.TextColor3 = Color3.fromRGB(255, 255, 255)
label.Parent = content

-- Fixed Minimize Function (Shrink Only)
local minimized = false
local fullSize = UDim2.new(0, 300, 0, 300)
local minimizedSize = UDim2.new(0, 300, 0, 30)

minimizeButton.MouseButton1Click:Connect(function()
	minimized = not minimized

	if minimized then
		content.Visible = false
		mainFrame:TweenSize(minimizedSize, Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.4, true)
	else
		mainFrame:TweenSize(fullSize, Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.4, true)
		task.wait(0.4)
		content.Visible = true
	end
end)

	-- Dragging Functionality
	local dragging, dragStart, startPos
	mainFrame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = mainFrame.Position
		end
	end)

	mainFrame.InputChanged:Connect(function(input)
		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			local delta = input.Position - dragStart
			mainFrame.Position = UDim2.new(
				startPos.X.Scale,
				startPos.X.Offset + delta.X,
				startPos.Y.Scale,
				startPos.Y.Offset + delta.Y
			)
		end
	end)

	mainFrame.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = false
		end
	end)

	-- Scrolling Frame
	local scrollingFrame = Instance.new("ScrollingFrame")
	scrollingFrame.Size = UDim2.new(1, -20, 1, -50)
	scrollingFrame.Position = UDim2.new(0, 10, 0, 40)
	scrollingFrame.BackgroundTransparency = 1
	scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 300)
	scrollingFrame.ScrollBarThickness = 6
	scrollingFrame.Parent = mainFrame

	local layout = Instance.new("UIListLayout")
	layout.Padding = UDim.new(0, 10)
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.Parent = scrollingFrame

	-- Buttons Data
	local buttons = {
		{name = "Bang V2", r6 = "https://pastebin.com/raw/aPSHMV6K", r15 = "https://pastebin.com/raw/1ePMTt9n"},
		{name = "Get Banged", r6 = "https://pastebin.com/raw/zHbw7ND1", r15 = "https://pastebin.com/raw/7hvcjDnW"},
		{name = "Suck", r6 = "https://pastebin.com/raw/SymCfnAW", r15 = "https://pastebin.com/raw/p8yxRfr4"},
		{name = "Get Suc", r6 = "https://pastebin.com/raw/FPu4e2Qh", r15 = "https://pastebin.com/raw/DyPP2tAF"},
	}

	for _, buttonData in pairs(buttons) do
		local button = Instance.new("TextButton")
		button.Size = UDim2.new(0.8, 0, 0, 40)
		button.BackgroundColor3 = Color3.fromRGB(50, 150, 255)
		button.Text = buttonData.name
		button.Font = Enum.Font.SourceSansBold
		button.TextSize = 20
		button.TextColor3 = Color3.fromRGB(255, 255, 255)
		button.Parent = scrollingFrame

		local uicorner = Instance.new("UICorner")
		uicorner.CornerRadius = UDim.new(0, 10)
		uicorner.Parent = button

		button.MouseButton1Click:Connect(function()
			if isR6 then
				loadstring(game:HttpGet(buttonData.r6))()
			else
				loadstring(game:HttpGet(buttonData.r15))()
			end
		end)
	end
end)

GameTab:NewDivider()


-- Create first dropdown for tool selection
local selectedTool1 = "Awaken"
local toolDropdown1 = MainTab:NewDropdown(
	"Select Tool 1",
	Custom_PowerTools,
	"Awaken",
	function(selected)
		selectedTool1 = selected
		print("Selected tool 1:", selectedTool1)
	end
)

-- Create second dropdown for tool selection
local selectedTool2 = "Oblivious"
local toolDropdown2 = MainTab:NewDropdown(
	"Select Tool 2",
	Custom_PowerTools,
	"Oblivious",
	function(selected)
		selectedTool2 = selected
		print("Selected tool 2:", selectedTool2)
	end
)

-- Create text input for custom name
local customNameInput = MainTab:NewTextInput(
	"Custom Powers Name",
	"Enter custom name...",
	function(text)
		print("Custom name entered:", text)
	end
)

-- Create button to get tools and change shop UI text
local getToolButton = MainTab:NewButton(
	"Equip Custom Power",
	function()
		-- Get both tools using ToolModule
		ToolModule:GetTools(selectedTool1, selectedTool2)

		-- Get the custom name from the text input
		local customName = customNameInput.GetText()

		-- Change the shop UI text
		local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Powers
		spawn(function()
			while true do
				ui.CurrentlyEquipped.Text = "Currently Equipped: " .. (customName or "")
				task.wait()
			end
		end)
	end)

MainTab:NewDivider()

MainTab:NewButton("Enable Dash", function()
	localPlayer.Boosts["Faster Sprint"].Value = 5
	local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Boosts
	local Speed = ui["Faster Sprint"]

	spawn(function()
		while true do
			task.wait()
			Speed.BuyButtonRobux.Visible = false
			Speed.BuyButtonCoin.Visible = false
			Speed.ItemLevel.Text = "Current Level (5)"
		end
	end)
end)

MainTab:NewButton("Won Boost", function()
	localPlayer.Boosts["Won Boost"].Value = 5
	local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Boosts
	local Speed = ui["Won Boost"]

	spawn(function()
		while true do
			task.wait()
			Speed.BuyButtonRobux.Visible = false
			Speed.BuyButtonCoin.Visible = false
			Speed.ItemLevel.Text = "Current Level (5)"
		end
	end)
end)

MainTab:NewButton("Strength Boost", function()
	localPlayer.Boosts["Damage Boost"].Value = 5
	local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Boosts
	local Speed = ui["Damage Boost"]

	spawn(function()
		while true do
			task.wait()
			Speed.BuyButtonRobux.Visible = false
			Speed.BuyButtonCoin.Visible = false
			Speed.ItemLevel.Text = "Current Level (5)"
		end
	end)
end)

MainTab:NewButton("Equip Phantom Step", function()
	localPlayer:SetAttribute("_EquippedPower", "PHANTOM STEP")
end)

MainTab:NewButton("Remove Power", function()
	localPlayer:SetAttribute("_EquippedPower", "")
end)

MainTab:NewButton("Enable Powers", function()
	game.Workspace.Values.PowersDisabled.Value = false
end)

MainTab:NewDivider()

MainTab:NewButton("Enable All Gamepasses", function()
	Library:Notify("Enabling All Gamepasses", "Loading Script", 4, "Info")
	localPlayer:SetAttribute("HasLighter", true)
	localPlayer:SetAttribute("HasPush", true)
	game.Workspace.Values.CanPush.Value = true
	local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Gamepass
	game.Workspace.Values.CanPush.Value = true

	for i, v in pairs(ui:GetChildren()) do
		if v:IsA("TextButton") then
			spawn(function()
				if v.ItemName.Text == "Revive All" or v.ItemName.Text == "One Time Playable Guard" then
					print("["..v.ItemName.Text.."] Has Been Blocked")
					Library:Notify(v.ItemName.Text, "Blocked To Look Legit", 4, "Info")
				else
					v.BuyButton.Content.TextLabel.Text = "OWNED"
					Library:Notify(v.ItemName.Text, "Giving Gamepass", 4, "Info")
					print("Done ["..v.ItemName.Text.."]")
				end
			end)
		end
	end
end)

MainTab:NewButton("Select Fork", function()
	localPlayer:SetAttribute("WeaponSelected", "Fork")
end)

MainTab:NewButton("Show All Buttons", function()
	local ui = localPlayer.PlayerGui.Buttons.LeftButtons

	for i, v in pairs(ui:GetChildren()) do
		if v:IsA("ImageButton") then
			v.Visible = true
		end
	end
end)

-- PLAYER TAB CONTENT
PlayerTab:NewText("=== PLAYER TELEPORTS ===")

-- Create player dropdown
local playerOptions = getPlayerList()
local playerDropdown = PlayerTab:NewDropdown("Player Selector", playerOptions, playerOptions[1], function(selectedName)
	selectedPlayer = getPlayerByDisplayName(selectedName)
end)

PlayerTab:NewButton("Refresh Players", function()
	-- Note: GoldField dropdown refresh would need to be implemented in the library
	print("Player list refreshed")
end)

PlayerTab:NewButton("Teleport To Selected Player", function()
	if selectedPlayer then
		teleportToPlayer(selectedPlayer)
	else
		print("No player selected!")
	end
end)

local goatersa = false

PlayerTab:NewToggle("Attach to player", false, function(state)
	if selectedPlayer then
		goatersa = state
		spawn(function()
			while true do
				if goatersa == true then
					teleportToPlayer(selectedPlayer)
				else
					-- ignore
				end
				task.wait(0.1) -- for preformance without there will be lag
			end
		end)
	else
		print("No player selected!")
	end
end)


PlayerTab:NewButton("Teleport To Random Player", function()
	teleportToRandomPlayer()
end)

PlayerTab:NewDivider()

PlayerTab:NewButton("Hitbox multiplier", function()
	if game.Workspace.Values.HitboxMultiplier.Value == 10 then
		Library:Notify("[HITBOX]", "is 1x", 4, "Info")
		game.Workspace.Values.HitboxMultiplier.Value = 1
	else
		Library:Notify("[HITBOX]", "is 10x", 4, "Info")
		game.Workspace.Values.HitboxMultiplier.Value = 10
	end
end)

-- Hitbox Expander Toggle
PlayerTab:NewToggle("🔴 Hitbox Expander", "Expand your hitbox range", function(state)
    if state then
        Library:Notify("🔴 HITBOX EXPANDER", "Loading hitbox expander...", 3, "Info")
        
        -- Execute the hitbox expander script
        local success, error = pcall(function()
            loadstring(game:HttpGet("https://pastebin.com/raw/tE9CCGqe", true))()
        end)
        
        if success then
            Library:Notify("🟢 HITBOX EXPANDER", "Successfully loaded!", 3, "Success")
        else
            Library:Notify("🔴 HITBOX EXPANDER", "Failed to load: " .. error, 5, "Error")
        end
        
    else
        Library:Notify("🔴 HITBOX EXPANDER", "Disabled - May require game rejoin", 3, "Warning")
    end
end)

PlayerTab:NewToggle("Infinite Jump", false, function(value)
	infiniteJumpEnabled = value

	if infiniteJumpEnabled then
		-- Connect to UserInputService to detect jump input
		local UserInputService = game:GetService("UserInputService")

		jumpConnection = game:GetService("UserInputService").JumpRequest:Connect(function()
			local character = localPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				end
			end
		end)
	else
		-- Disable infinite jump
		if jumpConnection then
			jumpConnection:Disconnect()
			jumpConnection = nil
		end
	end
end)

-- Noclip Toggle
local noclipEnabled = false
local noclipConnection = nil

PlayerTab:NewToggle("Noclip", false, function(state)
	noclipEnabled = state

	if noclipEnabled then
		noclipConnection = RunService.Stepped:Connect(function()
			if localPlayer.Character then
				for _, part in pairs(localPlayer.Character:GetDescendants()) do
					if part:IsA("BasePart") then
						-- Only disable collision on main body parts, not accessories
						if part.Name == "Head" or part.Name == "Torso" or part.Name == "HumanoidRootPart" or 
							part.Name == "Left Arm" or part.Name == "Right Arm" or 
							part.Name == "Left Leg" or part.Name == "Right Leg" or
							part.Name == "UpperTorso" or part.Name == "LowerTorso" or
							part.Name == "LeftUpperArm" or part.Name == "LeftLowerArm" or part.Name == "LeftHand" or
							part.Name == "RightUpperArm" or part.Name == "RightLowerArm" or part.Name == "RightHand" or
							part.Name == "LeftUpperLeg" or part.Name == "LeftLowerLeg" or part.Name == "LeftFoot" or
							part.Name == "RightUpperLeg" or part.Name == "RightLowerLeg" or part.Name == "RightFoot" then
							part.CanCollide = false
						end
					end
				end
			end
		end)
	else
		if noclipConnection then
			noclipConnection:Disconnect()
			noclipConnection = nil
		end

		-- Re-enable collision only on parts we disabled
		if localPlayer.Character then
			for _, part in pairs(localPlayer.Character:GetDescendants()) do
				if part:IsA("BasePart") then
					if part.Name == "Head" or part.Name == "Torso" or 
						part.Name == "Left Arm" or part.Name == "Right Arm" or 
						part.Name == "Left Leg" or part.Name == "Right Leg" or
						part.Name == "UpperTorso" or part.Name == "LowerTorso" or
						part.Name == "LeftUpperArm" or part.Name == "LeftLowerArm" or part.Name == "LeftHand" or
						part.Name == "RightUpperArm" or part.Name == "RightLowerArm" or part.Name == "RightHand" or
						part.Name == "LeftUpperLeg" or part.Name == "LeftLowerLeg" or part.Name == "LeftFoot" or
						part.Name == "RightUpperLeg" or part.Name == "RightLowerLeg" or part.Name == "RightFoot" then
						part.CanCollide = true
					end
				end
			end
		end
	end
end)

-- Ultra Cool Auto Dodge with Visual Effects
local isDodgeActive = false
local dodgeLoop = nil
local lastDodgeTime = 0
local dodgeCooldown = 0.5 -- Half second cooldown

-- Add the toggle button to your existing tab
PlayerTab:NewToggle("✨ Auto Dodge", "Epic dodge with cool visuals", function(state)
    isDodgeActive = state
    
    if state then
        -- ENABLE
        Library:Notify("✨ ULTRA DODGE", "ACTIVE - Epic visuals ready!", 3, "Success")
        
        if dodgeLoop then
            dodgeLoop:Disconnect()
        end
        
        dodgeLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if not isDodgeActive then return end
            ultraDodgeDetection()
        end)
        
    else
        -- DISABLE
        Library:Notify("✨ ULTRA DODGE", "INACTIVE", 3, "Warning")
        
        if dodgeLoop then
            dodgeLoop:Disconnect()
            dodgeLoop = nil
        end
    end
end)

function ultraDodgeDetection()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local myRoot = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not myRoot or not humanoid or humanoid.Health <= 0 then return end
    
    -- Cooldown check (HALF SECOND)
    if tick() - lastDodgeTime < dodgeCooldown then return end
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherRoot then
                local distance = (myRoot.Position - otherRoot.Position).Magnitude
                
                if distance < 18 then
                    local toMe = (myRoot.Position - otherRoot.Position).Unit
                    local lookDir = otherRoot.CFrame.LookVector
                    
                    if toMe:Dot(lookDir) > 0.6 then
                        local tool = otherPlayer.Character:FindFirstChildOfClass("Tool")
                        if tool then
                            epicDodge(otherRoot.Position)
                            lastDodgeTime = tick() -- Update cooldown timer
                            break
                        end
                    end
                end
            end
        end
    end
end

function epicDodge(attackerPos)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not rootPart or not humanoid then return end
    
    -- Calculate dodge direction
    local threatDir = (rootPart.Position - attackerPos).Unit
    local dodgeDistance = 25
    
    -- Try multiple safe directions
    local directions = {
        threatDir, -- Direct away
        threatDir:Cross(Vector3.new(0, 1, 0)), -- Left
        -threatDir:Cross(Vector3.new(0, 1, 0)), -- Right
        (threatDir + Vector3.new(0, 0.5, 0)).Unit -- Up and away
    }
    
    local foundSafeSpot = false
    local safePosition = rootPart.Position
    
    for _, dir in ipairs(directions) do
        local testPos = rootPart.Position + (dir * dodgeDistance)
        local groundRay = Ray.new(testPos + Vector3.new(0, 5, 0), Vector3.new(0, -20, 0))
        local groundHit, groundPos = workspace:FindPartOnRay(groundRay, character)
        
        if groundHit then
            safePosition = groundPos + Vector3.new(0, 3, 0)
            foundSafeSpot = true
            break
        end
    end
    
    if foundSafeSpot then
        -- Create EPIC DODGE EFFECTS
        createDodgeEffects(rootPart.Position, safePosition)
        
        -- Teleport after a brief delay for dramatic effect
        spawn(function()
            wait(0.1) -- Small delay for animation
            rootPart.CFrame = CFrame.new(safePosition)
        end)
        
        Library:Notify("🚀 EPIC DODGE!", "Cooldown: 0.5s", 2, "Success")
    else
        Library:Notify("⚠️ DODGE FAILED", "No safe spot found", 2, "Warning")
    end
end

function createDodgeEffects(startPos, endPos)
    local TweenService = game:GetService("TweenService")
    
    -- 1. DASH TRAIL EFFECT
    spawn(function()
        local trailPart = Instance.new("Part")
        trailPart.Size = Vector3.new(2, 2, 2)
        trailPart.Position = startPos
        trailPart.BrickColor = BrickColor.new("Bright blue")
        trailPart.Material = Enum.Material.Neon
        trailPart.Anchored = true
        trailPart.CanCollide = false
        trailPart.Parent = workspace
        
        local trailTween = TweenService:Create(trailPart, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Position = endPos,
            Transparency = 1
        })
        
        trailTween:Play()
        game:GetService("Debris"):AddItem(trailPart, 1)
    end)
    
    -- 2. AFTERIMAGE EFFECT (Multiple ghost copies)
    spawn(function()
        for i = 1, 3 do
            local afterImage = Instance.new("Part")
            afterImage.Size = Vector3.new(4, 6, 2)
            afterImage.Position = startPos + Vector3.new(0, 1, 0)
            afterImage.BrickColor = BrickColor.new("Bright violet")
            afterImage.Material = Enum.Material.Glass
            afterImage.Transparency = 0.7
            afterImage.Anchored = true
            afterImage.CanCollide = false
            afterImage.Parent = workspace
            
            local tweenInfo = TweenInfo.new(
                0.4, 
                Enum.EasingStyle.Quad, 
                Enum.EasingDirection.Out,
                0, -- RepeatCount
                false, -- Reverses
                i * 0.1 -- Delay
            )
            
            local afterTween = TweenService:Create(afterImage, tweenInfo, {
                Position = endPos + Vector3.new(0, 1, 0),
                Transparency = 1,
                Size = Vector3.new(2, 3, 1)
            })
            
            afterTween:Play()
            game:GetService("Debris"):AddItem(afterImage, 2)
        end
    end)
    
    -- 3. RING EXPLOSION EFFECT at start position
    spawn(function()
        for i = 1, 8 do
            local ringPart = Instance.new("Part")
            ringPart.Size = Vector3.new(0.5, 0.5, 0.5)
            ringPart.Position = startPos
            ringPart.BrickColor = BrickColor.new("Bright yellow")
            ringPart.Material = Enum.Material.Neon
            ringPart.Anchored = true
            ringPart.CanCollide = false
            ringPart.Parent = workspace
            
            local angle = (i / 8) * math.pi * 2
            local ringTween = TweenService:Create(ringPart, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Position = startPos + Vector3.new(
                    math.cos(angle) * 10,
                    math.sin(angle) * 2,
                    math.sin(angle) * 10
                ),
                Transparency = 1
            })
            
            ringTween:Play()
            game:GetService("Debris"):AddItem(ringPart, 2)
        end
    end)
    
    -- 4. SPEED LINES EFFECT
    spawn(function()
        local speedLines = Instance.new("Part")
        speedLines.Size = Vector3.new(10, 10, 10)
        speedLines.Position = startPos
        speedLines.Transparency = 1
        speedLines.Anchored = true
        speedLines.CanCollide = false
        speedLines.Parent = workspace
        
        local particleEmitter = Instance.new("ParticleEmitter")
        particleEmitter.Texture = "rbxasset://textures/particles/sparkles_main.dds"
        particleEmitter.Lifetime = NumberRange.new(0.3, 0.8)
        particleEmitter.Rate = 100
        particleEmitter.SpreadAngle = Vector2.new(45, 45)
        particleEmitter.Speed = NumberRange.new(10, 20)
        particleEmitter.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 255))
        })
        particleEmitter.Parent = speedLines
        
        game:GetService("Debris"):AddItem(speedLines, 1)
    end)
    
    -- 5. IMPACT EFFECT at destination
    spawn(function()
        wait(0.2) -- Delay for arrival
        
        local impactRing = Instance.new("Part")
        impactRing.Size = Vector3.new(1, 0.2, 1)
        impactRing.Position = endPos
        impactRing.BrickColor = BrickColor.new("Lime green")
        impactRing.Material = Enum.Material.Neon
        impactRing.Anchored = true
        impactRing.CanCollide = false
        impactRing.Parent = workspace
        
        local impactTween = TweenService:Create(impactRing, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Size = Vector3.new(15, 0.2, 15),
            Transparency = 1
        })
        
        impactTween:Play()
        game:GetService("Debris"):AddItem(impactRing, 2)
    end)
    
    -- 6. FLASH EFFECT
    spawn(function()
        local flash = Instance.new("Part")
        flash.Size = Vector3.new(20, 20, 20)
        flash.Position = startPos
        flash.BrickColor = BrickColor.new("Institutional white")
        flash.Material = Enum.Material.Neon
        flash.Transparency = 0.5
        flash.Anchored = true
        flash.CanCollide = false
        flash.Parent = workspace
        
        local flashTween = TweenService:Create(flash, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Transparency = 1,
            Size = Vector3.new(30, 30, 30)
        })
        
        flashTween:Play()
        game:GetService("Debris"):AddItem(flash, 1)
    end)
end

-- Auto Dash Script - No Visuals
local isAutoDashActive = false
local autoDashLoop = nil
local lastDashTime = 0
local dashCooldown = 2
local isHoldingShift = false
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Add the toggle button
PlayerTab:NewToggle("🌀 Auto Dodge Legit", "Auto dash away from attacks", function(state)
    isAutoDashActive = state
    
    if state then
        Library:Notify("🌀 AUTO DODGE LEGIT", "ACTIVE - Will dash from attacks!", 3, "Success")
        
        if autoDashLoop then
            autoDashLoop:Disconnect()
        end
        
        autoDashLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if not isAutoDashActive then return end
            autoDashRoutine()
        end)
        
    else
        Library:Notify("🌀 AUTO DODGE LEGIT", "INACTIVE", 3, "Warning")
        releaseShift()
        if autoDashLoop then
            autoDashLoop:Disconnect()
            autoDashLoop = nil
        end
    end
end)

-- Shift holding functions
function holdShift()
    if not isHoldingShift then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
        isHoldingShift = true
    end
end

function releaseShift()
    if isHoldingShift then
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
        isHoldingShift = false
    end
end

-- Main detection routine
function autoDashRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        releaseShift()
        return 
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart or humanoid.Health <= 0 then 
        releaseShift()
        return 
    end
    
    -- Check cooldown
    if tick() - lastDashTime < dashCooldown then return end
    
    -- Detect if any player is attacking us
    local attacker, attackDirection, attackSide = detectAttackDirection()
    
    if attacker and attackSide then
        performDirectionalDash(attackSide, attackDirection)
        lastDashTime = tick()
    end
end

-- Detect which direction the attack is coming from
function detectAttackDirection()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil, nil, nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil, nil, nil end
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
            
            if otherRoot and otherHumanoid and otherHumanoid.Health > 0 then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                
                if distance <= 20 then
                    -- Calculate relative position
                    local attackerPos = otherRoot.Position
                    local myPos = rootPart.Position
                    local relativePos = attackerPos - myPos
                    
                    -- Get local space direction
                    local lookVector = rootPart.CFrame.LookVector
                    local rightVector = rootPart.CFrame.RightVector
                    
                    -- Convert to local space
                    local localX = relativePos:Dot(rightVector)
                    local localZ = relativePos:Dot(lookVector)
                    
                    -- Determine attack direction
                    local attackSide = getAttackDirection(localX, localZ)
                    local attackDirection = (attackerPos - myPos).Unit
                    
                    -- Check if attacker is actually attacking
                    local tool = otherPlayer.Character:FindFirstChildOfClass("Tool")
                    local lookDirection = otherRoot.CFrame.LookVector
                    local directionToMe = (myPos - attackerPos).Unit
                    
                    if tool and directionToMe:Dot(lookDirection) > 0.6 then
                        return otherPlayer, attackDirection, attackSide
                    end
                    
                    -- Also check animations
                    if isPlayerAnimatingAttack(otherPlayer) then
                        return otherPlayer, attackDirection, attackSide
                    end
                end
            end
        end
    end
    
    return nil, nil, nil
end

-- Determine which side the attack is coming from
function getAttackDirection(localX, localZ)
    local angle = math.atan2(localX, localZ)
    local degrees = math.deg(angle)
    
    if degrees < 0 then degrees = degrees + 360 end
    
    if degrees >= 315 or degrees < 45 then
        return "FRONT"
    elseif degrees >= 45 and degrees < 135 then
        return "RIGHT"
    elseif degrees >= 135 and degrees < 225 then
        return "BACK"
    else
        return "LEFT"
    end
end

-- Perform dash based on attack direction
function performDirectionalDash(attackSide, attackDirection)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart then return end
    
    -- HOLD SHIFT TO RUN
    holdShift()
    
    local dashVector = Vector3.new(0, 0, 0)
    
    -- Calculate dash direction based on attack side
    if attackSide == "FRONT" then
        -- Attack from front - dash backward
        dashVector = -rootPart.CFrame.LookVector
        
    elseif attackSide == "BACK" then
        -- Attack from back - dash forward
        dashVector = rootPart.CFrame.LookVector
        
    elseif attackSide == "LEFT" then
        -- Attack from left - dash right
        dashVector = rootPart.CFrame.RightVector
        
    elseif attackSide == "RIGHT" then
        -- Attack from right - dash left
        dashVector = -rootPart.CFrame.RightVector
    end
    
    -- Execute the dash
    if dashVector.Magnitude > 0 then
        -- Press Q to dash
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
        wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
        
        -- Move in dash direction while holding shift
        local dashDistance = 25
        local dashPosition = rootPart.Position + (dashVector * dashDistance)
        
        -- Move to dash position
        humanoid:MoveTo(dashPosition)
        
        -- Release shift after dash
        spawn(function()
            wait(0.5)
            releaseShift()
        end)
    end
end

-- Check if player is performing attack animations
function isPlayerAnimatingAttack(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return false end
    
    local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    if not humanoid then return false end
    
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then return false end
    
    for _, track in pairs(animator:GetPlayingAnimationTracks()) do
        local animName = track.Animation.Name:lower()
        if animName:find("attack") or animName:find("swing") or animName:find("slash") or 
           animName:find("punch") or animName:find("kick") or animName:find("shoot") then
            return true
        end
    end
    
    return false
end

-- Clean up when script stops
game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
    releaseShift()
end)

-- Initial notification
Library:Notify("🌀 AUTO DASH", "Directional dodging enabled!", 4, "Info")

-- Advanced AI Assistant - Game File Explorer
local isAIActive = false
local AIBotConnection = nil

-- Add the toggle button
PlayerTab:NewToggle("🤖 DAHENBOT", "AI that explores game files for development", function(state)
    isAIActive = state
    
    if state then
        Library:Notify("🤖 DAHENBOT", "Activated - Game file explorer ready!", 4, "Success")
        
        if AIBotConnection then
            AIBotConnection:Disconnect()
        end
        
        -- Listen for chat messages
        AIBotConnection = game:GetService("Players").LocalPlayer.Chatted:Connect(function(message)
            if isAIActive then
                processDevMessage(message)
            end
        end)
        
    else
        Library:Notify("🤖 DAHEN BOT", "Deactivated", 3, "Warning")
        if AIBotConnection then
            AIBotConnection:Disconnect()
            AIBotConnection = nil
        end
    end
end)

-- Enhanced AI Response Function for Development
function processDevMessage(message)
    local lowerMessage = message:lower()
    
    -- Check if message is for the bot
    if lowerMessage:find("dahenbot") or lowerMessage:find("dev") or lowerMessage:find("script") or lowerMessage:find("file") or lowerMessage:find("explore") then
        
        -- Game File Exploration Commands
        if lowerMessage:find("explore") or lowerMessage:find("files") or lowerMessage:find("what's in") then
            exploreGameFiles(message)
            
        -- Find specific objects
        elseif lowerMessage:find("find") or lowerMessage:find("where is") or lowerMessage:find("locate") then
            findInGameFiles(message)
            
        -- Script analysis
        elseif lowerMessage:find("script") or lowerMessage:find("code") then
            analyzeScripts(message)
            
        -- Service information
        elseif lowerMessage:find("service") or lowerMessage:find("workspace") or lowerMessage:find("players") then
            showServiceInfo(message)
            
        -- Object properties
        elseif lowerMessage:find("property") or lowerMessage:find("properties") or lowerMessage:find("what does") then
            showObjectProperties(message)
            
        -- Game structure
        elseif lowerMessage:find("structure") or lowerMessage:find("hierarchy") then
            showGameStructure()
            
        -- Help for developers
        elseif lowerMessage:find("help") or lowerMessage:find("commands") then
            showDevHelp()
            
        else
            -- Enhanced response with file exploration
            local enhancedResponse = enhanceDevResponse(message)
            if enhancedResponse then
                sendAIResponse(enhancedResponse)
            else
                sendAIResponse("I can help you explore game files! Try: 'find scripts', 'explore workspace', or 'show services'")
            end
        end
    end
end

-- Explore game files based on query
function exploreGameFiles(message)
    local lowerMessage = message:lower()
    
    if lowerMessage:find("workspace") then
        exploreWorkspace()
    elseif lowerMessage:find("lighting") then
        exploreLighting()
    elseif lowerMessage:find("players") then
        explorePlayers()
    elseif lowerMessage:find("replicated") then
        exploreReplicatedStorage()
    elseif lowerMessage:find("server") then
        exploreServerStorage()
    elseif lowerMessage:find("starter") then
        exploreStarterPack()
    else
        -- General exploration
        sendAIResponse("📁 Game Structure:\n" .. getGameStructure())
    end
end

-- Find specific objects in game files
function findInGameFiles(message)
    local searchTerm = extractSearchTerm(message)
    if not searchTerm then
        sendAIResponse("What would you like me to find? Example: 'find sword' or 'locate scripts'")
        return
    end
    
    local results = {}
    
    -- Search in major services
    local servicesToSearch = {
        workspace,
        game:GetService("ReplicatedStorage"),
        game:GetService("ServerStorage"),
        game:GetService("StarterPack"),
        game:GetService("StarterPlayer"):FindFirstChild("StarterPlayerScripts"),
        game:GetService("StarterPlayer"):FindFirstChild("StarterCharacterScripts")
    }
    
    for _, service in pairs(servicesToSearch) do
        if service then
            local found = searchInService(service, searchTerm)
            for _, item in ipairs(found) do
                table.insert(results, item)
            end
        end
    end
    
    if #results > 0 then
        local response = "🔍 Found '" .. searchTerm .. "' in:\n"
        for i, result in ipairs(results) do
            if i <= 10 then -- Limit to 10 results
                response = response .. "• " .. result .. "\n"
            end
        end
        if #results > 10 then
            response = response .. "... and " .. (#results - 10) .. " more items"
        end
        sendAIResponse(response)
    else
        sendAIResponse("❌ No results found for '" .. searchTerm .. "'")
    end
end

-- Search in a specific service
function searchInService(service, searchTerm, path)
    path = path or service.Name
    local results = {}
    
    for _, item in pairs(service:GetChildren()) do
        local itemPath = path .. " > " .. item.Name
        
        -- Check if item matches search
        if item.Name:lower():find(searchTerm:lower()) then
            table.insert(results, itemPath .. " (" .. item.ClassName .. ")")
        end
        
        -- Recursively search children
        if #item:GetChildren() > 0 then
            local childResults = searchInService(item, searchTerm, itemPath)
            for _, result in ipairs(childResults) do
                table.insert(results, result)
            end
        end
    end
    
    return results
end

-- Explore Workspace
function exploreWorkspace()
    local workspaceInfo = "🏗️ Workspace Contents:\n"
    local categories = {}
    
    for _, item in pairs(workspace:GetChildren()) do
        local class = item.ClassName
        if not categories[class] then
            categories[class] = {}
        end
        table.insert(categories[class], item.Name)
    end
    
    for class, items in pairs(categories) do
        workspaceInfo = workspaceInfo .. "📦 " .. class .. " (" .. #items .. "):\n"
        for i, item in ipairs(items) do
            if i <= 5 then
                workspaceInfo = workspaceInfo .. "  • " .. item .. "\n"
            end
        end
        if #items > 5 then
            workspaceInfo = workspaceInfo .. "  ... and " .. (#items - 5) .. " more\n"
        end
    end
    
    sendAIResponse(workspaceInfo)
end

-- Explore ReplicatedStorage
function exploreReplicatedStorage()
    local repStorage = game:GetService("ReplicatedStorage")
    local info = "🔁 ReplicatedStorage:\n"
    
    if #repStorage:GetChildren() == 0 then
        info = info .. "Empty"
    else
        for _, item in pairs(repStorage:GetChildren()) do
            info = info .. "• " .. item.Name .. " (" .. item.ClassName .. ")\n"
        end
    end
    
    sendAIResponse(info)
end

-- Show service information
function showServiceInfo(message)
    local lowerMessage = message:lower()
    local response = "🔧 Services:\n"
    
    local services = game:GetServices()
    for _, service in pairs(services) do
        local serviceName = service.Name
        if lowerMessage:find(serviceName:lower()) or lowerMessage:find("all") then
            response = response .. "• " .. serviceName .. ": " .. countChildren(service) .. " items\n"
        end
    end
    
    if response == "🔧 Services:\n" then
        response = "Available services: Workspace, Lighting, Players, ReplicatedStorage, ServerStorage, etc."
    end
    
    sendAIResponse(response)
end

-- Analyze scripts
function analyzeScripts(message)
    local lowerMessage = message:lower()
    local scriptsFound = {}
    
    -- Search for scripts in major containers
    local containers = {
        workspace,
        game:GetService("ReplicatedStorage"),
        game:GetService("ServerStorage"),
        game:GetService("StarterPack"),
        game:GetService("StarterPlayer"):FindFirstChild("StarterPlayerScripts"),
        game:GetService("StarterPlayer"):FindFirstChild("StarterCharacterScripts")
    }
    
    for _, container in pairs(containers) do
        if container then
            findScriptsInContainer(container, scriptsFound)
        end
    end
    
    if #scriptsFound > 0 then
        local response = "📜 Scripts Found (" .. #scriptsFound .. "):\n"
        for i, scriptInfo in ipairs(scriptsFound) do
            if i <= 8 then
                response = response .. "• " .. scriptInfo .. "\n"
            end
        end
        if #scriptsFound > 8 then
            response = response .. "... and " .. (#scriptsFound - 8) .. " more scripts"
        end
        sendAIResponse(response)
    else
        sendAIResponse("❌ No scripts found in game structure")
    end
end

-- Find scripts in a container
function findScriptsInContainer(container, scriptsFound, path)
    path = path or container.Name
    
    for _, item in pairs(container:GetChildren()) do
        if item:IsA("Script") or item:IsA("LocalScript") or item:IsA("ModuleScript") then
            table.insert(scriptsFound, item.Name .. " (" .. item.ClassName .. " in " .. path .. ")")
        end
        
        -- Recursively search children
        if #item:GetChildren() > 0 then
            findScriptsInContainer(item, scriptsFound, path .. " > " .. item.Name)
        end
    end
end

-- Show object properties
function showObjectProperties(message)
    local searchTerm = extractSearchTerm(message)
    if not searchTerm then
        sendAIResponse("Which object's properties? Example: 'properties of Part'")
        return
    end
    
    local foundObjects = {}
    
    -- Search for object
    local services = {workspace, game:GetService("ReplicatedStorage")}
    for _, service in pairs(services) do
        local object = findObjectByName(service, searchTerm)
        if object then
            table.insert(foundObjects, object)
        end
    end
    
    if #foundObjects > 0 then
        local object = foundObjects[1]
        local response = "📋 Properties of " .. object.Name .. " (" .. object.ClassName .. "):\n"
        
        -- Show important properties
        local importantProps = {"Position", "Size", "Color", "Material", "Transparency", "Anchored", "CanCollide"}
        
        for _, propName in pairs(importantProps) do
            local success, value = pcall(function()
                return object[propName]
            end)
            if success and value ~= nil then
                response = response .. "• " .. propName .. ": " .. tostring(value) .. "\n"
            end
        end
        
        sendAIResponse(response)
    else
        sendAIResponse("❌ Object '" .. searchTerm .. "' not found")
    end
end

-- Show game structure overview
function showGameStructure()
    local structure = "🎮 Game Structure Overview:\n"
    
    local services = {
        "Workspace", "Lighting", "Players", "ReplicatedStorage", 
        "ServerStorage", "StarterPack", "StarterPlayer"
    }
    
    for _, serviceName in pairs(services) do
        local service = game:GetService(serviceName)
        if service then
            structure = structure .. "• " .. serviceName .. ": " .. countChildren(service) .. " items\n"
        end
    end
    
    sendAIResponse(structure)
end

-- Helper function to extract search term from message
function extractSearchTerm(message)
    local patterns = {
        "find%s+(.+)",
        "where%s+is%s+(.+)",
        "locate%s+(.+)",
        "properties%s+of%s+(.+)",
        "what%s+is%s+(.+)"
    }
    
    for _, pattern in ipairs(patterns) do
        local match = message:match(pattern)
        if match then
            return match
        end
    end
    
    return nil
end

-- Helper function to count children recursively
function countChildren(object)
    local count = #object:GetChildren()
    for _, child in pairs(object:GetChildren()) do
        count = count + countChildren(child)
    end
    return count
end

-- Find object by name recursively
function findObjectByName(container, name)
    for _, item in pairs(container:GetChildren()) do
        if item.Name:lower() == name:lower() then
            return item
        end
        
        local found = findObjectByName(item, name)
        if found then
            return found
        end
    end
    return nil
end

-- Get general game structure
function getGameStructure()
    local structure = ""
    
    local majorServices = {
        workspace,
        game:GetService("Lighting"),
        game:GetService("ReplicatedStorage"),
        game:GetService("ServerStorage"),
        game:GetService("StarterPack")
    }
    
    for _, service in pairs(majorServices) do
        structure = structure .. "• " .. service.Name .. ": " .. countChildren(service) .. " items\n"
    end
    
    return structure
end

-- Enhanced development responses
function enhanceDevResponse(message)
    local lowerMessage = message:lower()
    
    if lowerMessage:find("how many") and lowerMessage:find("script") then
        return "I found " .. countScripts() .. " scripts in your game"
        
    elseif lowerMessage:find("what services") then
        return "Available services: " .. table.concat(getServiceNames(), ", ")
        
    elseif lowerMessage:find("game info") then
        return "Game Place ID: " .. game.PlaceId .. ", Players: " .. #game:GetService("Players"):GetPlayers()
        
    elseif lowerMessage:find("help me develop") then
        return "I can help you explore scripts, find objects, analyze structure, and understand your game's architecture!"
    end
    
    return nil
end

-- Count total scripts in game
function countScripts()
    local count = 0
    local containers = {
        workspace,
        game:GetService("ReplicatedStorage"),
        game:GetService("ServerStorage"),
        game:GetService("StarterPack")
    }
    
    for _, container in pairs(containers) do
        count = count + countScriptsInContainer(container)
    end
    
    return count
end

-- Count scripts in container recursively
function countScriptsInContainer(container)
    local count = 0
    
    for _, item in pairs(container:GetChildren()) do
        if item:IsA("Script") or item:IsA("LocalScript") or item:IsA("ModuleScript") then
            count = count + 1
        end
        count = count + countScriptsInContainer(item)
    end
    
    return count
end

-- Get service names
function getServiceNames()
    local names = {}
    local services = game:GetServices()
    for _, service in pairs(services) do
        table.insert(names, service.Name)
    end
    return names
end

-- Show development help
function showDevHelp()
    local helpText = [[
🤖 DEVELOPMENT COMMANDS:

🔍 EXPLORATION:
• "explore workspace" - Show workspace contents
• "find [name]" - Find objects by name
• "show services" - List all services
• "game structure" - Overview of game hierarchy

📜 SCRIPT ANALYSIS:
• "analyze scripts" - Find all scripts
• "find scripts" - Locate script files
• "properties of [object]" - Show object properties

🎮 GAME INFO:
• "player count" - How many players
• "script count" - Total scripts in game
• "service info" - Detailed service information

Try: "find sword" or "explore replicatedstorage"
]]
    sendAIResponse(helpText)
end

-- Send AI response to chat
function sendAIResponse(response)
    wait(math.random(0.5, 1.5))
    
    local success = pcall(function()
        game:GetService("ReplicatedStorage").DefaultChatSystemChatEvents.SayMessageRequest:FireServer("🤖 " .. response, "All")
    end)
    
    if not success then
        game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync("🤖 " .. response)
    end
end

-- Quick commands for developers
PlayerTab:NewButton("🔍 Quick Explore", "Quick game structure analysis", function()
    sendAIResponse("🔍 Quick Analysis:\n" .. getGameStructure())
end)

PlayerTab:NewButton("📜 Script Count", "Count all scripts in game", function()
    sendAIResponse("📜 Total Scripts: " .. countScripts())
end)

PlayerTab:NewButton("🎮 Service Info", "Show all services", function()
    local services = getServiceNames()
    sendAIResponse("🔧 Services: " .. table.concat(services, ", "))
end)

-- Initial notification
Library:Notify("🤖 DEV ASSISTANT", "Game file explorer ready! Try 'explore workspace'", 5, "Info")

-- Auto Attack Script - Spam attacks with movement during combat
local isAutoAttackActive = false
local autoAttackLoop = nil
local lastAttackTime = 0
local attackCooldown = 0.1 -- Much faster cooldown for spam
local isHoldingShift = false
local VirtualInputManager = game:GetService("VirtualInputManager")
local lastMovementTime = 0
local movementCooldown = 0.3

-- Add the first toggle button
PlayerTab:NewToggle("⚔️ Auto Attack", "Spam attacks with movement", function(state)
    isAutoAttackActive = state
    
    if state then
        Library:Notify("⚔️ AUTO ATTACK", "ACTIVE - Spam attacks with movement!", 3, "Success")
        
        if autoAttackLoop then
            autoAttackLoop:Disconnect()
        end
        
        autoAttackLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if not isAutoAttackActive then return end
            autoAttackRoutine()
        end)
        
    else
        Library:Notify("⚔️ AUTO ATTACK", "INACTIVE", 3, "Warning")
        releaseShift() -- Release shift when disabled
        if autoAttackLoop then
            autoAttackLoop:Disconnect()
            autoAttackLoop = nil
        end
    end
end)

-- Add the second toggle button (Smart Attack)
local isSmartAttackActive = false
local smartAttackLoop = nil

PlayerTab:NewToggle("🎯 Smart Auto Attack", "Spam attacks with advanced movement", function(state)
    isSmartAttackActive = state
    
    if state then
        Library:Notify("🎯 SMART ATTACK", "ACTIVE - Advanced combat movement!", 3, "Success")
        
        if smartAttackLoop then
            smartAttackLoop:Disconnect()
        end
        
        smartAttackLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if not isSmartAttackActive then return end
            smartAttackRoutine()
        end)
        
    else
        Library:Notify("🎯 SMART ATTACK", "INACTIVE", 3, "Warning")
        releaseShift() -- Release shift when disabled
        if smartAttackLoop then
            smartAttackLoop:Disconnect()
            smartAttackLoop = nil
        end
    end
end)

-- Shift holding functions
function holdShift()
    if not isHoldingShift then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
        isHoldingShift = true
    end
end

function releaseShift()
    if isHoldingShift then
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
        isHoldingShift = false
    end
end

-- Combat movement functions
function performCombatMovement(character, targetPlayer)
    if not character or not targetPlayer or not targetPlayer.Character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    
    if not humanoid or not rootPart or not targetRoot then return end
    
    -- Only move every movementCooldown seconds
    if tick() - lastMovementTime < movementCooldown then return end
    
    lastMovementTime = tick()
    
    local distance = (rootPart.Position - targetRoot.Position).Magnitude
    
    -- Different movement patterns based on distance
    if distance <= 8 then
        -- Close range: strafe around target
        local movementPatterns = {
            function() strafeLeft(rootPart, targetRoot, humanoid) end,
            function() strafeRight(rootPart, targetRoot, humanoid) end,
            function() circleStrafe(rootPart, targetRoot, humanoid) end,
            function() backAndForward(rootPart, targetRoot, humanoid) end
        }
        
        -- Random movement pattern
        local randomPattern = movementPatterns[math.random(1, #movementPatterns)]
        randomPattern()
        
    elseif distance <= 15 then
        -- Medium range: advance while strafing
        advanceWithStrafing(rootPart, targetRoot, humanoid)
    end
end

function strafeLeft(rootPart, targetRoot, humanoid)
    local rightVector = rootPart.CFrame.RightVector
    local movePosition = rootPart.Position - (rightVector * 4)
    humanoid:MoveTo(movePosition)
end

function strafeRight(rootPart, targetRoot, humanoid)
    local rightVector = rootPart.CFrame.RightVector
    local movePosition = rootPart.Position + (rightVector * 4)
    humanoid:MoveTo(movePosition)
end

function circleStrafe(rootPart, targetRoot, humanoid)
    local directionToTarget = (targetRoot.Position - rootPart.Position).Unit
    local rightVector = rootPart.CFrame.RightVector
    local circlePosition = rootPart.Position + (rightVector * 3) + (directionToTarget * 2)
    humanoid:MoveTo(circlePosition)
end

function backAndForward(rootPart, targetRoot, humanoid)
    local directionToTarget = (targetRoot.Position - rootPart.Position).Unit
    -- Move back a bit then forward
    local moveBackPosition = rootPart.Position - (directionToTarget * 3)
    humanoid:MoveTo(moveBackPosition)
    
    -- After a short delay, move forward
    spawn(function()
        wait(0.2)
        if humanoid and humanoid.Health > 0 then
            local moveForwardPosition = rootPart.Position + (directionToTarget * 2)
            humanoid:MoveTo(moveForwardPosition)
        end
    end)
end

function advanceWithStrafing(rootPart, targetRoot, humanoid)
    local directionToTarget = (targetRoot.Position - rootPart.Position).Unit
    local rightVector = rootPart.CFrame.RightVector
    
    -- Combine forward movement with slight strafing
    local strafeDirection = math.random() > 0.5 and rightVector or -rightVector
    local advancePosition = rootPart.Position + (directionToTarget * 5) + (strafeDirection * 2)
    humanoid:MoveTo(advancePosition)
end

-- Shared functions for both toggles
function autoAttackRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        releaseShift()
        return 
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart or humanoid.Health <= 0 then 
        releaseShift()
        return 
    end
    
    -- Find nearest player
    local nearestPlayer, nearestDistance = findNearestPlayer()
    
    if nearestPlayer and nearestDistance then
        if nearestDistance <= 10 then -- Increased attack range
            -- Player is in attack range - SPAM ATTACKS WITH MOVEMENT!
            releaseShift() -- Release shift when in combat range
            
            -- Perform combat movement
            performCombatMovement(character, nearestPlayer)
            
            -- SPAM ATTACKS (no cooldown check for true spam)
            performSpamAttack()
            
        else
            -- Player is out of range - RUN TO PLAYER!
            holdShift() -- Hold shift when chasing
            moveToPlayer(nearestPlayer, rootPart, humanoid)
        end
    else
        releaseShift()
    end
end

function smartAttackRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        releaseShift()
        return 
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart or humanoid.Health <= 0 then 
        releaseShift()
        return 
    end
    
    -- Check if player has a weapon
    local weapon = character:FindFirstChildOfClass("Tool")
    local attackRange = weapon and 12 or 8 -- Increased range
    
    local nearestPlayer, nearestDistance = findNearestPlayer()
    
    if nearestPlayer and nearestDistance then
        if nearestDistance <= attackRange then
            -- In attack range - SPAM ATTACKS WITH MOVEMENT!
            releaseShift()
            
            -- Advanced combat movement
            performCombatMovement(character, nearestPlayer)
            
            -- Weapon-based spam attacks
            if weapon then
                spamWeaponAttack(weapon)
            else
                spamMeleeAttack()
            end
            
        else
            -- Move to target - RUN FAST!
            holdShift()
            moveToPlayer(nearestPlayer, rootPart, humanoid)
        end
    else
        releaseShift()
    end
end

function findNearestPlayer()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil, math.huge end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil, math.huge end
    
    local nearestPlayer = nil
    local nearestDistance = math.huge
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
            
            if otherRoot and otherHumanoid and otherHumanoid.Health > 0 then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end
    
    return nearestPlayer, nearestDistance
end

function moveToPlayer(targetPlayer, rootPart, humanoid)
    if not targetPlayer or not targetPlayer.Character then 
        releaseShift()
        return 
    end
    
    local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then 
        releaseShift()
        return 
    end
    
    -- Move towards target
    humanoid:MoveTo(targetRoot.Position)
    
    -- Face the target
    rootPart.CFrame = CFrame.new(rootPart.Position, Vector3.new(targetRoot.Position.X, rootPart.Position.Y, targetRoot.Position.Z))
    
    -- Stop running if very close to target
    local distance = (rootPart.Position - targetRoot.Position).Magnitude
    if distance <= 8 then
        releaseShift()
    end
end

-- SPAM ATTACK FUNCTIONS
function performSpamAttack()
    -- Rapid mouse clicks for spam
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.02)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    
    -- Random attack keys for variety
    local attackKeys = {Enum.KeyCode.E, Enum.KeyCode.F, Enum.KeyCode.Q, Enum.KeyCode.R, Enum.KeyCode.Space}
    local randomKey = attackKeys[math.random(1, #attackKeys)]
    
    VirtualInputManager:SendKeyEvent(true, randomKey, false, game)
    wait(0.02)
    VirtualInputManager:SendKeyEvent(false, randomKey, false, game)
    
    -- Create spam attack effects
    createSpamAttackEffects()
end

function spamWeaponAttack(weapon)
    -- Rapid weapon activation
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.01)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    
    -- Additional key presses for combo
    if math.random(1, 3) == 1 then -- 33% chance for extra input
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.R, false, game)
        wait(0.01)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.R, false, game)
    end
    
    createWeaponEffects(weapon)
end

function spamMeleeAttack()
    -- Rapid melee combo
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.01)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    
    -- Additional melee inputs
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
    wait(0.01)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
    
    createAttackEffects()
end

function createSpamAttackEffects()
    local character = game.Players.LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    -- Rapid flash effect for spam attacks
    spawn(function()
        local flash = Instance.new("Part")
        flash.Size = Vector3.new(3, 3, 3)
        flash.Position = rootPart.Position
        flash.BrickColor = BrickColor.new("Bright red")
        flash.Material = Enum.Material.Neon
        flash.Transparency = 0.3
        flash.Anchored = true
        flash.CanCollide = false
        flash.Parent = workspace
        
        game:GetService("Debris"):AddItem(flash, 0.1)
    end)
end

function createAttackEffects()
    local character = game.Players.LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    -- Quick melee effect
    local swing = Instance.new("Part")
    swing.Size = Vector3.new(2, 2, 0.3)
    swing.Position = rootPart.Position + (rootPart.CFrame.LookVector * 2)
    swing.BrickColor = BrickColor.new("Bright orange")
    swing.Material = Enum.Material.Neon
    swing.Anchored = true
    swing.CanCollide = false
    swing.Parent = workspace
    
    game:GetService("Debris"):AddItem(swing, 0.2)
end

function createWeaponEffects(weapon)
    local character = game.Players.LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    -- Quick muzzle flash
    local muzzle = Instance.new("Part")
    muzzle.Size = Vector3.new(0.5, 0.5, 0.5)
    muzzle.Position = rootPart.Position + (rootPart.CFrame.LookVector * 3)
    muzzle.BrickColor = BrickColor.new("Bright yellow")
    muzzle.Material = Enum.Material.Neon
    muzzle.Anchored = true
    muzzle.CanCollide = false
    muzzle.Parent = workspace
    
    game:GetService("Debris"):AddItem(muzzle, 0.1)
end

-- Clean up when script stops
game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
    releaseShift()
end)

-- Initial notification
Library:Notify("⚔️ AUTO ATTACK", "Spam attacks with combat movement enabled!", 4, "Info")

-- Auto TP Attack - Loop TP to nearest player with spam attacks
local isAutoTPAttackActive = false
local autoTPAttackLoop = nil
local currentTarget = nil
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Add the toggle button
PlayerTab:NewToggle("🔁 Killaura Rage", "Loop TP to nearest player with spam attacks", function(state)
    isAutoTPAttackActive = state
    
    if state then
        Library:Notify("🔁 KILLAURA RAGE", "ACTIVE - Teleporting and attacking!", 3, "Success")
        
        if autoTPAttackLoop then
            autoTPAttackLoop:Disconnect()
        end
        
        autoTPAttackLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if not isAutoTPAttackActive then return end
            autoTPAttackRoutine()
        end)
        
    else
        Library:Notify("🔁 KILLAURA RAGE", "INACTIVE", 3, "Warning")
        currentTarget = nil
        if autoTPAttackLoop then
            autoTPAttackLoop:Disconnect()
            autoTPAttackLoop = nil
        end
    end
end)

-- Main TP attack routine
function autoTPAttackRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart or humanoid.Health <= 0 then return end
    
    -- Check if current target is still valid
    if currentTarget then
        if not isTargetValid(currentTarget) then
            -- Target died or became invalid, find new one
            currentTarget = nil
            Library:Notify("🎯 TARGET DOWN", "Finding new target...", 2, "Info")
        end
    end
    
    -- Find new target if needed
    if not currentTarget then
        currentTarget = findNearestPlayer()
        if currentTarget then
            Library:Notify("🎯 NEW TARGET", "Targeting: " .. currentTarget.Name, 2, "Success")
        else
            return -- No targets found
        end
    end
    
    -- TP to target and attack
    if currentTarget and currentTarget.Character then
        local targetRoot = currentTarget.Character:FindFirstChild("HumanoidRootPart")
        if targetRoot then
            -- Teleport behind the target
            local behindOffset = -targetRoot.CFrame.LookVector * 3
            local tpPosition = targetRoot.Position + behindOffset + Vector3.new(0, 3, 0)
            
            -- Teleport to target
            rootPart.CFrame = CFrame.new(tpPosition)
            
            -- Face the target
            rootPart.CFrame = CFrame.new(rootPart.Position, Vector3.new(targetRoot.Position.X, rootPart.Position.Y, targetRoot.Position.Z))
            
            -- Spam attacks
            performSpamAttacks()
        end
    end
end

-- Check if target is still valid (alive and in game)
function isTargetValid(targetPlayer)
    if not targetPlayer then return false end
    if not targetPlayer.Character then return false end
    
    local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    if not humanoid then return false end
    
    return humanoid.Health > 0
end

-- Find nearest player (excluding current target if any)
function findNearestPlayer()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end
    
    local nearestPlayer = nil
    local nearestDistance = math.huge
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
            
            if otherRoot and otherHumanoid and otherHumanoid.Health > 0 then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end
    
    return nearestPlayer
end

-- Perform spam attacks
function performSpamAttacks()
    -- Rapid mouse clicks for spam
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.01)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    
    -- Additional rapid clicks for more spam
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.01)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
end

-- Monitor target health to auto-switch
local targetMonitorLoop = nil

-- Start monitoring target health when toggle is enabled
game:GetService("Players").LocalPlayer.Chatted:Connect(function(message)
    if message:lower() == "start target monitor" and isAutoTPAttackActive and not targetMonitorLoop then
        startTargetMonitor()
    end
end)

function startTargetMonitor()
    if targetMonitorLoop then
        targetMonitorLoop:Disconnect()
    end
    
    targetMonitorLoop = game:GetService("RunService").Heartbeat:Connect(function()
        if not isAutoTPAttackActive then
            if targetMonitorLoop then
                targetMonitorLoop:Disconnect()
                targetMonitorLoop = nil
            end
            return
        end
        
        if currentTarget and currentTarget.Character then
            local humanoid = currentTarget.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then
                Library:Notify("💀 TARGET ELIMINATED", "Moving to next target...", 2, "Warning")
                currentTarget = nil
            end
        end
    end)
end

-- Clean up when script stops
game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
    currentTarget = nil
    if targetMonitorLoop then
        targetMonitorLoop:Disconnect()
        targetMonitorLoop = nil
    end
end)

-- Initial notification
Library:Notify("🔁 KILLAURA RAGE", "Will TP to nearest player and spam attacks!", 4, "Info")

-- KILLAURA LEGIT - PlayerTab Version
local isKillAuraActive = false
local killAuraLoop = nil
local killAuraRange = 10
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Add to PlayerTab only
PlayerTab:NewTextBox("KillAura Range", "Set attack range (1-50 studs)", "10", function(text)
    local newRange = tonumber(text)
    if newRange and newRange >= 1 and newRange <= 50 then
        killAuraRange = newRange
        Library:Notify("KILLAURA", "Range set to: " .. killAuraRange .. " studs", 3)
    else
        Library:Notify("KILLAURA", "Invalid range! Use 1-50", 3)
    end
end)

PlayerTab:NewToggle("KILLAURA LEGIT", "Auto attack players in range", function(state)
    isKillAuraActive = state
    
    if state then
        Library:Notify("KILLAURA", "ACTIVE - Range: " .. killAuraRange .. " studs", 3)
        
        if killAuraLoop then
            killAuraLoop:Disconnect()
        end
        
        killAuraLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if not isKillAuraActive then return end
            killAuraRoutine()
        end)
        
    else
        Library:Notify("KILLAURA", "INACTIVE", 3)
        if killAuraLoop then
            killAuraLoop:Disconnect()
            killAuraLoop = nil
        end
    end
end)

PlayerTab:NewButton("Test KillAura", "Check if players are in range", function()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        Library:Notify("KILLAURA", "No character found!", 3)
        return 
    end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then 
        Library:Notify("KILLAURA", "No root part found!", 3)
        return 
    end
    
    local playersInRange = 0
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherRoot then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                if distance <= killAuraRange then
                    playersInRange = playersInRange + 1
                end
            end
        end
    end
    
    Library:Notify("KILLAURA", "Players in range: " .. playersInRange, 4)
end)

-- KillAura Function
function killAuraRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    -- Check for players in range
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
            
            if otherRoot and otherHumanoid and otherHumanoid.Health > 0 then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                
                if distance <= killAuraRange then
                    -- Attack the player
                    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
                    wait(0.02)
                    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
                    return
                end
            end
        end
    end
end

-- Clean up
game.Players.LocalPlayer.CharacterRemoving:Connect(function()
    if killAuraLoop then
        killAuraLoop:Disconnect()
        killAuraLoop = nil
    end
    isKillAuraActive = false
end)

Library:Notify("KILLAURA LEGIT", "Loaded in PlayerTab!", 5)

-- GAME TAB CONTENT
GameTab:NewText("=== GAME TELEPORTS ===")

GameTab:NewText("Red Light Green Light")

GameTab:NewButton("RLGL - Teleport To End", function()
	local char = localPlayer.Character
	char.HumanoidRootPart.CFrame = CFrame.new(-46.0587921, 1025.23352, 108.6353122)
end)

GameTab:NewButton("RLGL - Teleport To Start", function()
	local char = localPlayer.Character
	char.HumanoidRootPart.CFrame = CFrame.new(-48.5137215, 1024.521, -492.023163)
end)

-- Get all player usernames
local function getPlayerList()
	local playerList = {}
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= localPlayer then
			table.insert(playerList, player.Name)
		end
	end
	return playerList
end

-- Find player by username
local function getPlayerByName(name)
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Name == name then
			return player
		end
	end
	return nil
end
-- Auto help function
local function autoHelp()
	local playerList = getPlayerList()
	local targetPlayer = nil
	local targetPlayerName = nil
	local to = Players:GetAttribute("InjuredPlayer")
end

local NEVERAURA = false
local MAYBEAURA = false

GameTab:NewToggle("ANTI SHOT!!", false, function()
	MAYBEAURA = not MAYBEAURA
	local char = localPlayer.Character
	while true do
		if MAYBEAURA == true then
			char.Parent = workspace.Live.GreenPlayers
			if char:FindFirstChild("MovedRecentlyRedLight") then
				char.SafeRedLightGreenLight:Destroy()
			end
			if char:FindFirstChild("SafeRedLightGreenLight") then
				char.SafeRedLightGreenLight:Destroy()
			end

			local folder = Instance.new("Folder")
			folder.Parent = char
			folder.Name = "SafeRedLightGreenLight"
		end
		task.wait()
	end
end)

GameTab:NewToggle("RLGL - Auto Help", false, function()
	NEVERAURA = not NEVERAURA
end)

GameTab:NewDivider()

GameTab:NewText("Dalgona")

local NOTDELETEABLE = {"Lighting", "Won", "PickModelCacheFix"}

local shapes = {"Star", "Circle", "Umbrella", "MonaLisa", "Triangle", "SackBoy"}
local outlineParts = {}
local connection = nil
local clickConnections = {}

local function createOutline(shape)
	-- Clear existing outline
	for _, part in pairs(outlineParts) do
		part:Destroy()
	end
	outlineParts = {}

	if not shape then return end

	local cf, size = shape:GetBoundingBox()
	local thickness = 0.3
	local padding = 0.5
	local outlineSize = size + Vector3.new(padding * 2, padding * 2, padding * 2)

	local edges = {
		{pos = Vector3.new(outlineSize.X/2, -outlineSize.Y/2, 0), size = Vector3.new(thickness, thickness, outlineSize.Z)},
		{pos = Vector3.new(-outlineSize.X/2, -outlineSize.Y/2, 0), size = Vector3.new(thickness, thickness, outlineSize.Z)},
		{pos = Vector3.new(0, -outlineSize.Y/2, outlineSize.Z/2), size = Vector3.new(outlineSize.X, thickness, thickness)},
		{pos = Vector3.new(0, -outlineSize.Y/2, -outlineSize.Z/2), size = Vector3.new(outlineSize.X, thickness, thickness)},
		{pos = Vector3.new(outlineSize.X/2, outlineSize.Y/2, 0), size = Vector3.new(thickness, thickness, outlineSize.Z)},
		{pos = Vector3.new(-outlineSize.X/2, outlineSize.Y/2, 0), size = Vector3.new(thickness, thickness, outlineSize.Z)},
		{pos = Vector3.new(0, outlineSize.Y/2, outlineSize.Z/2), size = Vector3.new(outlineSize.X, thickness, thickness)},
		{pos = Vector3.new(0, outlineSize.Y/2, -outlineSize.Z/2), size = Vector3.new(outlineSize.X, thickness, thickness)},
		{pos = Vector3.new(outlineSize.X/2, 0, outlineSize.Z/2), size = Vector3.new(thickness, outlineSize.Y, thickness)},
		{pos = Vector3.new(-outlineSize.X/2, 0, outlineSize.Z/2), size = Vector3.new(thickness, outlineSize.Y, thickness)},
		{pos = Vector3.new(outlineSize.X/2, 0, -outlineSize.Z/2), size = Vector3.new(thickness, outlineSize.Y, thickness)},
		{pos = Vector3.new(-outlineSize.X/2, 0, -outlineSize.Z/2), size = Vector3.new(thickness, outlineSize.Y, thickness)},
	}

	for _, edge in pairs(edges) do
		local part = Instance.new("Part")
		part.Size = edge.size
		part.Anchored = true
		part.CanCollide = false
		part.Material = Enum.Material.Neon
		part.Color = Color3.fromRGB(0, 255, 0)
		part.Transparency = 0
		part.Parent = workspace
		table.insert(outlineParts, part)
	end

	if connection then connection:Disconnect() end
	connection = RunService.RenderStepped:Connect(function()
		if not shape or not shape.Parent then
			for _, part in pairs(outlineParts) do
				part:Destroy()
			end
			outlineParts = {}
			if connection then connection:Disconnect() end
			return
		end

		local newCf = shape:GetBoundingBox()
		for i, part in pairs(outlineParts) do
			part.CFrame = newCf * CFrame.new(edges[i].pos)
		end
	end)

	print("Outline created!")
end

GameTab:NewButton("Auto Cookie", function()
	local Module = game.ReplicatedStorage.Modules.Games.DalgonaClient
	for _, f in ipairs(getreg()) do
		if typeof(f) == "function" and islclosure(f) then
			if getfenv(f).script == Module then
				if getinfo(f).nups == 76 then
					setupvalue(f, 33, 9e9)
					setupvalue(f, 34, 9e9)
					break
				end
			end
		end
	end
end)

-- ESP Configuration
local espSeekersEnabled = false
local espHidersEnabled = false

-- Function to check if player has a knife (is a seeker)
local function isSeeker(player)
	if not player then return false end

	-- Check character for knife
	if player.Character and player.Character:FindFirstChild("Knife") then
		return true
	end

	-- Check backpack for knife
	local backpack = player:FindFirstChild("Backpack")
	if backpack and backpack:FindFirstChild("Knife") then
		return true
	end

	return false
end

-- Create simple box ESP
local function createBox(character, color)
	if not character or not character:FindFirstChild("HumanoidRootPart") then return end

	-- Remove existing box
	local existingBox = character:FindFirstChild("ESPBox")
	if existingBox then
		existingBox:Destroy()
	end

	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	local humanoid = character:FindFirstChild("Humanoid")

	-- Determine target part based on rig type
	local targetPart = humanoidRootPart
	if humanoid then
		if humanoid.RigType == Enum.HumanoidRigType.R6 then
			targetPart = character:FindFirstChild("Torso") or humanoidRootPart
		else
			targetPart = character:FindFirstChild("LowerTorso") or humanoidRootPart
		end
	end

	-- Create BillboardGui for box
	local boxGui = Instance.new("BillboardGui")
	boxGui.Name = "ESPBox"
	boxGui.Parent = character
	boxGui.Size = UDim2.new(4, 0, 6, 0)
	boxGui.StudsOffset = Vector3.new(0, 0, 0)
	boxGui.Adornee = targetPart
	boxGui.AlwaysOnTop = true
	boxGui.ZIndexBehavior = Enum.ZIndexBehavior.Global

	-- Container frame
	local containerFrame = Instance.new("Frame")
	containerFrame.Parent = boxGui
	containerFrame.Size = UDim2.new(1, 0, 1, 0)
	containerFrame.BackgroundTransparency = 1

	-- Create box edges (Top, Bottom, Left, Right)
	local edges = {
		{UDim2.new(1, 0, 0, 2), UDim2.new(0, 0, 0, 0)}, -- Top
		{UDim2.new(1, 0, 0, 2), UDim2.new(0, 0, 1, -2)}, -- Bottom
		{UDim2.new(0, 2, 1, 0), UDim2.new(0, 0, 0, 0)}, -- Left
		{UDim2.new(0, 2, 1, 0), UDim2.new(1, -2, 0, 0)} -- Right
	}

	for _, data in ipairs(edges) do
		local edge = Instance.new("Frame")
		edge.Parent = containerFrame
		edge.Size = data[1]
		edge.Position = data[2]
		edge.BackgroundColor3 = color
		edge.BorderSizePixel = 0
	end
end

-- Remove box from character
local function removeBox(character)
	if not character then return end
	local box = character:FindFirstChild("ESPBox")
	if box then
		box:Destroy()
	end
end

-- Update ESP for a single player
local function updatePlayerESP(player)
	if not player or player == localPlayer then return end
	if not player.Character then return end

	local isSeekerRole = isSeeker(player)

	-- Check if we should show ESP
	if (isSeekerRole and espSeekersEnabled) then
		createBox(player.Character, Color3.new(1, 0, 0)) -- Red for seeker
	elseif (not isSeekerRole and espHidersEnabled) then
		createBox(player.Character, Color3.new(0, 0, 1)) -- Blue for hider
	else
		removeBox(player.Character)
	end
end

-- Update all players ESP
local function updateAllESP()
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= localPlayer then
			updatePlayerESP(player)
		end
	end
end

-- Remove all ESP boxes
local function removeAllESP()
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character then
			removeBox(player.Character)
		end
	end
end

-- Setup player monitoring
local function setupPlayer(player)
	if player == localPlayer then return end

	-- Monitor character added
	player.CharacterAdded:Connect(function(character)
		task.wait(0.5) -- Wait for character to fully load
		updatePlayerESP(player)
	end)

	-- Monitor existing character
	if player.Character then
		-- Monitor for knife changes
		player.Character.ChildAdded:Connect(function(child)
			if child.Name == "Knife" then
				task.wait(0.1)
				updatePlayerESP(player)
			end
		end)

		player.Character.ChildRemoved:Connect(function(child)
			if child.Name == "Knife" then
				task.wait(0.1)
				updatePlayerESP(player)
			end
		end)
	end

	-- Monitor backpack
	local backpack = player:FindFirstChild("Backpack")
	if backpack then
		backpack.ChildAdded:Connect(function(child)
			if child.Name == "Knife" then
				task.wait(0.1)
				updatePlayerESP(player)
			end
		end)

		backpack.ChildRemoved:Connect(function(child)
			if child.Name == "Knife" then
				task.wait(0.1)
				updatePlayerESP(player)
			end
		end)
	end
end

-- Initialize ESP system
local function initializeESP()
	-- Setup existing players
	for _, player in ipairs(Players:GetPlayers()) do
		setupPlayer(player)
	end

	-- Setup new players
	Players.PlayerAdded:Connect(setupPlayer)

	-- Cleanup when players leave
	Players.PlayerRemoving:Connect(function(player)
		if player.Character then
			removeBox(player.Character)
		end
	end)
end

-- Start the ESP system
initializeESP()

GameTab:NewDivider()

GameTab:NewText("Final Dinner / HNS")

GameTab:NewButton("Final Dinner - Teleport To Safe Spot", function()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	if char and char:FindFirstChild("HumanoidRootPart") then
		char.HumanoidRootPart.CFrame = CFrame.new(182.413818, 121.033997, -93.8286514)
	end
end)

GameTab:NewToggle("ESP Seekers", false, function(state)
	espSeekersEnabled = state
	updateAllESP()
	print("ESP Seekers:", state and "Enabled" or "Disabled")
end)

GameTab:NewToggle("ESP Hiders", false, function(state)
	espHidersEnabled = state
	updateAllESP()
	print("ESP Hiders:", state and "Enabled" or "Disabled")
end)

GameTab:NewButton("HNS - ESP Exit", function()
	for i, floor1doors in pairs(game.Workspace.HideAndSeekMap.NEWFIXEDDOORS.Floor1.EXITDOORS:GetChildren()) do
		Instance.new("Highlight", floor1doors)
	end
	for i, floor2doors in pairs(game.Workspace.HideAndSeekMap.NEWFIXEDDOORS.Floor2.EXITDOORS:GetChildren()) do
		Instance.new("Highlight", floor2doors)
	end
	for i, floor3doors in pairs(game.Workspace.HideAndSeekMap.NEWFIXEDDOORS.Floor3.EXITDOORS:GetChildren()) do
		Instance.new("Highlight", floor3doors)
	end
end)

GameTab:NewButton("HNS - Delete The Spikes", function()
	game.Workspace.HideAndSeekMap.KillingParts:Destroy()
end)

-- Loopkill Variables
local selectedTarget = nil
local loopkillEnabled = false
local loopkillConnection = nil
local lastAttackTime = 0
local attackCooldown = 0.3

-- Get all player usernames
local function getPlayerList()
	local playerList = {}
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= localPlayer then
			table.insert(playerList, player.Name)
		end
	end
	return playerList
end

-- Find player by username
local function getPlayerByName(name)
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Name == name then
			return player
		end
	end
	return nil
end

-- Get damage tool (Knife, Fork, or Bottle)
local function getDamageTool()
	local character = localPlayer.Character
	if not character then return nil end

	-- Check if tool is equipped in character
	local knife = character:FindFirstChild("Knife")
	if knife and knife:IsA("Tool") then return knife end

	local fork = character:FindFirstChild("Fork")
	if fork and fork:IsA("Tool") then return fork end

	local bottle = character:FindFirstChild("Bottle")
	if bottle and bottle:IsA("Tool") then return bottle end

	-- Check backpack
	local backpack = localPlayer:FindFirstChild("Backpack")
	if backpack then
		knife = backpack:FindFirstChild("Knife")
		if knife and knife:IsA("Tool") then return knife end

		fork = backpack:FindFirstChild("Fork")
		if fork and fork:IsA("Tool") then return fork end

		bottle = backpack:FindFirstChild("Bottle")
		if bottle and bottle:IsA("Tool") then return bottle end
	end

	return nil
end

-- Equip the damage tool
local function equipDamageTool()
	local tool = getDamageTool()
	if not tool then return false end

	-- If tool is in backpack, equip it
	if tool.Parent == localPlayer.Backpack then
		localPlayer.Character.Humanoid:EquipTool(tool)
		task.wait(0.1)
	end

	return true
end

-- Calculate orbit position around target
local function getOrbitPosition(targetPosition, angle, radius)
	local x = targetPosition.X + math.cos(angle) * radius
	local z = targetPosition.Z + math.sin(angle) * radius
	return Vector3.new(x, targetPosition.Y, z)
end

local function performLoopkill()
	if not loopkillEnabled or not selectedTarget then return end
	local targetPlayer = getPlayerByName(selectedTarget)
	if not targetPlayer or not targetPlayer.Character then return end
	local targetChar = targetPlayer.Character
	local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
	local targetHumanoid = targetChar:FindFirstChild("Humanoid")
	if not targetRoot or not targetHumanoid or targetHumanoid.Health <= 0 then return end
	local character = localPlayer.Character
	if not character then return end
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end
	-- Equip damage tool
	if not equipDamageTool() then
		warn("No damage tool found (Knife, Fork, or Bottle)")
		return
	end
	local tool = getDamageTool()
	if not tool or tool.Parent ~= character then return end
	-- Calculate orbit angle based on time
	local currentTime = tick()
	local angle = (currentTime * 3) % (math.pi * 2) -- Rotate around target
	local radius = 1 -- Distance from target (closer)
	-- Get orbit position
	local orbitPos = getOrbitPosition(targetRoot.Position, angle, radius)
	-- Teleport to orbit position
	humanoidRootPart.CFrame = CFrame.new(orbitPos, targetRoot.Position)
	-- Attack every 0.1 seconds
	if currentTime - lastAttackTime >= 0.1 then
		-- Activate the tool to damage
		if tool:FindFirstChild("Handle") then
			-- Fire remote or activate tool
			local remoteEvent = tool:FindFirstChildWhichIsA("RemoteEvent")
			local remoteFunction = tool:FindFirstChildWhichIsA("RemoteFunction")
			if remoteEvent then
				pcall(function()
					remoteEvent:FireServer()
				end)
			end
			if remoteFunction then
				pcall(function()
					remoteFunction:InvokeServer()
				end)
			end
			-- Try to activate tool
			pcall(function()
				tool:Activate()
			end)
		end
		lastAttackTime = currentTime
	end
end

GameTab:NewDivider()
GameTab:NewText("Tug of War")

local tugOfWarAutoEnabled = false
local tugOfWarAutoThread = nil
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remote = ReplicatedStorage.Remotes:WaitForChild("TemporaryReachedBindable")
local VALID_PULL_DATA = { { IHateYou = true } }

GameTab:NewToggle("Tug of War Auto", false, function(Value)
	tugOfWarAutoEnabled = Value
	if Value then
		if tugOfWarAutoThread then return end
		tugOfWarAutoThread = task.spawn(function()
			while tugOfWarAutoEnabled do
				Remote:FireServer(unpack(VALID_PULL_DATA))
				task.wait(0.025)
			end
			tugOfWarAutoThread = nil
		end)
	else
		tugOfWarAutoEnabled = false
		if tugOfWarAutoThread then
			task.cancel(tugOfWarAutoThread)
			tugOfWarAutoThread = nil
		end
	end
end)
--[[
REBEL:
THE GUARDS CONTAIN: "RebelGuard"
Folder: game.Workspace.Live
]]

-- Start loopkill
local function startLoopkill()
	if loopkillConnection then
		loopkillConnection:Disconnect()
	end

	loopkillConnection = RunService.Heartbeat:Connect(function()
		if loopkillEnabled and selectedTarget then
			pcall(performLoopkill)
		end
	end)

	print("Loopkill started on:", selectedTarget)
end

-- Stop loopkill
local function stopLoopkill()
	if loopkillConnection then
		loopkillConnection:Disconnect()
		loopkillConnection = nil
	end

	print("Loopkill stopped")
end

-- Player dropdown
local playerDropdown = GameTab:NewDropdown("Select Target", getPlayerList(), nil, function(selected)
	selectedTarget = selected
	print("Target selected:", selectedTarget)

	-- If loopkill is already enabled, restart with new target
	if loopkillEnabled then
		stopLoopkill()
		startLoopkill()
	end
end)

-- Loopkill toggle
local aura = GameTab:NewToggle("Kill aura", false, function(state)
	loopkillEnabled = state

	if state then
		if not selectedTarget then
			warn("Please select a target first!")
			loopkillEnabled = false
			return
		end

		if not getDamageTool() then
			warn("You need a Knife, Fork, or Bottle to use loopkill!")
			loopkillEnabled = false
			return
		end

		startLoopkill()
	else
		stopLoopkill()
	end
end)

-- Update player list when players join/leave
Players.PlayerAdded:Connect(function()
	task.wait(0.5)
	-- Note: You'd need to manually refresh the dropdown or add an update function
	print("Player joined - consider refreshing target list")
end)

Players.PlayerRemoving:Connect(function(player)
	if selectedTarget == player.Name then
		selectedTarget = nil
		loopkillEnabled = false
		stopLoopkill()
		print("Target left the game - loopkill disabled")
	end
end)

-- Clean up on death
localPlayer.CharacterAdded:Connect(function()
	task.wait(1)
	if loopkillEnabled then
		print("Respawned - restarting loopkill")
	end
end)

GameTab:NewDivider()

GameTab:NewText("Jump Rope")
GameTab:NewButton("Jump Rope - Teleport To End", function()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	if char and char:FindFirstChild("HumanoidRootPart") then
		char.HumanoidRootPart.CFrame = CFrame.new(720.896057, 198.628311, 921.170654)
	end
end)

GameTab:NewButton("Jump Rope - Delete The Rope", function()
	game.Workspace.Effects.rope:Destroy()
end)

GameTab:NewDivider()

GameTab:NewText("Glass Bridge")
GameTab:NewButton("Glass Bridge - Teleport To End", function()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	if char and char:FindFirstChild("HumanoidRootPart") then
		char.HumanoidRootPart.CFrame = CFrame.new(-196.372467, 522.192139, -1534.20984)
	end
end)

GameTab:NewButton("Glass Bridge Fake Glass", function()
	CreateGlassBridgeCover()
end)

GameTab:NewButton("Glass Esp", function()
	local GlassHolder = workspace:WaitForChild("GlassBridge"):WaitForChild("GlassHolder")

	for i, v in pairs(GlassHolder:GetChildren()) do
		for g, j in pairs(v:GetChildren()) do
			if j:IsA("Model") and j.PrimaryPart then
				local Color = j.PrimaryPart:GetAttribute("exploitingisevil") 
					and Color3.fromRGB(248, 87, 87) 
					or Color3.fromRGB(28, 235, 87)
				j.PrimaryPart.Color = Color
				j.PrimaryPart.Transparency = 0
				j.PrimaryPart.Material = Enum.Material.Neon
			end
		end
	end
end)

local RebelBring = false
local guardConnection = nil

local function bringGuardsRebel()
	RebelBring = not RebelBring

	if RebelBring then
		local Players = game:GetService("Players")
		local localPlayer = Players.LocalPlayer

		-- Function to teleport a single guard
		local function teleportGuard(guard)
			local character = localPlayer.Character
			if not character then return end

			local rootPart = character:FindFirstChild("HumanoidRootPart")
			if not rootPart then return end

			local guardRoot = guard:FindFirstChild("HumanoidRootPart") or guard:FindFirstChild("Torso")

			if guardRoot and guardRoot:IsA("BasePart") then
				guardRoot.CFrame = rootPart.CFrame * CFrame.new(0, 0, -10)
			elseif guard:IsA("Model") then
				guard:MoveTo((rootPart.CFrame * CFrame.new(0, 0, -10)).Position)
			end
		end

		-- Teleport all existing guards
		local liveFolder = game.Workspace:FindFirstChild("Live")
		if liveFolder then
			for _, child in ipairs(liveFolder:GetChildren()) do
				if string.find(child.Name, "RebelGuard") then
					teleportGuard(child)
				end
			end

			-- Monitor for new guards and auto-teleport them
			guardConnection = liveFolder.ChildAdded:Connect(function(child)
				if RebelBring and string.find(child.Name, "RebelGuard") then
					task.wait(0.5)
					teleportGuard(child)
				end
			end)

			print("RebelGuard auto-bring enabled")
		end
	else
		-- Disconnect the monitoring when disabled
		if guardConnection then
			guardConnection:Disconnect()
			guardConnection = nil
		end
		print("RebelGuard auto-bring disabled")
	end
end

local function aimbotRebelGuards()
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local localPlayer = Players.LocalPlayer
	local camera = workspace.CurrentCamera

	local aimbotConnection = nil
	local isAimbotActive = false

	return function(toggle)
		isAimbotActive = toggle

		if isAimbotActive then
			aimbotConnection = RunService.RenderStepped:Connect(function()
				if not isAimbotActive then return end

				local character = localPlayer.Character
				if not character then return end

				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if not rootPart then return end

				local liveFolder = game.Workspace:FindFirstChild("Live")
				if not liveFolder then return end

				-- Find closest RebelGuard
				local closestGuard = nil
				local shortestDistance = math.huge

				for _, child in ipairs(liveFolder:GetChildren()) do
					if string.find(child.Name, "RebelGuard") then
						local guardHead = child:FindFirstChild("Head")
						local guardHumanoid = child:FindFirstChild("Humanoid")

						if guardHead and guardHumanoid and guardHumanoid.Health > 0 then
							local distance = (rootPart.Position - guardHead.Position).Magnitude

							if distance < shortestDistance then
								shortestDistance = distance
								closestGuard = guardHead
							end
						end
					end
				end

				-- Aim at closest guard
				if closestGuard then
					camera.CFrame = CFrame.new(camera.CFrame.Position, closestGuard.Position)
				end
			end)

			print("RebelGuard aimbot enabled")
		else
			if aimbotConnection then
				aimbotConnection:Disconnect()
				aimbotConnection = nil
			end
			print("RebelGuard aimbot disabled")
		end
	end
end

GameTab:NewDivider()
GameTab:NewText("Rebel")

GameTab:NewToggle("Bring Guards", false, function(state)
	while true do
		task.wait()
		if state then
			bringGuardsRebel()
		else
			bringGuardsRebel()
		end
	end
end)

GameTab:NewToggle("Aimbot Guards", false, function(state)
	if state then
		aimbotRebelGuards(true)
	else
		aimbotRebelGuards(false)
	end
end)

GameTab:NewDivider()
GameTab:NewText("Mingle [coming soon]")

GameTab:NewButton("Teleport To Room", function()
	local char = localPlayer.Character
	char.HumanoidRootPart.CFrame = CFrame.new(1170.68262, 403.950592, -486.154968)
end)

GameTab:NewDivider()
GameTab:NewText("Final Sky squid Game[SKY SQUID]")

GameTab:NewButton("Anti fall", function()
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")

	local player = Players.LocalPlayer
	repeat task.wait() until player.Character and player.Character:FindFirstChild("HumanoidRootPart")
	local character = player.Character
	local rootPart = character:WaitForChild("HumanoidRootPart")
	local startingY = rootPart.Position.Y
	local fallLimit = startingY - 5
	local teleported = false

	RunService.RenderStepped:Connect(function()
		if not rootPart or not rootPart.Parent then return end
		if rootPart.Position.Y < fallLimit and not teleported then
			teleported = true
			local nearestPlayer
			local nearestDist = math.huge
			for _, other in ipairs(Players:GetPlayers()) do
				if other ~= player and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
					local hum = other.Character:FindFirstChild("Humanoid")
					if hum and hum.Health > 0 then
						local dist = (rootPart.Position - other.Character.HumanoidRootPart.Position).Magnitude
						if dist < nearestDist then
							nearestDist = dist
							nearestPlayer = other
						end
					end
				end
			end
			if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("HumanoidRootPart") then
				local targetRoot = nearestPlayer.Character.HumanoidRootPart
				local direction = (rootPart.Position - targetRoot.Position).Unit
				rootPart.CFrame = CFrame.new(targetRoot.Position + direction * 3)
			else
				rootPart.CFrame = CFrame.new(rootPart.Position.X, startingY, rootPart.Position.Z)
			end
		end
		if rootPart.Position.Y >= startingY - 1 then
			teleported = false
		end
	end)
end)

-- Auto QTE for Specific Game (E,F,Q,R + Mobile)
GameTab:NewToggle("Auto QTE universal", "Automatically complete E,F,Q,R QTEs for PC and Mobile", function(state)
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local player = Players.LocalPlayer
    local autoQTEConnection = nil
    
    local isMobile = UserInputService.TouchEnabled
    local lastQTE = 0
    local qteCooldown = 0.1
    
    -- Game-specific QTE detection
    local function detectGameQTEs()
        -- Method 1: Look for QTE GUI elements (from your images)
        local gui = player:FindFirstChild("PlayerGui")
        if gui then
            -- Look for specific QTE GUI names from your images
            local qteGUIs = {
                "QTEGui", "GuiQTE", "ScreenGuiBotones", "FrameContenedorQTE",
                "FrameQTE", "FramePermisosYMas", "TextButtonQTE"
            }
            
            for _, guiName in pairs(qteGUIs) do
                local qteGui = gui:FindFirstChild(guiName, true)
                if qteGui and qteGui.Visible then
                    return true
                end
            end
            
            -- Look for QTE text (E, F, Q, R, TAP)
            local function searchForQTE(obj)
                if obj:IsA("TextLabel") or obj:IsA("TextButton") then
                    local text = obj.Text:upper()
                    if text == "E" or text == "F" or text == "Q" or text == "R" or text == "TAP" then
                        if obj.Visible and obj.Size ~= UDim2.new(0, 0, 0, 0) then
                            return true
                        end
                    end
                end
                
                for _, child in pairs(obj:GetChildren()) do
                    if searchForQTE(child) then
                        return true
                    end
                end
                return false
            end
            
            for _, screenGui in pairs(gui:GetChildren()) do
                if screenGui:IsA("ScreenGui") and screenGui.Enabled then
                    if searchForQTE(screenGui) then
                        return true
                    end
                end
            end
        end
        
        -- Method 2: Check QTE stats (from your leaderstats images)
        local character = player.Character
        if character then
            local leaderstats = character:FindFirstChild("leaderstats")
            if leaderstats then
                local qteStats = leaderstats:FindFirstChild("QTEAvgPercent") or leaderstats:FindFirstChild("QTESuccesses")
                if qteStats then
                    -- If QTE stats exist, there might be active QTEs
                    return true
                end
            end
        end
        
        -- Method 3: Check ReplicatedStorage for QTE events (from your images)
        local qteConfig = ReplicatedStorage:FindFirstChild("QTEConfig")
        local qteSaveEvent = ReplicatedStorage:FindFirstChild("QTESaveEvent")
        local qteSession = ReplicatedStorage:FindFirstChild("QTESESSION")
        
        if qteConfig or qteSaveEvent or qteSession then
            -- QTE system is present in the game
            return true
        end
        
        return false
    end
    
    -- Function to press specific QTE keys (E, F, Q, R)
    local function pressQTEEFQR()
        if tick() - lastQTE < qteCooldown then
            return
        end
        
        lastQTE = tick()
        
        if isMobile then
            -- MOBILE: Simulate tap for E,F,Q,R buttons
            local gui = player:FindFirstChild("PlayerGui")
            if gui then
                -- Look for specific QTE buttons to tap
                local buttonsToTap = {"E", "F", "Q", "R", "TAP"}
                
                for _, buttonText in pairs(buttonsToTap) do
                    local function findButton(obj)
                        if obj:IsA("TextButton") and obj.Text:upper() == buttonText then
                            if obj.Visible and obj.Active then
                                local absPos = obj.AbsolutePosition
                                local absSize = obj.AbsoluteSize
                                
                                if absPos and absSize then
                                    local centerX = absPos.X + (absSize.X / 2)
                                    local centerY = absPos.Y + (absSize.Y / 2)
                                    
                                    -- Simulate tap on the button
                                    VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
                                    wait(0.05)
                                    VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
                                    
                                    Library:Notify("[AUTO QTE]", "Tapped: " .. buttonText, 1, "Success")
                                    return true
                                end
                            end
                        end
                        
                        for _, child in pairs(obj:GetChildren()) do
                            if findButton(child) then
                                return true
                            end
                        end
                        return false
                    end
                    
                    for _, screenGui in pairs(gui:GetChildren()) do
                        if screenGui:IsA("ScreenGui") then
                            if findButton(screenGui) then
                                return
                            end
                        end
                    end
                end
            end
            
            -- Fallback: tap center screen
            local screenSize = workspace.CurrentCamera.ViewportSize
            VirtualInputManager:SendMouseButtonEvent(
                screenSize.X / 2, 
                screenSize.Y / 2, 
                0, true, game, 1
            )
            wait(0.05)
            VirtualInputManager:SendMouseButtonEvent(
                screenSize.X / 2, 
                screenSize.Y / 2, 
                0, false, game, 1
            )
            
            Library:Notify("[AUTO QTE]", "Mobile Tap (Fallback)", 1, "Info")
            
        else
            -- PC: Press E, F, Q, R keys in sequence (from your game config)
            local keysToPress = {
                Enum.KeyCode.E,
                Enum.KeyCode.F, 
                Enum.KeyCode.Q,
                Enum.KeyCode.R
            }
            
            local pressedKeys = {}
            
            for _, key in pairs(keysToPress) do
                VirtualInputManager:SendKeyEvent(true, key, false, game)
                wait(0.03)
                VirtualInputManager:SendKeyEvent(false, key, false, game)
                wait(0.05)
                
                table.insert(pressedKeys, key.Name)
            end
            
            Library:Notify("[AUTO QTE]", "Pressed: " .. table.concat(pressedKeys, ", "), 1, "Success")
        end
    end
    
    -- Handle timeout buffer (from your game config)
    local function handleTimeoutBuffer()
        -- Your game has timeout buffer of 0.25 seconds
        -- We need to be faster than this
        local timeoutBuffer = 0.25
        local reactionTime = 0.05 -- Our reaction time
        
        if reactionTime < timeoutBuffer then
            return true
        end
        return false
    end
    
    -- Main QTE detection loop optimized for your game
    local function gameQTECheck()
        if detectGameQTEs() then
            if handleTimeoutBuffer() then
                pressQTEEFQR()
            end
        end
    end
    
    -- Toggle functionality
    if state then
        if isMobile then
            Library:Notify("[AUTO QTE]", "Mobile E,F,Q,R Auto-Tap Enabled", 4, "Success")
        else
            Library:Notify("[AUTO QTE]", "PC E,F,Q,R Auto-Press Enabled", 4, "Success")
        end
        
        if not autoQTEConnection then
            autoQTEConnection = RunService.Heartbeat:Connect(gameQTECheck)
        end
    else
        Library:Notify("[AUTO QTE]", "Disabled", 3, "Warning")
        if autoQTEConnection then
            autoQTEConnection:Disconnect()
            autoQTEConnection = nil
        end
    end
end)

GameTab:NewDivider()
GameTab:NewText("ALL")

local AURAGAINER = false -- LOL U GUYS GOT NO AURA

GameTab:NewToggle("Auto Win", false, function()
	local values = game.Workspace.Values
	local char = localPlayer.Character

	AURAGAINER = not AURAGAINER

	while true do
		if AURAGAINER == true then
			task.wait(0.05) -- anti lag
			if values.CurrentGame.Value == "RedLightGreenLight" then
				char.HumanoidRootPart.CFrame = CFrame.new(-46.0587921, 1025.23352, 108.6353122)
			elseif values.CurrentGame.Value == "Dalgona" then

			elseif values.CurrentGame.Value == "TugOfWar" then

			elseif values.CurrentGame.Value == "LightsOut" then
				char.HumanoidRootPart.CFrame = CFrame.new(294.185852, 55.7636185, -3.9290698)
			elseif values.CurrentGame.Value == "HideAndSeek" then
				if localPlayer.Backpack:FindFirstChild("Knife") or char:FindFirstChild("Knife") then
					local Splayer = math.random(1, #Players)
					local Selected = Players[Splayer]

					while Selected.Backpack:FindFirstChild("Knife") or char:FindFirstChild("Knife") do
						Splayer = math.random(1, #Players)
						Selected = Players[Splayer]
					end
					performLoopkill(Splayer)
				else
					char.HumanoidRootPart.CFrame = CFrame.new(196.83342, 55.9547985, -90.4745865)
				end
			elseif values.CurrentGame.Value == "JumpRope" then
				char.HumanoidRootPart.CFrame = CFrame.new(720.896057, 198.628311, 921.170654)
			elseif values.CurrentGame.Value == "GlassBridge" then
				char.HumanoidRootPart.CFrame = CFrame.new(-196.372467, 522.192139, -1534.20984)
			elseif values.CurrentGame.Value == "Mingle" then
				char.HumanoidRootPart.CFrame = CFrame.new(1170.68262, 403.950592, -486.154968)
			elseif values.CurrentGame.Value == "SkySquidGame" then
				char.HumanoidRootPart.CFrame = CFrame.new(2730.44263,1043.33435,800.130554)
			elseif values.CurrentGame.Value == "SquidGame" then

			end
		else
			task.wait(0.05)
		end
	end
end)

GameTab:NewDivider()
GameTab:NewText("Game Entrances")

GameTab:NewButton("Dalgona Entrance", function()
	local char = localPlayer.Character
	char.PrimaryPart.CFrame = CFrame.new(-222.226, 230.93, 406.97)
end)

GameTab:NewButton("HNS/TUG Entrance", function()
	local char = localPlayer.Character
	char.PrimaryPart.CFrame = CFrame.new(-469.221, 245.556, 448.558)
end)

GameTab:NewButton("Jump Rope Entrance", function()
	local char = localPlayer.Character
	char.PrimaryPart.CFrame = CFrame.new(-435.823, 245.556, 504.708)
end)

GameTab:NewButton("Glass Bridge Entrance", function()
	local char = localPlayer.Character
	char.PrimaryPart.CFrame = CFrame.new(-372.466, 259.659, 482.508)
end)

GameTab:NewButton("Mingle Entrance", function()
	local char = localPlayer.Character
	char.PrimaryPart.CFrame = CFrame.new(-382.445, 288.554, 436.898)
end)

GameTab:NewButton("Last Game Entrance", function()
	local char = localPlayer.Character
	char.PrimaryPart.CFrame = CFrame.new(-430.687, 251.535, 791.952)
end)

-- MISC TAB CONTENT
MiscTab:NewText("=== TELEPORTS ===")

MiscTab:NewButton("Teleport To Spawn", function()
	local char = localPlayer.Character
	if char and char:FindFirstChild("HumanoidRootPart") then
		char.HumanoidRootPart.CFrame = CFrame.new(196.83342, 55.9547985, -90.4745865)
	end
end)

MiscTab:NewButton("Teleport To Safe Spot", function()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	if char and char:FindFirstChild("HumanoidRootPart") then
		char.HumanoidRootPart.CFrame = CFrame.new(179.030807, 57.9083214, 49.8269196)
	end
end)

MiscTab:NewDivider()

MiscTab:NewText("=== SpamX TITLES ===")

MiscTab:NewButton("[DAHEN HUB] Black Title", function()
	localPlayer:SetAttribute("_CurrentTitle", "Him")
	spawn(function()
		while task.wait() do
			localPlayer.Character.Torso.Player_Nametag.TitleText.Text = "[DAHEN SCRIPT]"
		end
	end)
end)

MiscTab:NewButton("[DAHEN HUB] Gold Title", function()
	localPlayer:SetAttribute("_CurrentTitle", "Rich Millionaire")
	spawn(function()
		while task.wait() do
			localPlayer.Character.Torso.Player_Nametag.TitleText.Text = "[SpamX USER]"
		end
	end)
end)

MiscTab:NewButton("[DAHEN HUB] Purple Title", function()
	localPlayer:SetAttribute("_CurrentTitle", "Tanos")
	spawn(function()
		while task.wait() do
			localPlayer.Character.Torso.Player_Nametag.TitleText.Text = "[SpamX USER]"
		end
	end)
end)

MiscTab:NewButton("[DAHEN HUB] Red Title", function()
	localPlayer:SetAttribute("_CurrentTitle", "The Chosen One")
	spawn(function()
		while task.wait() do
			localPlayer.Character.Torso.Player_Nametag.TitleText.Text = "[DAHEN SCRIPT ]"
		end
	end)
end)

MiscTab:NewDivider()

MiscTab:NewText("=== ITEM TELEPORTS ===")

MiscTab:NewButton("Teleport To Dropped Bandage", function()
	local char = localPlayer.Character
	if char and char:FindFirstChild("HumanoidRootPart") then
		for i = 1, 10 do
			char.HumanoidRootPart.CFrame = game.Workspace.Effects:FindFirstChild("DroppedBandage").PrimaryPart.CFrame
			task.wait(0.125)
		end
	end
end)

MiscTab:NewButton("Teleport To Dropped Grenade", function()
	local char = localPlayer.Character
	if char and char:FindFirstChild("HumanoidRootPart") then
		for i = 1, 10 do
			char.HumanoidRootPart.CFrame = game.Workspace.Effects:FindFirstChild("DroppedGrenade").PrimaryPart.CFrame
			task.wait(0.125)
		end
	end
end)

MiscTab:NewButton("Teleport To Dropped FlashBang", function()
	local char = localPlayer.Character
	if char and char:FindFirstChild("HumanoidRootPart") then
		for i = 1, 10 do
			char.HumanoidRootPart.CFrame = game.Workspace.Effects:FindFirstChild("DroppedFlashbang").PrimaryPart.CFrame
			task.wait(0.125)
		end
	end
end)

MiscTab:NewDivider()

local teleportEnabled = false
local teleportConnection = nil

-- Teleport to Dropped Bandage Toggle
MiscTab:NewToggle("Auto Grab Dropped Bandage", false, function(state)
	teleportEnabled = state

	if teleportEnabled then
		-- Start the teleport loop
		teleportConnection = game:GetService("RunService").Heartbeat:Connect(function()
			if not teleportEnabled then return end

			local char = localPlayer.Character
			if char and char:FindFirstChild("HumanoidRootPart") then
				local droppedBandage = game.Workspace.Effects:FindFirstChild("DroppedBandage")
				if droppedBandage and droppedBandage.PrimaryPart then
					char.HumanoidRootPart.CFrame = droppedBandage.PrimaryPart.CFrame
				end
			end
		end)
	else
		-- Stop the teleport loop
		if teleportConnection then
			teleportConnection:Disconnect()
			teleportConnection = nil
		end
	end
end)

-- Teleport to Dropped Grenade Toggle
local grenadeEnabled = false
local grenadeConnection = nil

MiscTab:NewToggle("Auto Grab Dropped Grenade", false, function(state)
	grenadeEnabled = state

	if grenadeEnabled then
		-- Start the teleport loop
		grenadeConnection = game:GetService("RunService").Heartbeat:Connect(function()
			if not grenadeEnabled then return end

			local char = localPlayer.Character
			if char and char:FindFirstChild("HumanoidRootPart") then
				local droppedGrenade = game.Workspace.Effects:FindFirstChild("DroppedGrenade")
				if droppedGrenade and droppedGrenade.PrimaryPart then
					char.HumanoidRootPart.CFrame = droppedGrenade.PrimaryPart.CFrame
				end
			end
		end)
	else
		-- Stop the teleport loop
		if grenadeConnection then
			grenadeConnection:Disconnect()
			grenadeConnection = nil
		end
	end
end)

-- Teleport to Dropped FlashBang Toggle
local flashbangEnabled = false
local flashbangConnection = nil

MiscTab:NewToggle("Auto Grab Dropped FlashBang", false, function(state)
	flashbangEnabled = state

	if flashbangEnabled then
		-- Start the teleport loop
		flashbangConnection = game:GetService("RunService").Heartbeat:Connect(function()
			if not flashbangEnabled then return end

			local char = localPlayer.Character
			if char and char:FindFirstChild("HumanoidRootPart") then
				local droppedFlashbang = game.Workspace.Effects:FindFirstChild("DroppedFlashbang")
				if droppedFlashbang and droppedFlashbang.PrimaryPart then
					char.HumanoidRootPart.CFrame = droppedFlashbang.PrimaryPart.CFrame
				end
			end
		end)
	else
		-- Stop the teleport loop
		if flashbangConnection then
			flashbangConnection:Disconnect()
			flashbangConnection = nil
		end
	end
end)

MiscTab:NewDivider()

MiscTab:NewToggle("Enable Spectate", false, function(state)
	game.Workspace.Values.CanSpectateIfWonGame.Value = state
end)

MiscTab:NewTextInput("Custom Player Number", "Put Tag Here", function(value)
	local char = localPlayer.Character
	local ui = localPlayer.PlayerGui.Leaderboard.Leaderboard.MainLeaderboard.Content:FindFirstChild(localPlayer.UserId)
	local Tags = char:FindFirstChild("PlayerTags")

	spawn(function()
		while true do
			task.wait()
			for i, tag in pairs(Tags:GetChildren()) do
				tag.SurfaceGui.TextLabel.Text = value
				ui.PlayerNumber.Text = "#"..value
			end
		end
	end)
end)

MiscTab:NewDivider()

MiscTab:NewButton("FPS Boost", function()
	-- Example FPS Booster Script
	local Lighting = game:GetService("Lighting")
	Lighting.GlobalShadows = false
	Lighting.FogEnd = 100000
	Lighting.Brightness = 1

	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") then
			v.Material = Enum.Material.SmoothPlastic
		end
	end
end)

-- Auto-refresh player list when players join/leave
Players.PlayerAdded:Connect(function()
	task.wait(1)
	-- Would need to refresh dropdown here
end)

Players.PlayerRemoving:Connect(function(player)
	if selectedPlayer == player then
		selectedPlayer = nil
	end
	-- Would need to refresh dropdown here
end)

-- Clean up speed boost and noclip on character respawn
localPlayer.CharacterAdded:Connect(function()
	speedBoostEnabled = false
	if speedConnection then
		speedConnection:Disconnect()
		speedConnection = nil
	end

	noclipEnabled = false
	if noclipConnection then
		noclipConnection:Disconnect()
		noclipConnection = nil
	end
end)

print("DAHEN HUB LOADED")
