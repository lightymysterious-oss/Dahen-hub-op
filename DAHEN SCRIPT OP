local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/x2zu/OPEN-SOURCE-UI-ROBLOX/refs/heads/main/X2ZU%20UI%20ROBLOX%20OPEN%20SOURCE/DummyUi-leak-by-x2zu/fetching-main/Tools/Framework.luau"))()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local TextChatService = game:GetService("TextChatService")
local ToolModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/GoldDoomOwner/Gold-Doom-Script/refs/heads/main/Tool%20Giver"))()
local UserInputService = game:GetService("UserInputService")

local Custom_PowerTools = {"Awaken", "Oblivious","Titanium", "Drug Abused", "Soul Monarch", "Creation", "AkazaDash", "ESPER RAGE", "GOLDEN MONARCH", "VOID WALKER", "STORM BREAKER", "CRIMSON REAPER", "CELESTIAL WRATH", "SHADOW ASSASSIN", "INFERNO KING", "FROZEN DOMAIN", "GRAVITY TITAN", "PLASMA SURGE", "TOXIC VENOM", "TIME WARP", "CRYSTAL FORTRESS", "BLOOD MOON", "DRAGON SPIRIT", "NEBULA VOID", "EARTH SHAKER", "WIND DANCER", "CHAOS BREAKER"}

if localPlayer then
	local textChannel = TextChatService:WaitForChild("TextChannels"):WaitForChild("RBXGeneral")
	textChannel:DisplaySystemMessage("[DAHEN HUB]: LOADING SCRIPT...")
	task.wait()
	textChannel:DisplaySystemMessage("[DAHEN HUB]: DAHEN HUB | INK GAMES")
	task.wait()
	textChannel:DisplaySystemMessage("[DAHEN HUB]: LOADED")
end

-- Create main window using Dummy UI format
local Window = Library:Window({
    Title = "DAHEN HUB INK GAME",
    Desc = "DAHEN HUB TESTING | INK GAMES\nhttps://discord.gg/golddoom, https://discord.gg/ringta",
    Icon = 105059922903197,
    Theme = "Dark",
    Config = {
        Keybind = Enum.KeyCode.LeftControl,
        Size = UDim2.new(0, 500, 0, 400)
    },
    CloseUIButton = {
        Enabled = true,
        Text = "DAHEN HUB"
    }
})

Window:Notify({
    Title = "Test",
    Desc = "Loading",
    Time = 4
})

-- Create tabs using Dummy UI format
local MainTab = Window:Tab({Title = "Main", Icon = "home"})
local PlayerTab = Window:Tab({Title = "Player", Icon = "user"}) 
local GameTab = Window:Tab({Title = "Game", Icon = "gamepad"})
local MiscTab = Window:Tab({Title = "Misc", Icon = "settings"})

-- Player Teleport System Variables
local selectedPlayer = nil

-- Function to get all players except local player
local function CreateGlassBridgeCover()
	local glassHolder = game.Workspace:FindFirstChild("GlassBridge")
	if not glassHolder then
		warn("GlassBridge not found in Workspace")
		return
	end

	glassHolder = glassHolder:FindFirstChild("GlassHolder")
	if not glassHolder then
		warn("GlassHolder not found in GlassBridge")
		return
	end

	local models = glassHolder:GetChildren()

	if #models == 0 then
		warn("No models found in GlassHolder")
		return
	end

	-- Calculate the bounding box that encompasses all models
	local minX, minY, minZ = math.huge, math.huge, math.huge
	local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge

	for _, model in ipairs(models) do
		if model:IsA("Model") or model:IsA("BasePart") then
			local cframe, size

			if model:IsA("Model") then
				cframe, size = model:GetBoundingBox()
			else
				cframe = model.CFrame
				size = model.Size
			end

			-- Calculate the corners of this model's bounding box
			local halfSize = size / 2
			local corners = {
				cframe * CFrame.new(-halfSize.X, -halfSize.Y, -halfSize.Z),
				cframe * CFrame.new(halfSize.X, -halfSize.Y, -halfSize.Z),
				cframe * CFrame.new(-halfSize.X, halfSize.Y, -halfSize.Z),
				cframe * CFrame.new(halfSize.X, halfSize.Y, -halfSize.Z),
				cframe * CFrame.new(-halfSize.X, -halfSize.Y, halfSize.Z),
				cframe * CFrame.new(halfSize.X, -halfSize.Y, halfSize.Z),
				cframe * CFrame.new(-halfSize.X, halfSize.Y, halfSize.Z),
				cframe * CFrame.new(halfSize.X, halfSize.Y, halfSize.Z),
			}

			-- Find min and max positions
			for _, corner in ipairs(corners) do
				local pos = corner.Position
				minX = math.min(minX, pos.X)
				minY = math.min(minY, pos.Y)
				minZ = math.min(minZ, pos.Z)
				maxX = math.max(maxX, pos.X)
				maxY = math.max(maxY, pos.Y)
				maxZ = math.max(maxZ, pos.Z)
			end
		end
	end

	-- Create the covering part
	local coverPart = Instance.new("Part")
	coverPart.Name = "GlassBridgeCover"
	coverPart.Anchored = true
	coverPart.CanCollide = true
	coverPart.Material = Enum.Material.SmoothPlastic
	coverPart.Color = Color3.fromRGB(100, 100, 255)
	coverPart.Transparency = 0.3

	-- Calculate size and position
	local sizeX = maxX - minX + 2 -- Add 2 studs padding
	local sizeY = maxY - minY + 2
	local sizeZ = maxZ - minZ + 2

	local centerX = (minX + maxX) / 2
	local centerY = (minY + maxY) / 2
	local centerZ = (minZ + maxZ) / 2

	coverPart.Size = Vector3.new(sizeX, sizeY, sizeZ)
	coverPart.CFrame = CFrame.new(centerX, centerY, centerZ)
	coverPart.Parent = workspace

	print("Glass Bridge Cover created!")
	print("Size:", coverPart.Size)
	print("Position:", coverPart.Position)

	return coverPart
end

local function getPlayerList()
	local playerList = {}
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= localPlayer then
			table.insert(playerList, player.DisplayName)
		end
	end
	return #playerList > 0 and playerList or {"No Players"}
end

-- Function to get player by display name
local function getPlayerByDisplayName(displayName)
	for _, player in pairs(Players:GetPlayers()) do
		if player.DisplayName == displayName then
			return player
		end
	end
	return nil
end

-- Function to teleport to selected player
local function teleportToPlayer(targetPlayer)
	if not targetPlayer or not targetPlayer.Character then
		return
	end

	local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
	local localRoot = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")

	if targetRoot and localRoot then
		localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, 3)
	end
end

-- Function to teleport to random player
local function teleportToRandomPlayer()
	local players = {}
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= localPlayer and player.Character then
			table.insert(players, player)
		end
	end

	if #players > 0 then
		local randomPlayer = players[math.random(1, #players)]
		teleportToPlayer(randomPlayer)
	end
end

-- MAIN TAB CONTENT
MainTab:Section({Title = "Custom Emotes"})

MainTab:Button({
    Title = "Custom Emotes",
    Desc = "Load custom emotes script",
    Callback = function()
        loadstring(game:HttpGet("https://pastebin.com/raw/1p6xnBNf"))()
        loadstring(game:HttpGet("https://raw.githubusercontent.com/GoldDoomOwner/Gold-Doom-Script/refs/heads/main/jerk"))()
    end
})

MainTab:Button({
    Title = "Custom Emotes 2",
    Desc = "Load additional custom emotes",
    Callback = function()
		-- Feel free to modify, contact pystyt on discord if u want to show me the modifications you did to the script, thanks alot
		-- Detect R6 or R15
		local player = game.Players.LocalPlayer
		local character = player.Character or player.CharacterAdded:Wait()
		local isR6 = character:FindFirstChild("Torso") ~= nil

		-- Notification Function
		local function showNotification(message)
			local notificationGui = Instance.new("ScreenGui")
			notificationGui.Name = "NotificationGui"
			notificationGui.Parent = game.CoreGui

			local notificationFrame = Instance.new("Frame")
			notificationFrame.Size = UDim2.new(0, 300, 0, 50)
			notificationFrame.Position = UDim2.new(0.5, -150, 1, -60)
			notificationFrame.AnchorPoint = Vector2.new(0.5, 1)
			notificationFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
			notificationFrame.BorderSizePixel = 0
			notificationFrame.Parent = notificationGui

			local uicorner = Instance.new("UICorner")
			uicorner.CornerRadius = UDim.new(0, 10)
			uicorner.Parent = notificationFrame

			local textLabel = Instance.new("TextLabel")
			textLabel.Size = UDim2.new(1, -20, 1, 0)
			textLabel.Position = UDim2.new(0, 10, 0, 0)
			textLabel.BackgroundTransparency = 1
			textLabel.Text = message .. " | by nikos_YT7"
			textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
			textLabel.Font = Enum.Font.SourceSansSemibold
			textLabel.TextSize = 18
			textLabel.TextXAlignment = Enum.TextXAlignment.Left
			textLabel.Parent = notificationFrame

			notificationFrame.BackgroundTransparency = 1
			textLabel.TextTransparency = 1

			game:GetService("TweenService"):Create(
				notificationFrame,
				TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.Out),
				{BackgroundTransparency = 0}
			):Play()

			game:GetService("TweenService"):Create(
				textLabel,
				TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.Out),
				{TextTransparency = 0}
			):Play()

			task.delay(5, function()
				game:GetService("TweenService"):Create(
					notificationFrame,
					TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.In),
					{BackgroundTransparency = 1}
				):Play()

				game:GetService("TweenService"):Create(
					textLabel,
					TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.In),
					{TextTransparency = 1}
				):Play()

				task.delay(0.5, function()
					notificationGui:Destroy()
				end)
			end)
		end

		-- Show notification based on rig type
		if isR6 then
			showNotification("R6 detected")
		else
			showNotification("R15 detected")
		end

		-- Create Screen GUI
		local gui = Instance.new("ScreenGui")
		gui.Name = "BangGui"
		gui.Parent = game.CoreGui

		-- Main Frame
		local mainFrame = Instance.new("Frame")
		mainFrame.Size = UDim2.new(0, 300, 0, 300)
		mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
		mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
		mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
		mainFrame.BorderSizePixel = 0
		mainFrame.Parent = gui

		local uicorner = Instance.new("UICorner")
		uicorner.CornerRadius = UDim.new(0, 20)
		uicorner.Parent = mainFrame

		-- Title
		local title = Instance.new("TextLabel")
		title.Size = UDim2.new(1, -60, 0, 30)
		title.Position = UDim2.new(0, 10, 0, 0)
		title.BackgroundTransparency = 1
		title.Text = "Choose"
		title.TextColor3 = Color3.fromRGB(255, 255, 255)
		title.Font = Enum.Font.SourceSansSemibold
		title.TextSize = 24
		title.TextXAlignment = Enum.TextXAlignment.Left
		title.Parent = mainFrame

		-- Dahen Hub Minimize/Restore System (Fixed)
		local minimized = false

		-- Main Dahen Hub restore button (appears when minimized)
		local restoreBtn = Instance.new("TextButton")
		restoreBtn.Size = UDim2.new(0, 120, 0, 36)
		restoreBtn.Position = UDim2.new(0, 12, 0, 12)
		restoreBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
		restoreBtn.Text = "Dahen Hub"
		restoreBtn.Font = Enum.Font.SourceSansBold
		restoreBtn.TextSize = 18
		restoreBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
		restoreBtn.Visible = false
		restoreBtn.Parent = gui

		Instance.new("UICorner", restoreBtn).CornerRadius = UDim.new(0, 8)

		-- Existing minimize button setup
		local miniBtn = Instance.new("TextButton")
		miniBtn.Size = UDim2.new(0, 36, 0, 36)
		miniBtn.Position = UDim2.new(1, -76, 0, 12)
		miniBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
		miniBtn.Text = "-"
		miniBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
		miniBtn.TextScaled = true
		miniBtn.Parent = mainFrame

		Instance.new("UICorner", miniBtn).CornerRadius = UDim.new(0, 8)

		-- Minimize behavior
		miniBtn.MouseButton1Click:Connect(function()
			if minimized then return end
			minimized = true

			-- Tween out smoothly
			mainFrame:TweenSize(UDim2.new(0, 300, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.3, true, function()
				mainFrame.Visible = false
				restoreBtn.Visible = true
			end)
		end)

		-- Restore behavior
		restoreBtn.MouseButton1Click:Connect(function()
			if not minimized then return end
			minimized = false

			restoreBtn.Visible = false
			mainFrame.Visible = true

			-- Tween back to normal size
			mainFrame:TweenSize(UDim2.new(0, 300, 0, 300), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.3, true)
		end)

		-- Close Button
		local closeButton = Instance.new("TextButton")
		closeButton.Size = UDim2.new(0, 30, 0, 30)
		closeButton.Position = UDim2.new(1, -40, 0, 0)
		closeButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
		closeButton.Text = "X"
		closeButton.Font = Enum.Font.SourceSansBold
		closeButton.TextSize = 20
		closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		closeButton.Parent = mainFrame

		local closeCorner = Instance.new("UICorner")
		closeCorner.CornerRadius = UDim.new(0, 10)
		closeCorner.Parent = closeButton

		closeButton.MouseButton1Click:Connect(function()
			gui:Destroy()
		end)

		-- Dahen Hub Minimize/Restore System

		-- MainFrame, minimizeButton, and closeButton should already exist
		local player = game.Players.LocalPlayer
		local gui = player:WaitForChild("PlayerGui")

		-- Create the Dahen Hub restore button
		local restoreButton = Instance.new("TextButton")
		restoreButton.Name = "RestoreButton"
		restoreButton.Text = "Dahen Hub"
		restoreButton.Font = Enum.Font.SourceSansBold
		restoreButton.TextSize = 20
		restoreButton.TextColor3 = Color3.fromRGB(255, 255, 255)
		restoreButton.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
		restoreButton.Size = UDim2.new(0, 150, 0, 40)
		restoreButton.Position = UDim2.new(0.5, -75, 0, 10) -- top center
		restoreButton.Visible = false
		restoreButton.Parent = gui

		local corner = Instance.new("UICorner")
		corner.CornerRadius = UDim.new(0, 10)
		corner.Parent = restoreButton

		local minimized = false

		local minimizeButton = miniBtn -- Use existing miniBtn

		minimizeButton.MouseButton1Click:Connect(function()
			minimized = true
			mainFrame.Visible = false
			restoreButton.Visible = true
		end)

		restoreButton.MouseButton1Click:Connect(function()
			minimized = false
			mainFrame.Visible = true
			restoreButton.Visible = false
		end)

		closeButton.MouseButton1Click:Connect(function()
			mainFrame.Visible = false
			restoreButton.Visible = false
		end)

		-- optional: close button behavior (keeps it visible and reliable)
		closeButton.MouseButton1Click:Connect(function()
			mainFrame.Visible = false
		end)

		-- Example Content
		local content = Instance.new("Frame")
		content.Size = UDim2.new(1, 0, 1, -30)
		content.Position = UDim2.new(0, 0, 0, 30)
		content.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
		content.Parent = mainFrame

		local label = Instance.new("TextLabel")
		label.Size = UDim2.new(1, 0, 0, 40)
		label.Position = UDim2.new(0, 0, 0, 10)
		label.BackgroundTransparency = 1
		label.Text = "Welcome to Dahen Hub!"
		label.Font = Enum.Font.SourceSansBold
		label.TextSize = 22
		label.TextColor3 = Color3.fromRGB(255, 255, 255)
		label.Parent = content

		-- Fixed Minimize Function (Shrink Only)
		local minimized = false
		local fullSize = UDim2.new(0, 300, 0, 300)
		local minimizedSize = UDim2.new(0, 300, 0, 30)

		minimizeButton.MouseButton1Click:Connect(function()
			minimized = not minimized

			if minimized then
				content.Visible = false
				mainFrame:TweenSize(minimizedSize, Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.4, true)
			else
				mainFrame:TweenSize(fullSize, Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.4, true)
				task.wait(0.4)
				content.Visible = true
			end
		end)

		-- Dragging Functionality
		local dragging, dragStart, startPos
		mainFrame.InputBegan:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				dragging = true
				dragStart = input.Position
				startPos = mainFrame.Position
			end
		end)

		mainFrame.InputChanged:Connect(function(input)
			if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
				local delta = input.Position - dragStart
				mainFrame.Position = UDim2.new(
					startPos.X.Scale,
					startPos.X.Offset + delta.X,
					startPos.Y.Scale,
					startPos.Y.Offset + delta.Y
				)
			end
		end)

		mainFrame.InputEnded:Connect(function(input)
			if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
				dragging = false
			end
		end)

		-- Scrolling Frame
		local scrollingFrame = Instance.new("ScrollingFrame")
		scrollingFrame.Size = UDim2.new(1, -20, 1, -50)
		scrollingFrame.Position = UDim2.new(0, 10, 0, 40)
		scrollingFrame.BackgroundTransparency = 1
		scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 300)
		scrollingFrame.ScrollBarThickness = 6
		scrollingFrame.Parent = mainFrame

		local layout = Instance.new("UIListLayout")
		layout.Padding = UDim.new(0, 10)
		layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
		layout.Parent = scrollingFrame

		-- Buttons Data
		local buttons = {
			{name = "Bang V2", r6 = "https://pastebin.com/raw/aPSHMV6K", r15 = "https://pastebin.com/raw/1ePMTt9n"},
			{name = "Get Banged", r6 = "https://pastebin.com/raw/zHbw7ND1", r15 = "https://pastebin.com/raw/7hvcjDnW"},
			{name = "Suck", r6 = "https://pastebin.com/raw/SymCfnAW", r15 = "https://pastebin.com/raw/p8yxRfr4"},
			{name = "Get Suc", r6 = "https://pastebin.com/raw/FPu4e2Qh", r15 = "https://pastebin.com/raw/DyPP2tAF"},
		}

		for _, buttonData in pairs(buttons) do
			local button = Instance.new("TextButton")
			button.Size = UDim2.new(0.8, 0, 0, 40)
			button.BackgroundColor3 = Color3.fromRGB(50, 150, 255)
			button.Text = buttonData.name
			button.Font = Enum.Font.SourceSansBold
			button.TextSize = 20
			button.TextColor3 = Color3.fromRGB(255, 255, 255)
			button.Parent = scrollingFrame

			local uicorner = Instance.new("UICorner")
			uicorner.CornerRadius = UDim.new(0, 10)
			uicorner.Parent = button

			button.MouseButton1Click:Connect(function()
				if isR6 then
					loadstring(game:HttpGet(buttonData.r6))()
				else
					loadstring(game:HttpGet(buttonData.r15))()
				end
			end)
		end
    end
})

Window:Line()

MainTab:Section({Title = "Power Tools"})

-- Create first dropdown for tool selection
local selectedTool1 = "Awaken"
MainTab:Dropdown({
    Title = "Select Tool 1",
    List = Custom_PowerTools,
    Value = "Awaken",
    Callback = function(selected)
        selectedTool1 = selected
        print("Selected tool 1:", selectedTool1)
    end
})

-- Create second dropdown for tool selection
local selectedTool2 = "Oblivious"
MainTab:Dropdown({
    Title = "Select Tool 2",
    List = Custom_PowerTools,
    Value = "Oblivious",
    Callback = function(selected)
        selectedTool2 = selected
        print("Selected tool 2:", selectedTool2)
    end
})

-- Create text input for custom name
local customNameInput = MainTab:Textbox({
    Title = "Custom Powers Name",
    Desc = "Enter custom name...",
    Placeholder = "Enter custom name...",
    Value = "",
    ClearTextOnFocus = false,
    Callback = function(text)
        print("Custom name entered:", text)
    end
})

-- Create button to get tools and change shop UI text
MainTab:Button({
    Title = "Equip Custom Power",
    Desc = "Get tools and change shop UI",
    Callback = function()
        -- Get both tools using ToolModule
        ToolModule:GetTools(selectedTool1, selectedTool2)

        -- Get the custom name from the text input
        local customName = customNameInput.GetText and customNameInput:GetText() or ""

        -- Change the shop UI text
        local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Powers
        spawn(function()
            while true do
                ui.CurrentlyEquipped.Text = "Currently Equipped: " .. (customName or "")
                task.wait()
            end
        end)
    end
})

Window:Line()

MainTab:Section({Title = "Boosts & Powers"})

MainTab:Button({
    Title = "Enable Dash",
    Desc = "Enable faster sprint boost",
    Callback = function()
        localPlayer.Boosts["Faster Sprint"].Value = 5
        local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Boosts
        local Speed = ui["Faster Sprint"]

        spawn(function()
            while true do
                task.wait()
                Speed.BuyButtonRobux.Visible = false
                Speed.BuyButtonCoin.Visible = false
                Speed.ItemLevel.Text = "Current Level (5)"
            end
        end)
    end
})

MainTab:Button({
    Title = "Won Boost",
    Desc = "Enable won boost",
    Callback = function()
        localPlayer.Boosts["Won Boost"].Value = 5
        local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Boosts
        local Speed = ui["Won Boost"]

        spawn(function()
            while true do
                task.wait()
                Speed.BuyButtonRobux.Visible = false
                Speed.BuyButtonCoin.Visible = false
                Speed.ItemLevel.Text = "Current Level (5)"
            end
        end)
    end
})

MainTab:Button({
    Title = "Strength Boost",
    Desc = "Enable damage boost",
    Callback = function()
        localPlayer.Boosts["Damage Boost"].Value = 5
        local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Boosts
        local Speed = ui["Damage Boost"]

        spawn(function()
            while true do
                task.wait()
                Speed.BuyButtonRobux.Visible = false
                Speed.BuyButtonCoin.Visible = false
                Speed.ItemLevel.Text = "Current Level (5)"
            end
        end)
    end
})

MainTab:Button({
    Title = "Equip Phantom Step",
    Desc = "Set Phantom Step power",
    Callback = function()
        localPlayer:SetAttribute("_EquippedPower", "PHANTOM STEP")
    end
})

MainTab:Button({
    Title = "Remove Power",
    Desc = "Clear equipped power",
    Callback = function()
        localPlayer:SetAttribute("_EquippedPower", "")
    end
})

MainTab:Button({
    Title = "Enable Powers",
    Desc = "Enable all powers",
    Callback = function()
        game.Workspace.Values.PowersDisabled.Value = false
    end
})

Window:Line()

MainTab:Section({Title = "Gamepasses & Weapons"})

MainTab:Button({
    Title = "Enable All Gamepasses",
    Desc = "Unlock all gamepasses",
    Callback = function()
        Window:Notify({
            Title = "Enabling All Gamepasses",
            Desc = "Loading Script",
            Time = 4
        })
        
        localPlayer:SetAttribute("HasLighter", true)
        localPlayer:SetAttribute("HasPush", true)
        game.Workspace.Values.CanPush.Value = true
        local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Gamepass
        game.Workspace.Values.CanPush.Value = true

        for i, v in pairs(ui:GetChildren()) do
            if v:IsA("TextButton") then
                spawn(function()
                    if v.ItemName.Text == "Revive All" or v.ItemName.Text == "One Time Playable Guard" then
                        print("["..v.ItemName.Text.."] Has Been Blocked")
                        Window:Notify({
                            Title = v.ItemName.Text,
                            Desc = "Blocked To Look Legit",
                            Time = 4
                        })
                    else
                        v.BuyButton.Content.TextLabel.Text = "OWNED"
                        Window:Notify({
                            Title = v.ItemName.Text,
                            Desc = "Giving Gamepass",
                            Time = 4
                        })
                        print("Done ["..v.ItemName.Text.."]")
                    end
                end)
            end
        end
    end
})

MainTab:Button({
    Title = "Select Fork",
    Desc = "Set Fork as weapon",
    Callback = function()
        localPlayer:SetAttribute("WeaponSelected", "Fork")
    end
})

MainTab:Button({
    Title = "Show All Buttons",
    Desc = "Reveal all UI buttons",
    Callback = function()
        local ui = localPlayer.PlayerGui.Buttons.LeftButtons
        for i, v in pairs(ui:GetChildren()) do
            if v:IsA("ImageButton") then
                v.Visible = true
            end
        end
    end
})

-- PLAYER TAB CONTENT - Converted to Dummy UI format
PlayerTab:Section({Title = "PLAYER TELEPORTS"})

-- Create player dropdown
local playerOptions = getPlayerList()
PlayerTab:Dropdown({
    Title = "Player Selector",
    List = playerOptions,
    Value = playerOptions[1],
    Callback = function(selectedName)
        selectedPlayer = getPlayerByDisplayName(selectedName)
    end
})

PlayerTab:Button({
    Title = "Refresh Players",
    Desc = "Update player list",
    Callback = function()
        print("Player list refreshed")
    end
})

PlayerTab:Button({
    Title = "Teleport To Selected Player",
    Desc = "TP to chosen player",
    Callback = function()
        if selectedPlayer then
            teleportToPlayer(selectedPlayer)
        else
            print("No player selected!")
        end
    end
})

local goatersa = false

PlayerTab:Toggle({
    Title = "Attach to player",
    Desc = "Auto follow selected player",
    Value = false,
    Callback = function(state)
        if selectedPlayer then
            goatersa = state
            spawn(function()
                while true do
                    if goatersa == true then
                        teleportToPlayer(selectedPlayer)
                    else
                        -- ignore
                    end
                    task.wait(0.1) -- for preformance without there will be lag
                end
            end)
        else
            print("No player selected!")
        end
    end
})

PlayerTab:Button({
    Title = "Teleport To Random Player",
    Desc = "TP to random player",
    Callback = function()
        teleportToRandomPlayer()
    end
})

Window:Line()

PlayerTab:Section({Title = "Combat Features"})

PlayerTab:Button({
    Title = "Hitbox multiplier",
    Desc = "Toggle hitbox size",
    Callback = function()
        if game.Workspace.Values.HitboxMultiplier.Value == 50 then
            Window:Notify({
                Title = "[HITBOX]",
                Desc = "is 1x",
                Time = 4
            })
            game.Workspace.Values.HitboxMultiplier.Value = 1
        else
            Window:Notify({
                Title = "[HITBOX]",
                Desc = "is 50x",
                Time = 4
            })
            game.Workspace.Values.HitboxMultiplier.Value = 50
        end
    end
})

-- HITBOX EXPANDER - Extended Attack Range with Visuals
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Hitbox Expander variables
local isHitboxExpanderActive = false
local expandedHitboxes = {}
local visualHitboxes = {}
local hitboxSize = 15
local hitboxRange = 30
local attackCooldown = 0.2
local lastAttackTime = 0

-- Add toggle to PlayerTab
PlayerTab:Toggle({
    Title = "Hitbox Expander",
    Desc = "Extend attack range with invisible hitboxes",
    Value = false,
    Callback = function(state)
        isHitboxExpanderActive = state
        
        if state then
            createExpandedHitboxes()
        else
            removeExpandedHitboxes()
        end
    end
})

-- Range input
PlayerTab:Textbox({
    Title = "Hitbox Range",
    Desc = "Set hitbox range (1-100)",
    Placeholder = "30",
    Value = "30",
    ClearTextOnFocus = false,
    Callback = function(text)
        local newRange = tonumber(text)
        if newRange and newRange >= 1 and newRange <= 100 then
            hitboxRange = newRange
            if isHitboxExpanderActive then
                removeExpandedHitboxes()
                createExpandedHitboxes()
            end
            Window:Notify({
                Title = "HITBOX EXPANDER",
                Desc = "Range set to: " .. hitboxRange .. " studs",
                Time = 3
            })
        else
            Window:Notify({
                Title = "HITBOX EXPANDER",
                Desc = "Invalid range! Use 1-100",
                Time = 3
            })
        end
    end
})

-- Create expanded hitboxes around player
local function createExpandedHitboxes()
    removeExpandedHitboxes()
    
    local character = localPlayer.Character
    if not character then return end
    
    -- Create hitboxes in all directions
    local hitboxPositions = {
        Vector3.new(0, 0, hitboxRange),  -- Front
        Vector3.new(hitboxRange, 0, 0),  -- Right
        Vector3.new(-hitboxRange, 0, 0), -- Left
        Vector3.new(0, 0, -hitboxRange), -- Back
        Vector3.new(0, hitboxRange, 0),  -- Top
    }
    
    for i, offset in ipairs(hitboxPositions) do
        local hitbox = createSingleHitbox(character, offset, "Hitbox_" .. i)
        table.insert(expandedHitboxes, hitbox)
        
        -- Create visual indicator
        local visual = createVisualHitbox(character, offset, "Visual_" .. i)
        table.insert(visualHitboxes, visual)
    end
    
    -- Create rotating sphere for 360 coverage
    local sphereHitbox = createSphereHitbox(character)
    table.insert(expandedHitboxes, sphereHitbox)
    
    -- Create visual for rotating sphere
    local sphereVisual = createSphereVisual(character)
    table.insert(visualHitboxes, sphereVisual)
end

-- Create a single hitbox part
local function createSingleHitbox(character, offset, name)
    local hitbox = Instance.new("Part")
    hitbox.Name = name
    hitbox.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    hitbox.Transparency = 1
    hitbox.CanCollide = false
    hitbox.Anchored = false
    hitbox.Massless = true
    
    -- Create TouchTransmitter
    local touchInterest = Instance.new("TouchTransmitter")
    touchInterest.Parent = hitbox
    
    -- Weld to character
    local weld = Instance.new("Weld")
    weld.Part0 = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head") or character.PrimaryPart
    weld.Part1 = hitbox
    weld.C0 = CFrame.new(offset)
    weld.Parent = hitbox
    
    hitbox.Parent = character
    
    -- Connect touched event
    hitbox.Touched:Connect(function(otherPart)
        onHitboxTouched(otherPart)
    end)
    
    return hitbox
end

-- Create visual indicator for hitbox
local function createVisualHitbox(character, offset, name)
    local visual = Instance.new("Part")
    visual.Name = name
    visual.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    visual.Material = Enum.Material.Neon
    visual.BrickColor = BrickColor.new("Bright red")
    visual.Transparency = 0.7
    visual.CanCollide = false
    visual.Anchored = false
    visual.Massless = true
    
    -- Weld to character
    local weld = Instance.new("Weld")
    weld.Part0 = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head") or character.PrimaryPart
    weld.Part1 = visual
    weld.C0 = CFrame.new(offset)
    weld.Parent = visual
    
    visual.Parent = character
    
    return visual
end

-- Create sphere hitbox that rotates around player
local function createSphereHitbox(character)
    local sphere = Instance.new("Part")
    sphere.Name = "RotatingSphereHitbox"
    sphere.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    sphere.Transparency = 1
    sphere.CanCollide = false
    sphere.Anchored = false
    sphere.Massless = true
    
    -- Create TouchTransmitter
    local touchInterest = Instance.new("TouchTransmitter")
    touchInterest.Parent = sphere
    
    -- Weld with rotation
    local weld = Instance.new("Weld")
    weld.Part0 = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head") or character.PrimaryPart
    weld.Part1 = sphere
    weld.Parent = sphere
    
    sphere.Parent = character
    
    -- Connect touched event
    sphere.Touched:Connect(function(otherPart)
        onHitboxTouched(otherPart)
    end)
    
    -- Make it rotate
    if isHitboxExpanderActive then
        coroutine.wrap(function()
            local angle = 0
            while isHitboxExpanderActive and sphere and sphere.Parent do
                angle = angle + 0.1
                local x = math.cos(angle) * hitboxRange
                local z = math.sin(angle) * hitboxRange
                weld.C0 = CFrame.new(x, 0, z)
                RunService.Heartbeat:Wait()
            end
        end)()
    end
    
    return sphere
end

-- Create visual for rotating sphere
local function createSphereVisual(character)
    local visual = Instance.new("Part")
    visual.Name = "RotatingSphereVisual"
    visual.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    visual.Material = Enum.Material.Neon
    visual.BrickColor = BrickColor.new("Bright blue")
    visual.Transparency = 0.7
    visual.CanCollide = false
    visual.Anchored = false
    visual.Massless = true
    
    -- Weld with rotation
    local weld = Instance.new("Weld")
    weld.Part0 = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head") or character.PrimaryPart
    weld.Part1 = visual
    weld.Parent = visual
    
    visual.Parent = character
    
    -- Make it rotate
    if isHitboxExpanderActive then
        coroutine.wrap(function()
            local angle = 0
            while isHitboxExpanderActive and visual and visual.Parent do
                angle = angle + 0.1
                local x = math.cos(angle) * hitboxRange
                local z = math.sin(angle) * hitboxRange
                weld.C0 = CFrame.new(x, 0, z)
                RunService.Heartbeat:Wait()
            end
        end)()
    end
    
    return visual
end

-- Handle when hitbox touches something
local function onHitboxTouched(otherPart)
    if not isHitboxExpanderActive then return end
    
    local currentTime = tick()
    if currentTime - lastAttackTime < attackCooldown then return end
    
    -- Check if touched part belongs to a player
    local touchedPlayer = getPlayerFromPart(otherPart)
    if touchedPlayer and touchedPlayer ~= localPlayer then
        -- Check if player is alive
        local character = touchedPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                -- Perform attack
                performAttack()
                lastAttackTime = currentTime
                
                -- Flash the hitbox that was touched
                flashHitboxVisual(otherPart)
            end
        end
    end
end

-- Flash hitbox visual when it hits something
local function flashHitboxVisual(touchedPart)
    for _, visual in pairs(visualHitboxes) do
        if visual and visual.Parent then
            local originalColor = visual.BrickColor
            visual.BrickColor = BrickColor.new("Bright green")
            
            -- Reset color after short delay
            delay(0.2, function()
                if visual and visual.Parent then
                    if visual.Name == "RotatingSphereVisual" then
                        visual.BrickColor = BrickColor.new("Bright blue")
                    else
                        visual.BrickColor = BrickColor.new("Bright red")
                    end
                end
            end)
        end
    end
end

-- Get player from touched part
local function getPlayerFromPart(part)
    local character = part:FindFirstAncestorOfClass("Model")
    if character then
        return Players:GetPlayerFromCharacter(character)
    end
    return nil
end

-- Perform attack (mobile-friendly)
local function performAttack()
    local currentTime = tick()
    if currentTime - lastAttackTime >= attackCooldown then
        -- Use screen tap for mobile compatibility
        local screenCenter = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
        
        VirtualInputManager:SendTouchEvent(0, screenCenter, Enum.TouchState.Began, nil, 0, 0)
        task.wait(0.05)
        VirtualInputManager:SendTouchEvent(0, screenCenter, Enum.TouchState.Ended, nil, 0, 0)
        
        lastAttackTime = currentTime
    end
end

-- Remove all expanded hitboxes
local function removeExpandedHitboxes()
    for _, hitbox in pairs(expandedHitboxes) do
        if hitbox and hitbox.Parent then
            hitbox:Destroy()
        end
    end
    expandedHitboxes = {}
    
    for _, visual in pairs(visualHitboxes) do
        if visual and visual.Parent then
            visual:Destroy()
        end
    end
    visualHitboxes = {}
end

-- Handle character respawning
localPlayer.CharacterAdded:Connect(function(character)
    if isHitboxExpanderActive then
        task.wait(1)
        createExpandedHitboxes()
    end
end)

-- Clean up when character is removed
localPlayer.CharacterRemoving:Connect(function()
    removeExpandedHitboxes()
end)

-- Status button to show current range
PlayerTab:Button({
    Title = "Hitbox Status",
    Desc = "Show current hitbox range",
    Callback = function()
        Window:Notify({
            Title = "HITBOX EXPANDER",
            Desc = "Current range: " .. hitboxRange .. " studs",
            Time = 4
        })
    end
})

-- Infinite Jump
local infiniteJumpEnabled = false
local jumpConnection = nil

PlayerTab:Toggle({
    Title = "Infinite Jump",
    Desc = "Enable infinite jumping",
    Value = false,
    Callback = function(state)
        infiniteJumpEnabled = state

        if infiniteJumpEnabled then
            -- Connect to UserInputService to detect jump input
            local UserInputService = game:GetService("UserInputService")

            jumpConnection = game:GetService("UserInputService").JumpRequest:Connect(function()
                local character = localPlayer.Character
                if character then
                    local humanoid = character:FindFirstChildOfClass("Humanoid")
                    if humanoid then
                        humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    end
                end
            end)
        else
            -- Disable infinite jump
            if jumpConnection then
                jumpConnection:Disconnect()
                jumpConnection = nil
            end
        end
    end
})

-- Noclip Toggle
local noclipEnabled = false
local noclipConnection = nil

PlayerTab:Toggle({
    Title = "Noclip",
    Desc = "Enable noclip mode",
    Value = false,
    Callback = function(state)
        noclipEnabled = state

        if noclipEnabled then
            noclipConnection = RunService.Stepped:Connect(function()
                if localPlayer.Character then
                    for _, part in pairs(localPlayer.Character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            -- Only disable collision on main body parts, not accessories
                            if part.Name == "Head" or part.Name == "Torso" or part.Name == "HumanoidRootPart" or 
                                part.Name == "Left Arm" or part.Name == "Right Arm" or 
                                part.Name == "Left Leg" or part.Name == "Right Leg" or
                                part.Name == "UpperTorso" or part.Name == "LowerTorso" or
                                part.Name == "LeftUpperArm" or part.Name == "LeftLowerArm" or part.Name == "LeftHand" or
                                part.Name == "RightUpperArm" or part.Name == "RightLowerArm" or part.Name == "RightHand" or
                                part.Name == "LeftUpperLeg" or part.Name == "LeftLowerLeg" or part.Name == "LeftFoot" or
                                part.Name == "RightUpperLeg" or part.Name == "RightLowerLeg" or part.Name == "RightFoot" then
                                part.CanCollide = false
                            end
                        end
                    end
                end
            end)
        else
            if noclipConnection then
                noclipConnection:Disconnect()
                noclipConnection = nil
            end

            -- Re-enable collision only on parts we disabled
            if localPlayer.Character then
                for _, part in pairs(localPlayer.Character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        if part.Name == "Head" or part.Name == "Torso" or 
                            part.Name == "Left Arm" or part.Name == "Right Arm" or 
                            part.Name == "Left Leg" or part.Name == "Right Leg" or
                            part.Name == "UpperTorso" or part.Name == "LowerTorso" or
                            part.Name == "LeftUpperArm" or part.Name == "LeftLowerArm" or part.Name == "LeftHand" or
                            part.Name == "RightUpperArm" or part.Name == "RightLowerArm" or part.Name == "RightHand" or
                            part.Name == "LeftUpperLeg" or part.Name == "LeftLowerLeg" or part.Name == "LeftFoot" or
                            part.Name == "RightUpperLeg" or part.Name == "RightLowerLeg" or part.Name == "RightFoot" then
                            part.CanCollide = true
                        end
                    end
                end
            end
        end
    end
})

-- Ultra Cool Auto Dodge with Visual Effects
local isDodgeActive = false
local dodgeLoop = nil
local lastDodgeTime = 0
local dodgeCooldown = 0.5 -- Half second cooldown

-- Add the toggle button to your existing tab
PlayerTab:Toggle({
    Title = "âœ¨ Auto Dodge",
    Desc = "Epic dodge with cool visuals",
    Value = false,
    Callback = function(state)
        isDodgeActive = state
        
        if state then
            -- ENABLE
            Window:Notify({
                Title = "âœ¨ ULTRA DODGE",
                Desc = "ACTIVE - Epic visuals ready!",
                Time = 3
            })
            
            if dodgeLoop then
                dodgeLoop:Disconnect()
            end
            
            dodgeLoop = game:GetService("RunService").Heartbeat:Connect(function()
                if not isDodgeActive then return end
                ultraDodgeDetection()
            end)
            
        else
            -- DISABLE
            Window:Notify({
                Title = "âœ¨ ULTRA DODGE",
                Desc = "INACTIVE",
                Time = 3
            })
            
            if dodgeLoop then
                dodgeLoop:Disconnect()
                dodgeLoop = nil
            end
        end
    end
})

function ultraDodgeDetection()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local myRoot = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not myRoot or not humanoid or humanoid.Health <= 0 then return end
    
    -- Cooldown check (HALF SECOND)
    if tick() - lastDodgeTime < dodgeCooldown then return end
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherRoot then
                local distance = (myRoot.Position - otherRoot.Position).Magnitude
                
                if distance < 18 then
                    local toMe = (myRoot.Position - otherRoot.Position).Unit
                    local lookDir = otherRoot.CFrame.LookVector
                    
                    if toMe:Dot(lookDir) > 0.6 then
                        local tool = otherPlayer.Character:FindFirstChildOfClass("Tool")
                        if tool then
                            epicDodge(otherRoot.Position)
                            lastDodgeTime = tick() -- Update cooldown timer
                            break
                        end
                    end
                end
            end
        end
    end
end

function epicDodge(attackerPos)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not rootPart or not humanoid then return end
    
    -- Calculate dodge direction
    local threatDir = (rootPart.Position - attackerPos).Unit
    local dodgeDistance = 25
    
    -- Try multiple safe directions
    local directions = {
        threatDir, -- Direct away
        threatDir:Cross(Vector3.new(0, 1, 0)), -- Left
        -threatDir:Cross(Vector3.new(0, 1, 0)), -- Right
        (threatDir + Vector3.new(0, 0.5, 0)).Unit -- Up and away
    }
    
    local foundSafeSpot = false
    local safePosition = rootPart.Position
    
    for _, dir in ipairs(directions) do
        local testPos = rootPart.Position + (dir * dodgeDistance)
        local groundRay = Ray.new(testPos + Vector3.new(0, 5, 0), Vector3.new(0, -20, 0))
        local groundHit, groundPos = workspace:FindPartOnRay(groundRay, character)
        
        if groundHit then
            safePosition = groundPos + Vector3.new(0, 3, 0)
            foundSafeSpot = true
            break
        end
    end
    
    if foundSafeSpot then
        -- Create EPIC DODGE EFFECTS
        createDodgeEffects(rootPart.Position, safePosition)
        
        -- Teleport after a brief delay for dramatic effect
        spawn(function()
            wait(0.1) -- Small delay for animation
            rootPart.CFrame = CFrame.new(safePosition)
        end)
        
        Window:Notify({
            Title = "ðŸš€ EPIC DODGE!",
            Desc = "Cooldown: 0.5s",
            Time = 2
        })
    else
        Window:Notify({
            Title = "âŒ DODGE FAILED",
            Desc = "No safe spot found",
            Time = 2
        })
    end
end

function createDodgeEffects(startPos, endPos)
    local TweenService = game:GetService("TweenService")
    
    -- 1. DASH TRAIL EFFECT
    spawn(function()
        local trailPart = Instance.new("Part")
        trailPart.Size = Vector3.new(2, 2, 2)
        trailPart.Position = startPos
        trailPart.BrickColor = BrickColor.new("Bright blue")
        trailPart.Material = Enum.Material.Neon
        trailPart.Anchored = true
        trailPart.CanCollide = false
        trailPart.Parent = workspace
        
        local trailTween = TweenService:Create(trailPart, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Position = endPos,
            Transparency = 1
        })
        
        trailTween:Play()
        game:GetService("Debris"):AddItem(trailPart, 1)
    end)
    
    -- 2. AFTERIMAGE EFFECT (Multiple ghost copies)
    spawn(function()
        for i = 1, 3 do
            local afterImage = Instance.new("Part")
            afterImage.Size = Vector3.new(4, 6, 2)
            afterImage.Position = startPos + Vector3.new(0, 1, 0)
            afterImage.BrickColor = BrickColor.new("Bright violet")
            afterImage.Material = Enum.Material.Glass
            afterImage.Transparency = 0.7
            afterImage.Anchored = true
            afterImage.CanCollide = false
            afterImage.Parent = workspace
            
            local tweenInfo = TweenInfo.new(
                0.4, 
                Enum.EasingStyle.Quad, 
                Enum.EasingDirection.Out,
                0, -- RepeatCount
                false, -- Reverses
                i * 0.1 -- Delay
            )
            
            local afterTween = TweenService:Create(afterImage, tweenInfo, {
                Position = endPos + Vector3.new(0, 1, 0),
                Transparency = 1,
                Size = Vector3.new(2, 3, 1)
            })
            
            afterTween:Play()
            game:GetService("Debris"):AddItem(afterImage, 2)
        end
    end)
    
    -- 3. RING EXPLOSION EFFECT at start position
    spawn(function()
        for i = 1, 8 do
            local ringPart = Instance.new("Part")
            ringPart.Size = Vector3.new(0.5, 0.5, 0.5)
            ringPart.Position = startPos
            ringPart.BrickColor = BrickColor.new("Bright yellow")
            ringPart.Material = Enum.Material.Neon
            ringPart.Anchored = true
            ringPart.CanCollide = false
            ringPart.Parent = workspace
            
            local angle = (i / 8) * math.pi * 2
            local ringTween = TweenService:Create(ringPart, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Position = startPos + Vector3.new(
                    math.cos(angle) * 10,
                    math.sin(angle) * 2,
                    math.sin(angle) * 10
                ),
                Transparency = 1
            })
            
            ringTween:Play()
            game:GetService("Debris"):AddItem(ringPart, 2)
        end
    end)
    
    -- 4. SPEED LINES EFFECT
    spawn(function()
        local speedLines = Instance.new("Part")
        speedLines.Size = Vector3.new(10, 10, 10)
        speedLines.Position = startPos
        speedLines.Transparency = 1
        speedLines.Anchored = true
        speedLines.CanCollide = false
        speedLines.Parent = workspace
        
        local particleEmitter = Instance.new("ParticleEmitter")
        particleEmitter.Texture = "rbxasset://textures/particles/sparkles_main.dds"
        particleEmitter.Lifetime = NumberRange.new(0.3, 0.8)
        particleEmitter.Rate = 100
        particleEmitter.SpreadAngle = Vector2.new(45, 45)
        particleEmitter.Speed = NumberRange.new(10, 20)
        particleEmitter.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 255))
        })
        particleEmitter.Parent = speedLines
        
        game:GetService("Debris"):AddItem(speedLines, 1)
    end)
    
    -- 5. IMPACT EFFECT at destination
    spawn(function()
        wait(0.2) -- Delay for arrival
        
        local impactRing = Instance.new("Part")
        impactRing.Size = Vector3.new(1, 0.2, 1)
        impactRing.Position = endPos
        impactRing.BrickColor = BrickColor.new("Lime green")
        impactRing.Material = Enum.Material.Neon
        impactRing.Anchored = true
        impactRing.CanCollide = false
        impactRing.Parent = workspace
        
        local impactTween = TweenService:Create(impactRing, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Size = Vector3.new(15, 0.2, 15),
            Transparency = 1
        })
        
        impactTween:Play()
        game:GetService("Debris"):AddItem(impactRing, 2)
    end)
    
    -- 6. FLASH EFFECT
    spawn(function()
        local flash = Instance.new("Part")
        flash.Size = Vector3.new(20, 20, 20)
        flash.Position = startPos
        flash.BrickColor = BrickColor.new("Institutional white")
        flash.Material = Enum.Material.Neon
        flash.Transparency = 0.5
        flash.Anchored = true
        flash.CanCollide = false
        flash.Parent = workspace
        
        local flashTween = TweenService:Create(flash, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Transparency = 1,
            Size = Vector3.new(30, 30, 30)
        })
        
        flashTween:Play()
        game:GetService("Debris"):AddItem(flash, 1)
    end)
end

-- Auto Dash Script - No Visuals
local isAutoDashActive = false
local autoDashLoop = nil
local lastDashTime = 0
local dashCooldown = 2
local isHoldingShift = false
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Add the toggle button
PlayerTab:Toggle({
    Title = "ðŸŒ Auto Dodge Legit",
    Desc = "Auto dash away from attacks",
    Value = false,
    Callback = function(state)
        isAutoDashActive = state
        
        if state then
            Window:Notify({
                Title = "ðŸŒ AUTO DODGE LEGIT",
                Desc = "ACTIVE - Will dash from attacks!",
                Time = 3
            })
            
            if autoDashLoop then
                autoDashLoop:Disconnect()
            end
            
            autoDashLoop = game:GetService("RunService").Heartbeat:Connect(function()
                if not isAutoDashActive then return end
                autoDashRoutine()
            end)
            
        else
            Window:Notify({
                Title = "ðŸŒ AUTO DODGE LEGIT",
                Desc = "INACTIVE",
                Time = 3
            })
            releaseShift()
            if autoDashLoop then
                autoDashLoop:Disconnect()
                autoDashLoop = nil
            end
        end
    end
})

-- Shift holding functions
function holdShift()
    if not isHoldingShift then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
        isHoldingShift = true
    end
end

function releaseShift()
    if isHoldingShift then
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
        isHoldingShift = false
    end
end

-- Main detection routine
function autoDashRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        releaseShift()
        return 
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart or humanoid.Health <= 0 then 
        releaseShift()
        return 
    end
    
    -- Check cooldown
    if tick() - lastDashTime < dashCooldown then return end
    
    -- Detect if any player is attacking us
    local attacker, attackDirection, attackSide = detectAttackDirection()
    
    if attacker and attackSide then
        performDirectionalDash(attackSide, attackDirection)
        lastDashTime = tick()
    end
end

-- Detect which direction the attack is coming from
function detectAttackDirection()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil, nil, nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil, nil, nil end
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
            
            if otherRoot and otherHumanoid and otherHumanoid.Health > 0 then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                
                if distance <= 20 then
                    -- Calculate relative position
                    local attackerPos = otherRoot.Position
                    local myPos = rootPart.Position
                    local relativePos = attackerPos - myPos
                    
                    -- Get local space direction
                    local lookVector = rootPart.CFrame.LookVector
                    local rightVector = rootPart.CFrame.RightVector
                    
                    -- Convert to local space
                    local localX = relativePos:Dot(rightVector)
                    local localZ = relativePos:Dot(lookVector)
                    
                    -- Determine attack direction
                    local attackSide = getAttackDirection(localX, localZ)
                    local attackDirection = (attackerPos - myPos).Unit
                    
                    -- Check if attacker is actually attacking
                    local tool = otherPlayer.Character:FindFirstChildOfClass("Tool")
                    local lookDirection = otherRoot.CFrame.LookVector
                    local directionToMe = (myPos - attackerPos).Unit
                    
                    if tool and directionToMe:Dot(lookDirection) > 0.6 then
                        return otherPlayer, attackDirection, attackSide
                    end
                    
                    -- Also check animations
                    if isPlayerAnimatingAttack(otherPlayer) then
                        return otherPlayer, attackDirection, attackSide
                    end
                end
            end
        end
    end
    
    return nil, nil, nil
end

-- Determine which side the attack is coming from
function getAttackDirection(localX, localZ)
    local angle = math.atan2(localX, localZ)
    local degrees = math.deg(angle)
    
    if degrees < 0 then degrees = degrees + 360 end
    
    if degrees >= 315 or degrees < 45 then
        return "FRONT"
    elseif degrees >= 45 and degrees < 135 then
        return "RIGHT"
    elseif degrees >= 135 and degrees < 225 then
        return "BACK"
    else
        return "LEFT"
    end
end

-- Perform dash based on attack direction
function performDirectionalDash(attackSide, attackDirection)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart then return end
    
    -- HOLD SHIFT TO RUN
    holdShift()
    
    local dashVector = Vector3.new(0, 0, 0)
    
    -- Calculate dash direction based on attack side
    if attackSide == "FRONT" then
        -- Attack from front - dash backward
        dashVector = -rootPart.CFrame.LookVector
        
    elseif attackSide == "BACK" then
        -- Attack from back - dash forward
        dashVector = rootPart.CFrame.LookVector
        
    elseif attackSide == "LEFT" then
        -- Attack from left - dash right
        dashVector = rootPart.CFrame.RightVector
        
    elseif attackSide == "RIGHT" then
        -- Attack from right - dash left
        dashVector = -rootPart.CFrame.RightVector
    end
    
    -- Execute the dash
    if dashVector.Magnitude > 0 then
        -- Press Q to dash
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
        wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
        
        -- Move in dash direction while holding shift
        local dashDistance = 25
        local dashPosition = rootPart.Position + (dashVector * dashDistance)
        
        -- Move to dash position
        humanoid:MoveTo(dashPosition)
        
        -- Release shift after dash
        spawn(function()
            wait(0.5)
            releaseShift()
        end)
    end
end

-- Check if player is performing attack animations
function isPlayerAnimatingAttack(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return false end
    
    local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    if not humanoid then return false end
    
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then return false end
    
    for _, track in pairs(animator:GetPlayingAnimationTracks()) do
        local animName = track.Animation.Name:lower()
        if animName:find("attack") or animName:find("swing") or animName:find("slash") or 
           animName:find("punch") or animName:find("kick") or animName:find("shoot") then
            return true
        end
    end
    
    return false
end

-- Clean up when script stops
game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
    releaseShift()
end)

-- Initial notification
Window:Notify({
    Title = "ðŸŒ AUTO DASH",
    Desc = "Directional dodging enabled!",
    Time = 4
})

-- DAHENBOT - Working Chat Command System
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TextChatService = game:GetService("TextChatService")
local RunService = game:GetService("RunService")

-- Bot state
local isDahenBotActive = false
local lastMessageTime = 0
local messageCooldown = 2 -- seconds between bot messages

-- Add toggle to PlayerTab
PlayerTab:Toggle({
    Title = "DAHENBOT",
    Desc = "Enable chat commands",
    Value = false,
    Callback = function(state)
        isDahenBotActive = state
        
        if state then
            Window:Notify({
                Title = "DAHENBOT",
                Desc = "ACTIVE - Say: find [thing], hitbox, help",
                Time = 5
            })
            startMessageMonitor()
        else
            Window:Notify({
                Title = "DAHENBOT",
                Desc = "INACTIVE",
                Time = 3
            })
            stopMessageMonitor()
        end
    end
})

-- Monitor chat messages by reading the chat UI
local chatMonitor = nil
local function startMessageMonitor()
    if chatMonitor then return end
    
    chatMonitor = RunService.Heartbeat:Connect(function()
        if not isDahenBotActive then return end
        
        -- Try to find chat messages in the UI
        local success, result = pcall(function()
            -- Method 1: Check TextChatService
            if TextChatService and TextChatService.TextChannels then
                local channel = TextChatService.TextChannels.RBXGeneral
                if channel then
                    local messages = channel:GetMessageHistory()
                    if messages and #messages > 0 then
                        local latest = messages[#messages]
                        if latest and latest.Text then
                            local text = latest.Text
                            local timestamp = latest.Timestamp
                            
                            -- Check if this is a new message for our bot
                            if timestamp > lastMessageTime and (string.find(text:lower(), "dahenbot") or string.find(text:lower(), "bot")) then
                                lastMessageTime = timestamp
                                processChatCommand(text)
                            end
                        end
                    end
                end
            end
        end)
        
        -- If TextChatService method fails, try alternative method
        if not success then
            checkChatAlternative()
        end
    end)
end

local function stopMessageMonitor()
    if chatMonitor then
        chatMonitor:Disconnect()
        chatMonitor = nil
    end
end

-- Alternative chat checking method
local function checkChatAlternative()
    -- This is a backup method - we'll use the old chat system
    local chatUI = game:GetService("CoreGui"):FindFirstChild("Chat")
    if chatUI then
        local channel = chatUI:FindFirstChild("ChannelWindowFrame")
        if channel then
            local messages = channel:GetChildren()
            for _, msgFrame in pairs(messages) do
                if msgFrame:IsA("Frame") and msgFrame:FindFirstChild("MessageLabel") then
                    local label = msgFrame.MessageLabel
                    local text = label.Text
                    if text and (string.find(text:lower(), "dahenbot") or string.find(text:lower(), "bot")) then
                        processChatCommand(text)
                    end
                end
            end
        end
    end
end

-- Process chat commands
local function processChatCommand(message)
    local lowerMsg = message:lower()
    
    -- Find command
    if string.find(lowerMsg, "find") then
        local searchTerm = extractSearchTerm(lowerMsg)
        if searchTerm then
            local results = quickSearch(searchTerm)
            sendBotResponse("ðŸ” " .. results)
        end
    end
    
    -- Hitbox command
    if string.find(lowerMsg, "hitbox") and not string.find(lowerMsg, "find") then
        local results = searchHitboxes()
        sendBotResponse("ðŸŽ¯ " .. results)
    end
    
    -- Help command
    if string.find(lowerMsg, "help") then
        sendBotResponse("ðŸ¤– Commands: 'find [thing]', 'hitbox', 'help' - Say with 'dahenbot' or 'bot'")
    end
end

-- Extract search term from message
local function extractSearchTerm(message)
    local patterns = {
        "dahenbot find (.+)",
        "bot find (.+)",
        "find (.+) dahenbot",
        "find (.+) bot"
    }
    
    for _, pattern in ipairs(patterns) do
        local match = string.match(message, pattern)
        if match then
            return match:gsub(" dahenbot", ""):gsub(" bot", ""):gsub("^%s*(.-)%s*$", "%1")
        end
    end
    
    return nil
end

-- Send bot response
local function sendBotResponse(message)
    -- Try to send in chat
    local success = pcall(function()
        if TextChatService and TextChatService.TextChannels then
            local channel = TextChatService.TextChannels.RBXGeneral
            if channel then
                channel:SendAsync("ðŸ¤– DAHENBOT: " .. message)
                return true
            end
        end
        return false
    end)
    
    -- If chat fails, use notification
    if not success then
        Window:Notify({
            Title = "DAHENBOT",
            Desc = message,
            Time = 8
        })
    end
end

-- Quick search function
local function quickSearch(searchTerm)
    searchTerm = searchTerm:lower()
    local results = {}
    local count = 0
    
    -- Search in common locations
    local locations = {
        workspace,
        ReplicatedStorage,
        game:GetService("ServerScriptService"),
        game:GetService("StarterPack"),
        game:GetService("StarterPlayer")
    }
    
    for _, location in pairs(locations) do
        if count >= 8 then break end
        
        for _, obj in pairs(location:GetDescendants()) do
            if count >= 8 then break end
            
            -- Check name match
            if string.find(obj.Name:lower(), searchTerm) then
                table.insert(results, obj.Name)
                count = count + 1
            end
        end
    end
    
    if #results > 0 then
        return "Found " .. count .. " items: " .. table.concat(results, ", ")
    else
        return "No results for '" .. searchTerm .. "'"
    end
end

-- Search for hitbox-related objects
local function searchHitboxes()
    local results = {}
    local count = 0
    
    local hitboxTerms = {
        "hitbox", "hit", "damage", "attack", "sword", "weapon", 
        "tool", "handle", "part", "collision", "bounding", "melee"
    }
    
    -- Search workspace
    for _, obj in pairs(workspace:GetDescendants()) do
        if count >= 10 then break end
        
        local objName = obj.Name:lower()
        
        -- Check hitbox terms
        for _, term in pairs(hitboxTerms) do
            if string.find(objName, term) then
                table.insert(results, obj.Name)
                count = count + 1
                break
            end
        end
    end
    
    -- Search tools
    if localPlayer:FindFirstChild("Backpack") then
        for _, tool in pairs(localPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                table.insert(results, "Tool:" .. tool.Name)
                count = count + 1
                if count >= 10 then break end
            end
        end
    end
    
    if #results > 0 then
        return "Hitbox objects: " .. table.concat(results, ", ")
    else
        return "No hitbox objects found"
    end
end

-- Manual command buttons (backup method)
PlayerTab:Textbox({
    Title = "DAHENBOT Command",
    Desc = "Type commands manually",
    Placeholder = "find hitbox",
    Value = "",
    ClearTextOnFocus = false,
    Callback = function(command)
        if command and command ~= "" then
            processChatCommand("dahenbot " .. command)
        end
    end
})

PlayerTab:Button({
    Title = "Find Hitboxes",
    Desc = "Search for hitbox objects",
    Callback = function()
        processChatCommand("dahenbot hitbox")
    end
})

PlayerTab:Button({
    Title = "DAHENBOT Help",
    Desc = "Show commands",
    Callback = function()
        sendBotResponse("Commands: Type in chat - 'dahenbot find [thing]' or 'dahenbot hitbox'")
    end
})

-- Test button
PlayerTab:Button({
    Title = "Test Search",
    Desc = "Test the search function",
    Callback = function()
        local results = quickSearch("tool")
        sendBotResponse("TEST: " .. results)
    end
})

-- Initialize
Window:Notify({
    Title = "DAHENBOT",
    Desc = "Toggle ON and say 'dahenbot help' in chat",
    Time = 5
})

-- Auto Attack Script - Moves to nearest player and auto-attacks WITH RUNNING (Shift Hold)
local isAutoAttackActive = false
local autoAttackLoop = nil
local lastAttackTime = 0
local attackCooldown = 0.1
local isHoldingShift = false
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Add the first toggle button
PlayerTab:Toggle({
    Title = "âš”ï¸ Auto Attack",
    Desc = "Auto move to nearest player and attack",
    Value = false,
    Callback = function(state)
        isAutoAttackActive = state
        
        if state then
            Window:Notify({
                Title = "âš”ï¸ AUTO ATTACK",
                Desc = "ACTIVE - Hunting enemies!",
                Time = 3
            })
            
            if autoAttackLoop then
                autoAttackLoop:Disconnect()
            end
            
            autoAttackLoop = game:GetService("RunService").Heartbeat:Connect(function()
                if not isAutoAttackActive then return end
                autoAttackRoutine()
            end)
            
        else
            Window:Notify({
                Title = "âš”ï¸ AUTO ATTACK",
                Desc = "INACTIVE",
                Time = 3
            })
            releaseShift() -- Release shift when disabled
            if autoAttackLoop then
                autoAttackLoop:Disconnect()
                autoAttackLoop = nil
            end
        end
    end
})

-- Add the second toggle button (Smart Attack)
local isSmartAttackActive = false
local smartAttackLoop = nil

PlayerTab:Toggle({
    Title = "ðŸŽ¯ Smart Auto Attack",
    Desc = "Advanced targeting with weapon detection",
    Value = false,
    Callback = function(state)
        isSmartAttackActive = state
        
        if state then
            Window:Notify({
                Title = "ðŸŽ¯ SMART ATTACK",
                Desc = "ACTIVE - Weapon-based combat!",
                Time = 3
            })
            
            if smartAttackLoop then
                smartAttackLoop:Disconnect()
            end
            
            smartAttackLoop = game:GetService("RunService").Heartbeat:Connect(function()
                if not isSmartAttackActive then return end
                smartAttackRoutine()
            end)
            
        else
            Window:Notify({
                Title = "ðŸŽ¯ SMART ATTACK",
                Desc = "INACTIVE",
                Time = 3
            })
            releaseShift() -- Release shift when disabled
            if smartAttackLoop then
                smartAttackLoop:Disconnect()
                smartAttackLoop = nil
            end
        end
    end
})

-- Shift holding functions
function holdShift()
    if not isHoldingShift then
        -- Press and hold Shift
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
        isHoldingShift = true
    end
end

function releaseShift()
    if isHoldingShift then
        -- Release Shift
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
        isHoldingShift = false
    end
end

-- Shared functions for both toggles
function autoAttackRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        releaseShift()
        return 
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart or humanoid.Health <= 0 then 
        releaseShift()
        return 
    end
    
    -- Find nearest player
    local nearestPlayer, nearestDistance = findNearestPlayer()
    
    if nearestPlayer and nearestDistance then
        if nearestDistance <= 8 then
            -- Player is in attack range - ATTACK!
            releaseShift() -- Release shift when attacking
            if tick() - lastAttackTime >= attackCooldown then
                performAttack()
                lastAttackTime = tick()
            end
        else
            -- Player is out of range - RUN TO PLAYER!
            holdShift() -- Hold shift when chasing
            moveToPlayer(nearestPlayer, rootPart, humanoid)
        end
    else
        releaseShift()
        Window:Notify({
            Title = "ðŸŽ¯ SEARCHING",
            Desc = "No targets found",
            Time = 2
        })
    end
end

function smartAttackRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        releaseShift()
        return 
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart or humanoid.Health <= 0 then 
        releaseShift()
        return 
    end
    
    -- Check if player has a weapon
    local weapon = character:FindFirstChildOfClass("Tool")
    local attackRange = weapon and 10 or 5 -- Longer range if has weapon
    
    local nearestPlayer, nearestDistance = findNearestPlayer()
    
    if nearestPlayer and nearestDistance then
        if nearestDistance <= attackRange then
            -- In attack range
            releaseShift() -- Release shift when attacking
            if tick() - lastAttackTime >= attackCooldown then
                if weapon then
                    useWeaponAttack(weapon)
                else
                    performMeleeAttack()
                end
                lastAttackTime = tick()
            end
        else
            -- Move to target - RUN FAST!
            holdShift() -- Hold shift when chasing
            moveToPlayer(nearestPlayer, rootPart, humanoid)
            
            -- Show distance indicator
            Window:Notify({
                Title = "ðŸŽ¯ TARGET",
                Desc = "Distance: " .. math.floor(nearestDistance) .. " studs",
                Time = 1
            })
        end
    else
        releaseShift()
        Window:Notify({
            Title = "ðŸŽ¯ SEARCHING",
            Desc = "No targets found",
            Time = 2
        })
    end
end

function findNearestPlayer()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil, math.huge end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil, math.huge end
    
    local nearestPlayer = nil
    local nearestDistance = math.huge
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
            
            if otherRoot and otherHumanoid and otherHumanoid.Health > 0 then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end
    
    return nearestPlayer, nearestDistance
end

function moveToPlayer(targetPlayer, rootPart, humanoid)
    if not targetPlayer or not targetPlayer.Character then 
        releaseShift()
        return 
    end
    
    local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then 
        releaseShift()
        return 
    end
    
    -- Calculate direction to target
    local direction = (targetRoot.Position - rootPart.Position).Unit
    
    -- Move towards target (character will run because Shift is held)
    humanoid:MoveTo(targetRoot.Position)
    
    -- Face the target
    rootPart.CFrame = CFrame.new(rootPart.Position, Vector3.new(targetRoot.Position.X, rootPart.Position.Y, targetRoot.Position.Z))
    
    -- Visual effect for movement (different color when running)
    spawn(function()
        local moveEffect = Instance.new("Part")
        moveEffect.Size = Vector3.new(1, 0.2, 1)
        moveEffect.Position = rootPart.Position - Vector3.new(0, 2.5, 0)
        moveEffect.BrickColor = BrickColor.new("Bright blue") -- Blue when running
        moveEffect.Material = Enum.Material.Neon
        moveEffect.Anchored = true
        moveEffect.CanCollide = false
        moveEffect.Transparency = 0.7
        moveEffect.Parent = workspace
        
        game:GetService("Debris"):AddItem(moveEffect, 0.3)
    end)
    
    -- Stop running if very close to target
    local distance = (rootPart.Position - targetRoot.Position).Magnitude
    if distance <= 6 then
        releaseShift()
    end
end

function performAttack()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    -- Make sure shift is released
    releaseShift()
    
    -- Method 1: Simulate mouse click (works for most combat systems)
    -- Left click (primary attack)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.05)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    
    -- Method 2: Press attack keys (E, F, Q, R, Space)
    local attackKeys = {Enum.KeyCode.E, Enum.KeyCode.F, Enum.KeyCode.Q, Enum.KeyCode.R, Enum.KeyCode.Space}
    
    for _, key in pairs(attackKeys) do
        VirtualInputManager:SendKeyEvent(true, key, false, game)
        wait(0.03)
        VirtualInputManager:SendKeyEvent(false, key, false, game)
        wait(0.02)
    end
    
    -- Visual effect for attack
    createAttackEffects(character)
    
    Window:Notify({
        Title = "ðŸ—¡ï¸ ATTACKING!",
        Desc = "Auto-attack executed!",
        Time = 1
    })
end

function useWeaponAttack(weapon)
    -- Make sure shift is released
    releaseShift()
    
    -- Activate the weapon
    if weapon:FindFirstChild("Handle") then
        -- Simulate clicking the weapon
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
        wait(0.1)
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
        
        -- Weapon-specific visual effect
        createWeaponEffects(weapon)
        
        Window:Notify({
            Title = "ðŸ”« WEAPON ATTACK",
            Desc = "Fired " .. weapon.Name,
            Time = 1
        })
    end
end

function performMeleeAttack()
    -- Make sure shift is released
    releaseShift()
    
    -- Melee combo: Click + Space
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.05)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
    wait(0.05)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
    
    Window:Notify({
        Title = "ðŸ¥Š MELEE ATTACK",
        Desc = "Punch/Kick combo!",
        Time = 1
    })
end

function createAttackEffects(character)
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    local TweenService = game:GetService("TweenService")
    
    -- SWING EFFECT
    spawn(function()
        for i = 1, 3 do
            local swingPart = Instance.new("Part")
            swingPart.Size = Vector3.new(2, 2, 0.5)
            swingPart.Position = rootPart.Position + (rootPart.CFrame.LookVector * 3)
            swingPart.BrickColor = BrickColor.new("Bright orange")
            swingPart.Material = Enum.Material.Neon
            swingPart.Anchored = true
            swingPart.CanCollide = false
            swingPart.Parent = workspace
            
            local angle = math.rad(i * 45)
            local swingTween = TweenService:Create(swingPart, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
                Position = rootPart.Position + Vector3.new(
                    math.cos(angle) * 5,
                    0,
                    math.sin(angle) * 5
                ),
                Transparency = 1
            })
            
            swingTween:Play()
            game:GetService("Debris"):AddItem(swingPart, 1)
        end
    end)
    
    -- IMPACT WAVE
    spawn(function()
        local wave = Instance.new("Part")
        wave.Shape = Enum.PartType.Cylinder
        wave.Size = Vector3.new(0.2, 2, 2)
        wave.Position = rootPart.Position
        wave.Orientation = Vector3.new(0, 0, 90)
        wave.BrickColor = BrickColor.new("Bright red")
        wave.Material = Enum.Material.Neon
        wave.Anchored = true
        wave.CanCollide = false
        wave.Parent = workspace
        
        local waveTween = TweenService:Create(wave, TweenInfo.new(0.4, Enum.EasingStyle.Quad), {
            Size = Vector3.new(0.2, 10, 10),
            Transparency = 1
        })
        
        waveTween:Play()
        game:GetService("Debris"):AddItem(wave, 1)
    end)
end

function createWeaponEffects(weapon)
    local character = game.Players.LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    -- Muzzle flash effect for weapons
    local muzzle = Instance.new("Part")
    muzzle.Size = Vector3.new(1, 1, 1)
    muzzle.Position = rootPart.Position + (rootPart.CFrame.LookVector * 4)
    muzzle.BrickColor = BrickColor.new("Bright yellow")
    muzzle.Material = Enum.Material.Neon
    muzzle.Anchored = true
    muzzle.CanCollide = false
    muzzle.Parent = workspace
    
    game:GetService("Debris"):AddItem(muzzle, 0.2)
end

-- Clean up when script stops
game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
    releaseShift()
end)

-- Initial notification
Window:Notify({
    Title = "âš”ï¸ AUTO ATTACK",
    Desc = "Now with Shift running enabled!",
    Time = 4
})

-- Auto TP Attack - Loop TP to nearest player with spam attacks
local isAutoTPAttackActive = false
local autoTPAttackLoop = nil
local currentTarget = nil
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Add the toggle button
PlayerTab:Toggle({
    Title = "ðŸ” KILLAURA RAGE",
    Desc = "Loop TP to nearest player with spam attacks",
    Value = false,
    Callback = function(state)
        isAutoTPAttackActive = state
        
        if state then
            Window:Notify({
                Title = "ðŸ” KILLAURA RAGE",
                Desc = "ACTIVE - Teleporting and attacking!",
                Time = 3
            })
            
            if autoTPAttackLoop then
                autoTPAttackLoop:Disconnect()
            end
            
            autoTPAttackLoop = game:GetService("RunService").Heartbeat:Connect(function()
                if not isAutoTPAttackActive then return end
                autoTPAttackRoutine()
            end)
            
        else
            Window:Notify({
                Title = "ðŸ” KILLAURA RAGE",
                Desc = "INACTIVE",
                Time = 3
            })
            currentTarget = nil
            if autoTPAttackLoop then
                autoTPAttackLoop:Disconnect()
                autoTPAttackLoop = nil
            end
        end
    end
})

-- Main TP attack routine
function autoTPAttackRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart or humanoid.Health <= 0 then return end
    
    -- Check if current target is still valid
    if currentTarget then
        if not isTargetValid(currentTarget) then
            -- Target died or became invalid, find new one
            currentTarget = nil
            Window:Notify({
                Title = "ðŸŽ¯ TARGET DOWN",
                Desc = "Finding new target...",
                Time = 2
            })
        end
    end
    
    -- Find new target if needed
    if not currentTarget then
        currentTarget = findNearestPlayer()
        if currentTarget then
            Window:Notify({
                Title = "ðŸŽ¯ NEW TARGET",
                Desc = "Targeting: " .. currentTarget.Name,
                Time = 2
            })
        else
            return -- No targets found
        end
    end
    
    -- TP to target and attack
    if currentTarget and currentTarget.Character then
        local targetRoot = currentTarget.Character:FindFirstChild("HumanoidRootPart")
        if targetRoot then
            -- Teleport behind the target
            local behindOffset = -targetRoot.CFrame.LookVector * 3
            local tpPosition = targetRoot.Position + behindOffset + Vector3.new(0, 3, 0)
            
            -- Teleport to target
            rootPart.CFrame = CFrame.new(tpPosition)
            
            -- Face the target
            rootPart.CFrame = CFrame.new(rootPart.Position, Vector3.new(targetRoot.Position.X, rootPart.Position.Y, targetRoot.Position.Z))
            
            -- Spam attacks
            performSpamAttacks()
        end
    end
end

-- Check if target is still valid (alive and in game)
function isTargetValid(targetPlayer)
    if not targetPlayer then return false end
    if not targetPlayer.Character then return false end
    
    local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    if not humanoid then return false end
    
    return humanoid.Health > 0
end

-- Find nearest player (excluding current target if any)
function findNearestPlayer()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end
    
    local nearestPlayer = nil
    local nearestDistance = math.huge
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
            
            if otherRoot and otherHumanoid and otherHumanoid.Health > 0 then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end
    
    return nearestPlayer
end

-- Perform spam attacks
function performSpamAttacks()
    -- Rapid mouse clicks for spam
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.01)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    
    -- Additional rapid clicks for more spam
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.01)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
end

-- Monitor target health to auto-switch
local targetMonitorLoop = nil

-- Start monitoring target health when toggle is enabled
game:GetService("Players").LocalPlayer.Chatted:Connect(function(message)
    if message:lower() == "start target monitor" and isAutoTPAttackActive and not targetMonitorLoop then
        startTargetMonitor()
    end
end)

function startTargetMonitor()
    if targetMonitorLoop then
        targetMonitorLoop:Disconnect()
    end
    
    targetMonitorLoop = game:GetService("RunService").Heartbeat:Connect(function()
        if not isAutoTPAttackActive then
            if targetMonitorLoop then
                targetMonitorLoop:Disconnect()
                targetMonitorLoop = nil
            end
            return
        end
        
        if currentTarget and currentTarget.Character then
            local humanoid = currentTarget.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then
                Window:Notify({
                    Title = "ðŸ’€ TARGET ELIMINATED",
                    Desc = "Moving to next target...",
                    Time = 2
                })
                currentTarget = nil
            end
        end
    end)
end

-- Clean up when script stops
game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
    currentTarget = nil
    if targetMonitorLoop then
        targetMonitorLoop:Disconnect()
        targetMonitorLoop = nil
    end
end)

-- Initial notification
Window:Notify({
    Title = "ðŸ” AUTO TP ATTACK",
    Desc = "Will TP to nearest player and spam attacks!",
    Time = 4
})

-- Magnitude Hitbox Expander
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer

-- Hitbox variables
local isHitboxExpanderActive = false
local magnitudeMultiplier = 2.0
local originalMagnitude = nil

-- Add toggle to PlayerTab
PlayerTab:Toggle({
    Title = "KILLAURA",
    Desc = "Extend attack range",
    Value = false,
    Callback = function(state)
        isHitboxExpanderActive = state
        
        if state then
            enableMagnitudeExpansion()
        else
            disableMagnitudeExpansion()
        end
    end
})

-- Multiplier input
PlayerTab:Textbox({
    Title = "KILLAURA RANGE",
    Desc = "Set multiplier (1-10)",
    Placeholder = "2.0",
    Value = "2.0",
    ClearTextOnFocus = false,
    Callback = function(text)
        local newMultiplier = tonumber(text)
        if newMultiplier and newMultiplier >= 1 and newMultiplier <= 10 then
            magnitudeMultiplier = newMultiplier
        end
    end
})

-- Hook magnitude function
local function enableMagnitudeExpansion()
    if originalMagnitude then return end
    
    -- Store original magnitude function
    originalMagnitude = Vector3.Magnitude
    
    -- Replace with modified version
    Vector3.Magnitude = function(self)
        local result = originalMagnitude(self)
        if isHitboxExpanderActive then
            return result / magnitudeMultiplier
        end
        return result
    end
end

-- Restore original function
local function disableMagnitudeExpansion()
    if originalMagnitude then
        Vector3.Magnitude = originalMagnitude
        originalMagnitude = nil
    end
end

-- Clean up when character is removed
localPlayer.CharacterRemoving:Connect(function()
    disableMagnitudeExpansion()
end)

-- GAME TAB CONTENT
GameTab:Section({Title = "GAME TELEPORTS"})

GameTab:Section({Title = "Red Light Green Light"})

GameTab:Button({
    Title = "RLGL - Teleport To End",
    Desc = "Teleport to Red Light Green Light end",
    Callback = function()
        local char = localPlayer.Character
        char.HumanoidRootPart.CFrame = CFrame.new(-46.0587921, 1025.23352, 108.6353122)
    end
})

GameTab:Button({
    Title = "RLGL - Teleport To Start",
    Desc = "Teleport to Red Light Green Light start",
    Callback = function()
        local char = localPlayer.Character
        char.HumanoidRootPart.CFrame = CFrame.new(-48.5137215, 1024.521, -492.023163)
    end
})

-- Get all player usernames
local function getPlayerList()
    local playerList = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            table.insert(playerList, player.Name)
        end
    end
    return playerList
end

-- Find player by username
local function getPlayerByName(name)
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Name == name then
            return player
        end
    end
    return nil
end

-- Auto help function
local function autoHelp()
    local playerList = getPlayerList()
    local targetPlayer = nil
    local targetPlayerName = nil
    local to = Players:GetAttribute("InjuredPlayer")
end

local NEVERAURA = false
local MAYBEAURA = false

GameTab:Toggle({
    Title = "ANTI SHOT!!",
    Desc = "Anti shot protection",
    Value = false,
    Callback = function(state)
        MAYBEAURA = state
        local char = localPlayer.Character
        while true do
            if MAYBEAURA == true then
                char.Parent = workspace.Live.GreenPlayers
                if char:FindFirstChild("MovedRecentlyRedLight") then
                    char.SafeRedLightGreenLight:Destroy()
                end
                if char:FindFirstChild("SafeRedLightGreenLight") then
                    char.SafeRedLightGreenLight:Destroy()
                end

                local folder = Instance.new("Folder")
                folder.Parent = char
                folder.Name = "SafeRedLightGreenLight"
            end
            task.wait()
        end
    end
})

GameTab:Toggle({
    Title = "RLGL - Auto Help",
    Desc = "Auto help in RLGL",
    Value = false,
    Callback = function(state)
        NEVERAURA = state
    end
})

Window:Line()

GameTab:Section({Title = "Dalgona"})

local NOTDELETEABLE = {"Lighting", "Won", "PickModelCacheFix"}

local shapes = {"Star", "Circle", "Umbrella", "MonaLisa", "Triangle", "SackBoy"}
local outlineParts = {}
local connection = nil
local clickConnections = {}

local function createOutline(shape)
    -- Clear existing outline
    for _, part in pairs(outlineParts) do
        part:Destroy()
    end
    outlineParts = {}

    if not shape then return end

    local cf, size = shape:GetBoundingBox()
    local thickness = 0.3
    local padding = 0.5
    local outlineSize = size + Vector3.new(padding * 2, padding * 2, padding * 2)

    local edges = {
        {pos = Vector3.new(outlineSize.X/2, -outlineSize.Y/2, 0), size = Vector3.new(thickness, thickness, outlineSize.Z)},
        {pos = Vector3.new(-outlineSize.X/2, -outlineSize.Y/2, 0), size = Vector3.new(thickness, thickness, outlineSize.Z)},
        {pos = Vector3.new(0, -outlineSize.Y/2, outlineSize.Z/2), size = Vector3.new(outlineSize.X, thickness, thickness)},
        {pos = Vector3.new(0, -outlineSize.Y/2, -outlineSize.Z/2), size = Vector3.new(outlineSize.X, thickness, thickness)},
        {pos = Vector3.new(outlineSize.X/2, outlineSize.Y/2, 0), size = Vector3.new(thickness, thickness, outlineSize.Z)},
        {pos = Vector3.new(-outlineSize.X/2, outlineSize.Y/2, 0), size = Vector3.new(thickness, thickness, outlineSize.Z)},
        {pos = Vector3.new(0, outlineSize.Y/2, outlineSize.Z/2), size = Vector3.new(outlineSize.X, thickness, thickness)},
        {pos = Vector3.new(0, outlineSize.Y/2, -outlineSize.Z/2), size = Vector3.new(outlineSize.X, thickness, thickness)},
        {pos = Vector3.new(outlineSize.X/2, 0, outlineSize.Z/2), size = Vector3.new(thickness, outlineSize.Y, thickness)},
        {pos = Vector3.new(-outlineSize.X/2, 0, outlineSize.Z/2), size = Vector3.new(thickness, outlineSize.Y, thickness)},
        {pos = Vector3.new(outlineSize.X/2, 0, -outlineSize.Z/2), size = Vector3.new(thickness, outlineSize.Y, thickness)},
        {pos = Vector3.new(-outlineSize.X/2, 0, -outlineSize.Z/2), size = Vector3.new(thickness, outlineSize.Y, thickness)},
    }

    for _, edge in pairs(edges) do
        local part = Instance.new("Part")
        part.Size = edge.size
        part.Anchored = true
        part.CanCollide = false
        part.Material = Enum.Material.Neon
        part.Color = Color3.fromRGB(0, 255, 0)
        part.Transparency = 0
        part.Parent = workspace
        table.insert(outlineParts, part)
    end

    if connection then connection:Disconnect() end
    connection = RunService.RenderStepped:Connect(function()
        if not shape or not shape.Parent then
            for _, part in pairs(outlineParts) do
                part:Destroy()
            end
            outlineParts = {}
            if connection then connection:Disconnect() end
            return
        end

        local newCf = shape:GetBoundingBox()
        for i, part in pairs(outlineParts) do
            part.CFrame = newCf * CFrame.new(edges[i].pos)
        end
    end)

    print("Outline created!")
end

GameTab:Button({
    Title = "Auto Cookie",
    Desc = "Auto complete cookie game",
    Callback = function()
        local Module = game.ReplicatedStorage.Modules.Games.DalgonaClient
        for _, f in ipairs(getreg()) do
            if typeof(f) == "function" and islclosure(f) then
                if getfenv(f).script == Module then
                    if getinfo(f).nups == 76 then
                        setupvalue(f, 33, 9e9)
                        setupvalue(f, 34, 9e9)
                        break
                    end
                end
            end
        end
    end
})

-- ESP Configuration
local espSeekersEnabled = false
local espHidersEnabled = false

-- Function to check if player has a knife (is a seeker)
local function isSeeker(player)
    if not player then return false end

    -- Check character for knife
    if player.Character and player.Character:FindFirstChild("Knife") then
        return true
    end

    -- Check backpack for knife
    local backpack = player:FindFirstChild("Backpack")
    if backpack and backpack:FindFirstChild("Knife") then
        return true
    end

    return false
end

-- Create simple box ESP
local function createBox(character, color)
    if not character or not character:FindFirstChild("HumanoidRootPart") then return end

    -- Remove existing box
    local existingBox = character:FindFirstChild("ESPBox")
    if existingBox then
        existingBox:Destroy()
    end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")

    -- Determine target part based on rig type
    local targetPart = humanoidRootPart
    if humanoid then
        if humanoid.RigType == Enum.HumanoidRigType.R6 then
            targetPart = character:FindFirstChild("Torso") or humanoidRootPart
        else
            targetPart = character:FindFirstChild("LowerTorso") or humanoidRootPart
        end
    end

    -- Create BillboardGui for box
    local boxGui = Instance.new("BillboardGui")
    boxGui.Name = "ESPBox"
    boxGui.Parent = character
    boxGui.Size = UDim2.new(4, 0, 6, 0)
    boxGui.StudsOffset = Vector3.new(0, 0, 0)
    boxGui.Adornee = targetPart
    boxGui.AlwaysOnTop = true
    boxGui.ZIndexBehavior = Enum.ZIndexBehavior.Global

    -- Container frame
    local containerFrame = Instance.new("Frame")
    containerFrame.Parent = boxGui
    containerFrame.Size = UDim2.new(1, 0, 1, 0)
    containerFrame.BackgroundTransparency = 1

    -- Create box edges (Top, Bottom, Left, Right)
    local edges = {
        {UDim2.new(1, 0, 0, 2), UDim2.new(0, 0, 0, 0)}, -- Top
        {UDim2.new(1, 0, 0, 2), UDim2.new(0, 0, 1, -2)}, -- Bottom
        {UDim2.new(0, 2, 1, 0), UDim2.new(0, 0, 0, 0)}, -- Left
        {UDim2.new(0, 2, 1, 0), UDim2.new(1, -2, 0, 0)} -- Right
    }

    for _, data in ipairs(edges) do
        local edge = Instance.new("Frame")
        edge.Parent = containerFrame
        edge.Size = data[1]
        edge.Position = data[2]
        edge.BackgroundColor3 = color
        edge.BorderSizePixel = 0
    end
end

-- Remove box from character
local function removeBox(character)
    if not character then return end
    local box = character:FindFirstChild("ESPBox")
    if box then
        box:Destroy()
    end
end

-- Update ESP for a single player
local function updatePlayerESP(player)
    if not player or player == localPlayer then return end
    if not player.Character then return end

    local isSeekerRole = isSeeker(player)

    -- Check if we should show ESP
    if (isSeekerRole and espSeekersEnabled) then
        createBox(player.Character, Color3.new(1, 0, 0)) -- Red for seeker
    elseif (not isSeekerRole and espHidersEnabled) then
        createBox(player.Character, Color3.new(0, 0, 1)) -- Blue for hider
    else
        removeBox(player.Character)
    end
end

-- Update all players ESP
local function updateAllESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            updatePlayerESP(player)
        end
    end
end

-- Remove all ESP boxes
local function removeAllESP()
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Character then
            removeBox(player.Character)
        end
    end
end

-- Setup player monitoring
local function setupPlayer(player)
    if player == localPlayer then return end

    -- Monitor character added
    player.CharacterAdded:Connect(function(character)
        task.wait(0.5) -- Wait for character to fully load
        updatePlayerESP(player)
    end)

    -- Monitor existing character
    if player.Character then
        -- Monitor for knife changes
        player.Character.ChildAdded:Connect(function(child)
            if child.Name == "Knife" then
                task.wait(0.1)
                updatePlayerESP(player)
            end
        end)

        player.Character.ChildRemoved:Connect(function(child)
            if child.Name == "Knife" then
                task.wait(0.1)
                updatePlayerESP(player)
            end
        end)
    end

    -- Monitor backpack
    local backpack = player:FindFirstChild("Backpack")
    if backpack then
        backpack.ChildAdded:Connect(function(child)
            if child.Name == "Knife" then
                task.wait(0.1)
                updatePlayerESP(player)
            end
        end)

        backpack.ChildRemoved:Connect(function(child)
            if child.Name == "Knife" then
                task.wait(0.1)
                updatePlayerESP(player)
            end
        end)
    end
end

-- Initialize ESP system
local function initializeESP()
    -- Setup existing players
    for _, player in ipairs(Players:GetPlayers()) do
        setupPlayer(player)
    end

    -- Setup new players
    Players.PlayerAdded:Connect(setupPlayer)

    -- Cleanup when players leave
    Players.PlayerRemoving:Connect(function(player)
        if player.Character then
            removeBox(player.Character)
        end
    end)
end

-- Start the ESP system
initializeESP()

Window:Line()

GameTab:Section({Title = "Final Dinner / HNS"})

GameTab:Button({
    Title = "Final Dinner - Teleport To Safe Spot",
    Desc = "Teleport to safe spot in Final Dinner",
    Callback = function()
        local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.HumanoidRootPart.CFrame = CFrame.new(182.413818, 121.033997, -93.8286514)
        end
    end
})

GameTab:Toggle({
    Title = "ESP Seekers",
    Desc = "Show ESP for seekers",
    Value = false,
    Callback = function(state)
        espSeekersEnabled = state
        updateAllESP()
        print("ESP Seekers:", state and "Enabled" or "Disabled")
    end
})

GameTab:Toggle({
    Title = "ESP Hiders",
    Desc = "Show ESP for hiders",
    Value = false,
    Callback = function(state)
        espHidersEnabled = state
        updateAllESP()
        print("ESP Hiders:", state and "Enabled" or "Disabled")
    end
})

GameTab:Button({
    Title = "HNS - ESP Exit",
    Desc = "Highlight exit doors in HNS",
    Callback = function()
        for i, floor1doors in pairs(game.Workspace.HideAndSeekMap.NEWFIXEDDOORS.Floor1.EXITDOORS:GetChildren()) do
            Instance.new("Highlight", floor1doors)
        end
        for i, floor2doors in pairs(game.Workspace.HideAndSeekMap.NEWFIXEDDOORS.Floor2.EXITDOORS:GetChildren()) do
            Instance.new("Highlight", floor2doors)
        end
        for i, floor3doors in pairs(game.Workspace.HideAndSeekMap.NEWFIXEDDOORS.Floor3.EXITDOORS:GetChildren()) do
            Instance.new("Highlight", floor3doors)
        end
    end
})

GameTab:Button({
    Title = "HNS - Delete The Spikes",
    Desc = "Remove spikes in HNS",
    Callback = function()
        game.Workspace.HideAndSeekMap.KillingParts:Destroy()
    end
})

-- Loopkill Variables
local selectedTarget = nil
local loopkillEnabled = false
local loopkillConnection = nil
local lastAttackTime = 0
local attackCooldown = 0.3

-- Get all player usernames
local function getPlayerList()
    local playerList = {}
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= localPlayer then
            table.insert(playerList, player.Name)
        end
    end
    return playerList
end

-- Find player by username
local function getPlayerByName(name)
    for _, player in ipairs(Players:GetPlayers()) do
        if player.Name == name then
            return player
        end
    end
    return nil
end

-- Get damage tool (Knife, Fork, or Bottle)
local function getDamageTool()
    local character = localPlayer.Character
    if not character then return nil end

    -- Check if tool is equipped in character
    local knife = character:FindFirstChild("Knife")
    if knife and knife:IsA("Tool") then return knife end

    local fork = character:FindFirstChild("Fork")
    if fork and fork:IsA("Tool") then return fork end

    local bottle = character:FindFirstChild("Bottle")
    if bottle and bottle:IsA("Tool") then return bottle end

    -- Check backpack
    local backpack = localPlayer:FindFirstChild("Backpack")
    if backpack then
        knife = backpack:FindFirstChild("Knife")
        if knife and knife:IsA("Tool") then return knife end

        fork = backpack:FindFirstChild("Fork")
        if fork and fork:IsA("Tool") then return fork end

        bottle = backpack:FindFirstChild("Bottle")
        if bottle and bottle:IsA("Tool") then return bottle end
    end

    return nil
end

-- Equip the damage tool
local function equipDamageTool()
    local tool = getDamageTool()
    if not tool then return false end

    -- If tool is in backpack, equip it
    if tool.Parent == localPlayer.Backpack then
        localPlayer.Character.Humanoid:EquipTool(tool)
        task.wait(0.1)
    end

    return true
end

-- Calculate orbit position around target
local function getOrbitPosition(targetPosition, angle, radius)
    local x = targetPosition.X + math.cos(angle) * radius
    local z = targetPosition.Z + math.sin(angle) * radius
    return Vector3.new(x, targetPosition.Y, z)
end

local function performLoopkill()
    if not loopkillEnabled or not selectedTarget then return end
    local targetPlayer = getPlayerByName(selectedTarget)
    if not targetPlayer or not targetPlayer.Character then return end
    local targetChar = targetPlayer.Character
    local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
    local targetHumanoid = targetChar:FindFirstChild("Humanoid")
    if not targetRoot or not targetHumanoid or targetHumanoid.Health <= 0 then return end
    local character = localPlayer.Character
    if not character then return end
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end
    -- Equip damage tool
    if not equipDamageTool() then
        warn("No damage tool found (Knife, Fork, or Bottle)")
        return
    end
    local tool = getDamageTool()
    if not tool or tool.Parent ~= character then return end
    -- Calculate orbit angle based on time
    local currentTime = tick()
    local angle = (currentTime * 3) % (math.pi * 2) -- Rotate around target
    local radius = 1 -- Distance from target (closer)
    -- Get orbit position
    local orbitPos = getOrbitPosition(targetRoot.Position, angle, radius)
    -- Teleport to orbit position
    humanoidRootPart.CFrame = CFrame.new(orbitPos)
    -- Attack every 0.1 seconds
    if currentTime - lastAttackTime >= 0.1 then
        -- Activate the tool to damage
        if tool:FindFirstChild("Handle") then
            -- Fire remote or activate tool
            local remoteEvent = tool:FindFirstChildWhichIsA("RemoteEvent")
            local remoteFunction = tool:FindFirstChildWhichIsA("RemoteFunction")
            if remoteEvent then
                pcall(function()
                    remoteEvent:FireServer()
                end)
            end
            if remoteFunction then
                pcall(function()
                    remoteFunction:InvokeServer()
                end)
            end
            -- Try to activate tool
            pcall(function()
                tool:Activate()
            end)
        end
        lastAttackTime = currentTime
    end
end

Window:Line()

GameTab:Section({Title = "Tug of War"})

local tugOfWarAutoEnabled = false
local tugOfWarAutoThread = nil
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remote = ReplicatedStorage.Remotes:WaitForChild("TemporaryReachedBindable")
local VALID_PULL_DATA = { { IHateYou = true } }

GameTab:Toggle({
    Title = "Tug of War Auto",
    Desc = "Auto tug of war",
    Value = false,
    Callback = function(state)
        tugOfWarAutoEnabled = state
        if state then
            if tugOfWarAutoThread then return end
            tugOfWarAutoThread = task.spawn(function()
                while tugOfWarAutoEnabled do
                    Remote:FireServer(unpack(VALID_PULL_DATA))
                    task.wait(0.025)
                end
                tugOfWarAutoThread = nil
            end)
        else
            tugOfWarAutoEnabled = false
            if tugOfWarAutoThread then
                task.cancel(tugOfWarAutoThread)
                tugOfWarAutoThread = nil
            end
        end
    end
})

-- Start loopkill
local function startLoopkill()
    if loopkillConnection then
        loopkillConnection:Disconnect()
    end

    loopkillConnection = RunService.Heartbeat:Connect(function()
        if loopkillEnabled and selectedTarget then
            pcall(performLoopkill)
        end
    end)

    print("Loopkill started on:", selectedTarget)
end

-- Stop loopkill
local function stopLoopkill()
    if loopkillConnection then
        loopkillConnection:Disconnect()
        loopkillConnection = nil
    end

    print("Loopkill stopped")
end

-- Player dropdown
local playerDropdown = GameTab:Dropdown({
    Title = "Select Target",
    List = getPlayerList(),
    Value = nil,
    Callback = function(selected)
        selectedTarget = selected
        print("Target selected:", selectedTarget)

        -- If loopkill is already enabled, restart with new target
        if loopkillEnabled then
            stopLoopkill()
            startLoopkill()
        end
    end
})

-- Loopkill toggle
GameTab:Toggle({
    Title = "Kill aura",
    Desc = "Enable kill aura",
    Value = false,
    Callback = function(state)
        loopkillEnabled = state

        if state then
            if not selectedTarget then
                warn("Please select a target first!")
                loopkillEnabled = false
                return
            end

            if not getDamageTool() then
                warn("You need a Knife, Fork, or Bottle to use loopkill!")
                loopkillEnabled = false
                return
            end

            startLoopkill()
        else
            stopLoopkill()
        end
    end
})

-- Update player list when players join/leave
Players.PlayerAdded:Connect(function()
    task.wait(0.5)
    -- Note: You'd need to manually refresh the dropdown or add an update function
    print("Player joined - consider refreshing target list")
end)

Players.PlayerRemoving:Connect(function(player)
    if selectedTarget == player.Name then
        selectedTarget = nil
        loopkillEnabled = false
        stopLoopkill()
        print("Target left the game - loopkill disabled")
    end
end)

-- Clean up on death
localPlayer.CharacterAdded:Connect(function()
    task.wait(1)
    if loopkillEnabled then
        print("Respawned - restarting loopkill")
    end
end)

Window:Line()

GameTab:Section({Title = "Jump Rope"})

GameTab:Button({
    Title = "Jump Rope - Teleport To End",
    Desc = "Teleport to jump rope end",
    Callback = function()
        local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.HumanoidRootPart.CFrame = CFrame.new(720.896057, 198.628311, 921.170654)
        end
    end
})

GameTab:Button({
    Title = "Jump Rope - Delete The Rope",
    Desc = "Remove jump rope",
    Callback = function()
        game.Workspace.Effects.rope:Destroy()
    end
})

Window:Line()

GameTab:Section({Title = "Glass Bridge"})

GameTab:Button({
    Title = "Glass Bridge - Teleport To End",
    Desc = "Teleport to glass bridge end",
    Callback = function()
        local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.HumanoidRootPart.CFrame = CFrame.new(-196.372467, 522.192139, -1534.20984)
        end
    end
})

GameTab:Button({
    Title = "Glass Bridge Fake Glass",
    Desc = "Create glass bridge cover",
    Callback = function()
        CreateGlassBridgeCover()
    end
})

GameTab:Button({
    Title = "Glass Esp",
    Desc = "Highlight glass bridge",
    Callback = function()
        local GlassHolder = workspace:WaitForChild("GlassBridge"):WaitForChild("GlassHolder")

        for i, v in pairs(GlassHolder:GetChildren()) do
            for g, j in pairs(v:GetChildren()) do
                if j:IsA("Model") and j.PrimaryPart then
                    local Color = j.PrimaryPart:GetAttribute("exploitingisevil") 
                        and Color3.fromRGB(248, 87, 87) 
                        or Color3.fromRGB(28, 235, 87)
                    j.PrimaryPart.Color = Color
                    j.PrimaryPart.Transparency = 0
                    j.PrimaryPart.Material = Enum.Material.Neon
                end
            end
        end
    end
})

local RebelBring = false
local guardConnection = nil

local function bringGuardsRebel()
    RebelBring = not RebelBring

    if RebelBring then
        local Players = game:GetService("Players")
        local localPlayer = Players.LocalPlayer

        -- Function to teleport a single guard
        local function teleportGuard(guard)
            local character = localPlayer.Character
            if not character then return end

            local rootPart = character:FindFirstChild("HumanoidRootPart")
            if not rootPart then return end

            local guardRoot = guard:FindFirstChild("HumanoidRootPart") or guard:FindFirstChild("Torso")

            if guardRoot and guardRoot:IsA("BasePart") then
                guardRoot.CFrame = rootPart.CFrame * CFrame.new(0, 0, -10)
            elseif guard:IsA("Model") then
                guard:MoveTo((rootPart.CFrame * CFrame.new(0, 0, -10)).Position)
            end
        end

        -- Teleport all existing guards
        local liveFolder = game.Workspace:FindFirstChild("Live")
        if liveFolder then
            for _, child in ipairs(liveFolder:GetChildren()) do
                if string.find(child.Name, "RebelGuard") then
                    teleportGuard(child)
                end
            end

            -- Monitor for new guards and auto-teleport them
            guardConnection = liveFolder.ChildAdded:Connect(function(child)
                if RebelBring and string.find(child.Name, "RebelGuard") then
                    task.wait(0.5)
                    teleportGuard(child)
                end
            end)

            print("RebelGuard auto-bring enabled")
        end
    else
        -- Disconnect the monitoring when disabled
        if guardConnection then
            guardConnection:Disconnect()
            guardConnection = nil
        end
        print("RebelGuard auto-bring disabled")
    end
end

local function aimbotRebelGuards()
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local localPlayer = Players.LocalPlayer
    local camera = workspace.CurrentCamera

    local aimbotConnection = nil
    local isAimbotActive = false

    return function(toggle)
        isAimbotActive = toggle

        if isAimbotActive then
            aimbotConnection = RunService.RenderStepped:Connect(function()
                if not isAimbotActive then return end

                local character = localPlayer.Character
                if not character then return end

                local rootPart = character:FindFirstChild("HumanoidRootPart")
                if not rootPart then return end

                local liveFolder = game.Workspace:FindFirstChild("Live")
                if not liveFolder then return end

                -- Find closest RebelGuard
                local closestGuard = nil
                local shortestDistance = math.huge

                for _, child in ipairs(liveFolder:GetChildren()) do
                    if string.find(child.Name, "RebelGuard") then
                        local guardHead = child:FindFirstChild("Head")
                        local guardHumanoid = child:FindFirstChild("Humanoid")

                        if guardHead and guardHumanoid and guardHumanoid.Health > 0 then
                            local distance = (rootPart.Position - guardHead.Position).Magnitude

                            if distance < shortestDistance then
                                shortestDistance = distance
                                closestGuard = guardHead
                            end
                        end
                    end
                end

                -- Aim at closest guard
                if closestGuard then
                    camera.CFrame = CFrame.new(camera.CFrame.Position, closestGuard.Position)
                end
            end)

            print("RebelGuard aimbot enabled")
        else
            if aimbotConnection then
                aimbotConnection:Disconnect()
                aimbotConnection = nil
            end
            print("RebelGuard aimbot disabled")
        end
    end
end

Window:Line()

GameTab:Section({Title = "Rebel"})

GameTab:Toggle({
    Title = "Bring Guards",
    Desc = "Bring rebel guards",
    Value = false,
    Callback = function(state)
        while true do
            task.wait()
            if state then
                bringGuardsRebel()
            else
                bringGuardsRebel()
            end
        end
    end
})

GameTab:Toggle({
    Title = "Aimbot Guards",
    Desc = "Aimbot rebel guards",
    Value = false,
    Callback = function(state)
        if state then
            aimbotRebelGuards(true)
        else
            aimbotRebelGuards(false)
        end
    end
})

Window:Line()

GameTab:Section({Title = "Mingle [coming soon]"})

GameTab:Button({
    Title = "Teleport To Room",
    Desc = "Teleport to mingle room",
    Callback = function()
        local char = localPlayer.Character
        char.HumanoidRootPart.CFrame = CFrame.new(1170.68262, 403.950592, -486.154968)
    end
})

Window:Line()

GameTab:Section({Title = "Final Sky squid Game[SKY SQUID]"})

GameTab:Button({
    Title = "Anti fall",
    Desc = "Anti fall protection",
    Callback = function()
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")

        local player = Players.LocalPlayer
        repeat task.wait() until player.Character and player.Character:FindFirstChild("HumanoidRootPart")
        local character = player.Character
        local rootPart = character:WaitForChild("HumanoidRootPart")
        local startingY = rootPart.Position.Y
        local fallLimit = startingY - 5
        local teleported = false

        RunService.RenderStepped:Connect(function()
            if not rootPart or not rootPart.Parent then return end
            if rootPart.Position.Y < fallLimit and not teleported then
                teleported = true
                local nearestPlayer
                local nearestDist = math.huge
                for _, other in ipairs(Players:GetPlayers()) do
                    if other ~= player and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
                        local hum = other.Character:FindFirstChild("Humanoid")
                        if hum and hum.Health > 0 then
                            local dist = (rootPart.Position - other.Character.HumanoidRootPart.Position).Magnitude
                            if dist < nearestDist then
                                nearestDist = dist
                                nearestPlayer = other
                            end
                        end
                    end
                end
                if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local targetRoot = nearestPlayer.Character.HumanoidRootPart
                    local direction = (rootPart.Position - targetRoot.Position).Unit
                    rootPart.CFrame = CFrame.new(targetRoot.Position + direction * 3)
                else
                    rootPart.CFrame = CFrame.new(rootPart.Position.X, startingY, rootPart.Position.Z)
                end
            end
            if rootPart.Position.Y >= startingY - 1 then
                teleported = false
            end
        end)
    end
})

-- Auto QTE for Specific Game (E,F,Q,R + Mobile)
GameTab:Toggle({
    Title = "Auto QTE universal",
    Desc = "Automatically complete E,F,Q,R QTEs for PC and Mobile",
    Value = false,
    Callback = function(state)
        local Players = game:GetService("Players")
        local RunService = game:GetService("RunService")
        local UserInputService = game:GetService("UserInputService")
        local VirtualInputManager = game:GetService("VirtualInputManager")
        local ReplicatedStorage = game:GetService("ReplicatedStorage")
        local player = Players.LocalPlayer
        local autoQTEConnection = nil
        
        local isMobile = UserInputService.TouchEnabled
        local lastQTE = 0
        local qteCooldown = 0.1
        
        -- Game-specific QTE detection
        local function detectGameQTEs()
            -- Method 1: Look for QTE GUI elements (from your images)
            local gui = player:FindFirstChild("PlayerGui")
            if gui then
                -- Look for specific QTE GUI names from your images
                local qteGUIs = {
                    "QTEGui", "GuiQTE", "ScreenGuiBotones", "FrameContenedorQTE",
                    "FrameQTE", "FramePermisosYMas", "TextButtonQTE"
                }
                
                for _, guiName in pairs(qteGUIs) do
                    local qteGui = gui:FindFirstChild(guiName, true)
                    if qteGui and qteGui.Visible then
                        return true
                    end
                end
                
                -- Look for QTE text (E, F, Q, R, TAP)
                local function searchForQTE(obj)
                    if obj:IsA("TextLabel") or obj:IsA("TextButton") then
                        local text = obj.Text:upper()
                        if text == "E" or text == "F" or text == "Q" or text == "R" or text == "TAP" then
                            if obj.Visible and obj.Size ~= UDim2.new(0, 0, 0, 0) then
                                return true
                            end
                        end
                    end
                    
                    for _, child in pairs(obj:GetChildren()) do
                        if searchForQTE(child) then
                            return true
                        end
                    end
                    return false
                end
                
                for _, screenGui in pairs(gui:GetChildren()) do
                    if screenGui:IsA("ScreenGui") and screenGui.Enabled then
                        if searchForQTE(screenGui) then
                            return true
                        end
                    end
                end
            end
            
            -- Method 2: Check QTE stats (from your leaderstats images)
            local character = player.Character
            if character then
                local leaderstats = character:FindFirstChild("leaderstats")
                if leaderstats then
                    local qteStats = leaderstats:FindFirstChild("QTEAvgPercent") or leaderstats:FindFirstChild("QTESuccesses")
                    if qteStats then
                        -- If QTE stats exist, there might be active QTEs
                        return true
                    end
                end
            end
            
            -- Method 3: Check ReplicatedStorage for QTE events (from your images)
            local qteConfig = ReplicatedStorage:FindFirstChild("QTEConfig")
            local qteSaveEvent = ReplicatedStorage:FindFirstChild("QTESaveEvent")
            local qteSession = ReplicatedStorage:FindFirstChild("QTESESSION")
            
            if qteConfig or qteSaveEvent or qteSession then
                -- QTE system is present in the game
                return true
            end
            
            return false
        end
        
        -- Function to press specific QTE keys (E, F, Q, R)
        local function pressQTEEFQR()
            if tick() - lastQTE < qteCooldown then
                return
            end
            
            lastQTE = tick()
            
            if isMobile then
                -- MOBILE: Simulate tap for E,F,Q,R buttons
                local gui = player:FindFirstChild("PlayerGui")
                if gui then
                    -- Look for specific QTE buttons to tap
                    local buttonsToTap = {"E", "F", "Q", "R", "TAP"}
                    
                    for _, buttonText in pairs(buttonsToTap) do
                        local function findButton(obj)
                            if obj:IsA("TextButton") and obj.Text:upper() == buttonText then
                                if obj.Visible and obj.Active then
                                    local absPos = obj.AbsolutePosition
                                    local absSize = obj.AbsoluteSize
                                    
                                    if absPos and absSize then
                                        local centerX = absPos.X + (absSize.X / 2)
                                        local centerY = absPos.Y + (absSize.Y / 2)
                                        
                                        -- Simulate tap on the button
                                        VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
                                        wait(0.05)
                                        VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
                                        
                                        Window:Notify({
                                            Title = "[AUTO QTE]",
                                            Desc = "Tapped: " .. buttonText,
                                            Time = 1
                                        })
                                        return true
                                    end
                                end
                            end
                            
                            for _, child in pairs(obj:GetChildren()) do
                                if findButton(child) then
                                    return true
                                end
                            end
                            return false
                        end
                        
                        for _, screenGui in pairs(gui:GetChildren()) do
                            if screenGui:IsA("ScreenGui") then
                                if findButton(screenGui) then
                                    return
                                end
                            end
                        end
                    end
                end
                
                -- Fallback: tap center screen
                local screenSize = workspace.CurrentCamera.ViewportSize
                VirtualInputManager:SendMouseButtonEvent(
                    screenSize.X / 2, 
                    screenSize.Y / 2, 
                    0, true, game, 1
                )
                wait(0.05)
                VirtualInputManager:SendMouseButtonEvent(
                    screenSize.X / 2, 
                    screenSize.Y / 2, 
                    0, false, game, 1
                )
                
                Window:Notify({
                    Title = "[AUTO QTE]",
                    Desc = "Mobile Tap (Fallback)",
                    Time = 1
                })
                
            else
                -- PC: Press E, F, Q, R keys in sequence (from your game config)
                local keysToPress = {
                    Enum.KeyCode.E,
                    Enum.KeyCode.F, 
                    Enum.KeyCode.Q,
                    Enum.KeyCode.R
                }
                
                local pressedKeys = {}
                
                for _, key in pairs(keysToPress) do
                    VirtualInputManager:SendKeyEvent(true, key, false, game)
                    wait(0.03)
                    VirtualInputManager:SendKeyEvent(false, key, false, game)
                    wait(0.05)
                    
                    table.insert(pressedKeys, key.Name)
                end
                
                Window:Notify({
                    Title = "[AUTO QTE]",
                    Desc = "Pressed: " .. table.concat(pressedKeys, ", "),
                    Time = 1
                })
            end
        end
        
        -- Handle timeout buffer (from your game config)
        local function handleTimeoutBuffer()
            -- Your game has timeout buffer of 0.25 seconds
            -- We need to be faster than this
            local timeoutBuffer = 0.25
            local reactionTime = 0.05 -- Our reaction time
            
            if reactionTime < timeoutBuffer then
                return true
            end
            return false
        end
        
        -- Main QTE detection loop optimized for your game
        local function gameQTECheck()
            if detectGameQTEs() then
                if handleTimeoutBuffer() then
                    pressQTEEFQR()
                end
            end
        end
        
        -- Toggle functionality
        if state then
            if isMobile then
                Window:Notify({
                    Title = "[AUTO QTE]",
                    Desc = "Mobile E,F,Q,R Auto-Tap Enabled",
                    Time = 4
                })
            else
                Window:Notify({
                    Title = "[AUTO QTE]",
                    Desc = "PC E,F,Q,R Auto-Press Enabled",
                    Time = 4
                })
            end
            
            if not autoQTEConnection then
                autoQTEConnection = RunService.Heartbeat:Connect(gameQTECheck)
            end
        else
            Window:Notify({
                Title = "[AUTO QTE]",
                Desc = "Disabled",
                Time = 3
            })
            if autoQTEConnection then
                autoQTEConnection:Disconnect()
                autoQTEConnection = nil
            end
        end
    end
})

Window:Line()

GameTab:Section({Title = "ALL"})

local AURAGAINER = false -- LOL U GUYS GOT NO AURA

GameTab:Toggle({
    Title = "Auto Win",
    Desc = "Auto win games",
    Value = false,
    Callback = function(state)
        local values = game.Workspace.Values
        local char = localPlayer.Character

        AURAGAINER = state

        while true do
            if AURAGAINER == true then
                task.wait(0.05) -- anti lag
                if values.CurrentGame.Value == "RedLightGreenLight" then
                    char.HumanoidRootPart.CFrame = CFrame.new(-46.0587921, 1025.23352, 108.6353122)
                elseif values.CurrentGame.Value == "Dalgona" then

                elseif values.CurrentGame.Value == "TugOfWar" then

                elseif values.CurrentGame.Value == "LightsOut" then
                    char.HumanoidRootPart.CFrame = CFrame.new(294.185852, 55.7636185, -3.9290698)
                elseif values.CurrentGame.Value == "HideAndSeek" then
                    if localPlayer.Backpack:FindFirstChild("Knife") or char:FindFirstChild("Knife") then
                        local Splayer = math.random(1, #Players)
                        local Selected = Players[Splayer]

                        while Selected.Backpack:FindFirstChild("Knife") or char:FindFirstChild("Knife") do
                            Splayer = math.random(1, #Players)
                            Selected = Players[Splayer]
                        end
                        performLoopkill(Splayer)
                    else
                        char.HumanoidRootPart.CFrame = CFrame.new(196.83342, 55.9547985, -90.4745865)
                    end
                elseif values.CurrentGame.Value == "JumpRope" then
                    char.HumanoidRootPart.CFrame = CFrame.new(720.896057, 198.628311, 921.170654)
                elseif values.CurrentGame.Value == "GlassBridge" then
                    char.HumanoidRootPart.CFrame = CFrame.new(-196.372467, 522.192139, -1534.20984)
                elseif values.CurrentGame.Value == "Mingle" then
                    char.HumanoidRootPart.CFrame = CFrame.new(1170.68262, 403.950592, -486.154968)
                elseif values.CurrentGame.Value == "SkySquidGame" then
                    char.HumanoidRootPart.CFrame = CFrame.new(2730.44263,1043.33435,800.130554)
                elseif values.CurrentGame.Value == "SquidGame" then

                end
            else
                task.wait(0.05)
            end
        end
    end
})

Window:Line()

GameTab:Section({Title = "Game Entrances"})

GameTab:Button({
    Title = "Dalgona Entrance",
    Desc = "Teleport to Dalgona entrance",
    Callback = function()
        local char = localPlayer.Character
        char.PrimaryPart.CFrame = CFrame.new(-222.226, 230.93, 406.97)
    end
})

GameTab:Button({
    Title = "HNS/TUG Entrance",
    Desc = "Teleport to HNS/TUG entrance",
    Callback = function()
        local char = localPlayer.Character
        char.PrimaryPart.CFrame = CFrame.new(-469.221, 245.556, 448.558)
    end
})

GameTab:Button({
    Title = "Jump Rope Entrance",
    Desc = "Teleport to Jump Rope entrance",
    Callback = function()
        local char = localPlayer.Character
        char.PrimaryPart.CFrame = CFrame.new(-435.823, 245.556, 504.708)
    end
})

GameTab:Button({
    Title = "Glass Bridge Entrance",
    Desc = "Teleport to Glass Bridge entrance",
    Callback = function()
        local char = localPlayer.Character
        char.PrimaryPart.CFrame = CFrame.new(-372.466, 259.659, 482.508)
    end
})

GameTab:Button({
    Title = "Mingle Entrance",
    Desc = "Teleport to Mingle entrance",
    Callback = function()
        local char = localPlayer.Character
        char.PrimaryPart.CFrame = CFrame.new(-382.445, 288.554, 436.898)
    end
})

GameTab:Button({
    Title = "Last Game Entrance",
    Desc = "Teleport to Last Game entrance",
    Callback = function()
        local char = localPlayer.Character
        char.PrimaryPart.CFrame = CFrame.new(-430.687, 251.535, 791.952)
    end
})

-- MISC TAB CONTENT
MiscTab:Section({Title = "TELEPORTS"})

MiscTab:Button({
    Title = "Teleport To Spawn",
    Desc = "Teleport to spawn",
    Callback = function()
        local char = localPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.HumanoidRootPart.CFrame = CFrame.new(196.83342, 55.9547985, -90.4745865)
        end
    end
})

MiscTab:Button({
    Title = "Teleport To Safe Spot",
    Desc = "Teleport to safe spot",
    Callback = function()
        local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
        if char and char:FindFirstChild("HumanoidRootPart") then
            char.HumanoidRootPart.CFrame = CFrame.new(179.030807, 57.9083214, 49.8269196)
        end
    end
})

Window:Line()

MiscTab:Section({Title = "SpamX TITLES"})

MiscTab:Button({
    Title = "[DAHEN HUB] Black Title",
    Desc = "Set black title",
    Callback = function()
        localPlayer:SetAttribute("_CurrentTitle", "Him")
        spawn(function()
            while task.wait() do
                localPlayer.Character.Torso.Player_Nametag.TitleText.Text = "[DAHEN SCRIPT]"
            end
        end)
    end
})

MiscTab:Button({
    Title = "[DAHEN HUB] Gold Title",
    Desc = "Set gold title",
    Callback = function()
        localPlayer:SetAttribute("_CurrentTitle", "Rich Millionaire")
        spawn(function()
            while task.wait() do
                localPlayer.Character.Torso.Player_Nametag.TitleText.Text = "[SpamX USER]"
            end
        end)
    end
})

MiscTab:Button({
    Title = "[DAHEN HUB] Purple Title",
    Desc = "Set purple title",
    Callback = function()
        localPlayer:SetAttribute("_CurrentTitle", "Tanos")
        spawn(function()
            while task.wait() do
                localPlayer.Character.Torso.Player_Nametag.TitleText.Text = "[SpamX USER]"
            end
        end)
    end
})

MiscTab:Button({
    Title = "[DAHEN HUB] Red Title",
    Desc = "Set red title",
    Callback = function()
        localPlayer:SetAttribute("_CurrentTitle", "The Chosen One")
        spawn(function()
            while task.wait() do
                localPlayer.Character.Torso.Player_Nametag.TitleText.Text = "[DAHEN SCRIPT ]"
            end
        end)
    end
})

Window:Line()

MiscTab:Section({Title = "ITEM TELEPORTS"})

MiscTab:Button({
    Title = "Teleport To Dropped Bandage",
    Desc = "Teleport to dropped bandage",
    Callback = function()
        local char = localPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            for i = 1, 10 do
                char.HumanoidRootPart.CFrame = game.Workspace.Effects:FindFirstChild("DroppedBandage").PrimaryPart.CFrame
                task.wait(0.125)
            end
        end
    end
})

MiscTab:Button({
    Title = "Teleport To Dropped Grenade",
    Desc = "Teleport to dropped grenade",
    Callback = function()
        local char = localPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            for i = 1, 10 do
                char.HumanoidRootPart.CFrame = game.Workspace.Effects:FindFirstChild("DroppedGrenade").PrimaryPart.CFrame
                task.wait(0.125)
            end
        end
    end
})

MiscTab:Button({
    Title = "Teleport To Dropped FlashBang",
    Desc = "Teleport to dropped flashbang",
    Callback = function()
        local char = localPlayer.Character
        if char and char:FindFirstChild("HumanoidRootPart") then
            for i = 1, 10 do
                char.HumanoidRootPart.CFrame = game.Workspace.Effects:FindFirstChild("DroppedFlashbang").PrimaryPart.CFrame
                task.wait(0.125)
            end
        end
    end
})

Window:Line()

local teleportEnabled = false
local teleportConnection = nil

-- Teleport to Dropped Bandage Toggle
MiscTab:Toggle({
    Title = "Auto Grab Dropped Bandage",
    Desc = "Auto grab dropped bandage",
    Value = false,
    Callback = function(state)
        teleportEnabled = state

        if teleportEnabled then
            -- Start the teleport loop
            teleportConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not teleportEnabled then return end

                local char = localPlayer.Character
                if char and char:FindFirstChild("HumanoidRootPart") then
                    local droppedBandage = game.Workspace.Effects:FindFirstChild("DroppedBandage")
                    if droppedBandage and droppedBandage.PrimaryPart then
                        char.HumanoidRootPart.CFrame = droppedBandage.PrimaryPart.CFrame
                    end
                end
            end)
        else
            -- Stop the teleport loop
            if teleportConnection then
                teleportConnection:Disconnect()
                teleportConnection = nil
            end
        end
    end
})

-- Teleport to Dropped Grenade Toggle
local grenadeEnabled = false
local grenadeConnection = nil

MiscTab:Toggle({
    Title = "Auto Grab Dropped Grenade",
    Desc = "Auto grab dropped grenade",
    Value = false,
    Callback = function(state)
        grenadeEnabled = state

        if grenadeEnabled then
            -- Start the teleport loop
            grenadeConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not grenadeEnabled then return end

                local char = localPlayer.Character
                if char and char:FindFirstChild("HumanoidRootPart") then
                    local droppedGrenade = game.Workspace.Effects:FindFirstChild("DroppedGrenade")
                    if droppedGrenade and droppedGrenade.PrimaryPart then
                        char.HumanoidRootPart.CFrame = droppedGrenade.PrimaryPart.CFrame
                    end
                end
            end)
        else
            -- Stop the teleport loop
            if grenadeConnection then
                grenadeConnection:Disconnect()
                grenadeConnection = nil
            end
        end
    end
})

-- Teleport to Dropped FlashBang Toggle
local flashbangEnabled = false
local flashbangConnection = nil

MiscTab:Toggle({
    Title = "Auto Grab Dropped FlashBang",
    Desc = "Auto grab dropped flashbang",
    Value = false,
    Callback = function(state)
        flashbangEnabled = state

        if flashbangEnabled then
            -- Start the teleport loop
            flashbangConnection = game:GetService("RunService").Heartbeat:Connect(function()
                if not flashbangEnabled then return end

                local char = localPlayer.Character
                if char and char:FindFirstChild("HumanoidRootPart") then
                    local droppedFlashbang = game.Workspace.Effects:FindFirstChild("DroppedFlashbang")
                    if droppedFlashbang and droppedFlashbang.PrimaryPart then
                        char.HumanoidRootPart.CFrame = droppedFlashbang.PrimaryPart.CFrame
                    end
                end
            end)
        else
            -- Stop the teleport loop
            if flashbangConnection then
                flashbangConnection:Disconnect()
                flashbangConnection = nil
            end
        end
    end
})

Window:Line()

MiscTab:Toggle({
    Title = "Enable Spectate",
    Desc = "Enable spectate mode",
    Value = false,
    Callback = function(state)
        game.Workspace.Values.CanSpectateIfWonGame.Value = state
    end
})

MiscTab:Textbox({
    Title = "Custom Player Number",
    Desc = "Put Tag Here",
    Placeholder = "Enter custom number",
    Value = "",
    ClearTextOnFocus = false,
    Callback = function(value)
        local char = localPlayer.Character
        local ui = localPlayer.PlayerGui.Leaderboard.Leaderboard.MainLeaderboard.Content:FindFirstChild(localPlayer.UserId)
        local Tags = char:FindFirstChild("PlayerTags")

        spawn(function()
            while true do
                task.wait()
                for i, tag in pairs(Tags:GetChildren()) do
                    tag.SurfaceGui.TextLabel.Text = value
                    ui.PlayerNumber.Text = "#"..value
                end
            end
        end)
    end
})

Window:Line()

MiscTab:Button({
    Title = "FPS Boost",
    Desc = "Boost FPS",
    Callback = function()
        -- Example FPS Booster Script
        local Lighting = game:GetService("Lighting")
        Lighting.GlobalShadows = false
        Lighting.FogEnd = 100000
        Lighting.Brightness = 1

        for _, v in pairs(workspace:GetDescendants()) do
            if v:IsA("BasePart") then
                v.Material = Enum.Material.SmoothPlastic
            end
        end
    end
})

-- Auto-refresh player list when players join/leave
Players.PlayerAdded:Connect(function()
    task.wait(1)
    -- Would need to refresh dropdown here
end)

Players.PlayerRemoving:Connect(function(player)
    if selectedPlayer == player then
        selectedPlayer = nil
    end
    -- Would need to refresh dropdown here
end)

-- Clean up speed boost and noclip on character respawn
localPlayer.CharacterAdded:Connect(function()
    speedBoostEnabled = false
    if speedConnection then
        speedConnection:Disconnect()
        speedConnection = nil
    end

    noclipEnabled = false
    if noclipConnection then
        noclipConnection:Disconnect()
        noclipConnection = nil
    end
end)

print("DAHEN HUB LOADED")