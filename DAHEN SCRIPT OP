local Library = loadstring(game:HttpGet("https://raw.githubusercontent.com/GoldDoomOwner/GoldField/refs/heads/main/SpazamX%20ui"))() -- loadstring(game:HttpGet("https://raw.githubusercontent.com/GoldDoomOwner/GoldField/refs/heads/main/GoldField%20Loader"))()
local RunService = game:GetService("RunService")
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local TextChatService = game:GetService("TextChatService")
local ToolModule = loadstring(game:HttpGet("https://raw.githubusercontent.com/GoldDoomOwner/Gold-Doom-Script/refs/heads/main/Tool%20Giver"))()
local UserInputService = game:GetService("UserInputService")

local Custom_PowerTools = {"Awaken", "Oblivious","Titanium", "Drug Abused", "Soul Monarch", "Creation", "AkazaDash", "ESPER RAGE", "GOLDEN MONARCH", "VOID WALKER", "STORM BREAKER", "CRIMSON REAPER", "CELESTIAL WRATH", "SHADOW ASSASSIN", "INFERNO KING", "FROZEN DOMAIN", "GRAVITY TITAN", "PLASMA SURGE", "TOXIC VENOM", "TIME WARP", "CRYSTAL FORTRESS", "BLOOD MOON", "DRAGON SPIRIT", "NEBULA VOID", "EARTH SHAKER", "WIND DANCER", "CHAOS BREAKER"}
-- game.Workspace.GlassBridge.GlassHuolder:GetChildren()
if localPlayer then
	-- Wait for TextChatService to be ready
	local textChannel = TextChatService:WaitForChild("TextChannels"):WaitForChild("RBXGeneral")

	textChannel:DisplaySystemMessage("[DAHEN HUB]: LOADING SCRIPT...")
	task.wait()
	textChannel:DisplaySystemMessage("[DAHEN HUB]: DAHEN HUB | INK GAMES")
	task.wait()
	textChannel:DisplaySystemMessage("[DAHEN HUB]: LOADED")
end

-- Create main window
local Window = Library:LoadWindow(
	"DAHEN HUB INK GAME: https://discord.gg/golddoom, https://discord.gg/ringta",  
	"DAHEN HUB TESTING | INK GAMES", 
	"1.2.0", 
	nil, 
	"DAHEN HUB | Ink Games", 
	"Disabled"
)

Library:Notify("Test", "Loading", 4, "Info")

-- Create tabs
local MainTab = Window:NewTab("Main")
local PlayerTab = Window:NewTab("Player")
local GameTab = Window:NewTab("Game")
local MiscTab = Window:NewTab("Misc")

-- Player Teleport System Variables
local selectedPlayer = nil

-- Function to get all players except local player
local function CreateGlassBridgeCover()
	local glassHolder = game.Workspace:FindFirstChild("GlassBridge")
	if not glassHolder then
		warn("GlassBridge not found in Workspace")
		return
	end

	glassHolder = glassHolder:FindFirstChild("GlassHolder")
	if not glassHolder then
		warn("GlassHolder not found in GlassBridge")
		return
	end

	local models = glassHolder:GetChildren()

	if #models == 0 then
		warn("No models found in GlassHolder")
		return
	end

	-- Calculate the bounding box that encompasses all models
	local minX, minY, minZ = math.huge, math.huge, math.huge
	local maxX, maxY, maxZ = -math.huge, -math.huge, -math.huge

	for _, model in ipairs(models) do
		if model:IsA("Model") or model:IsA("BasePart") then
			local cframe, size

			if model:IsA("Model") then
				cframe, size = model:GetBoundingBox()
			else
				cframe = model.CFrame
				size = model.Size
			end

			-- Calculate the corners of this model's bounding box
			local halfSize = size / 2
			local corners = {
				cframe * CFrame.new(-halfSize.X, -halfSize.Y, -halfSize.Z),
				cframe * CFrame.new(halfSize.X, -halfSize.Y, -halfSize.Z),
				cframe * CFrame.new(-halfSize.X, halfSize.Y, -halfSize.Z),
				cframe * CFrame.new(halfSize.X, halfSize.Y, -halfSize.Z),
				cframe * CFrame.new(-halfSize.X, -halfSize.Y, halfSize.Z),
				cframe * CFrame.new(halfSize.X, -halfSize.Y, halfSize.Z),
				cframe * CFrame.new(-halfSize.X, halfSize.Y, halfSize.Z),
				cframe * CFrame.new(halfSize.X, halfSize.Y, halfSize.Z),
			}

			-- Find min and max positions
			for _, corner in ipairs(corners) do
				local pos = corner.Position
				minX = math.min(minX, pos.X)
				minY = math.min(minY, pos.Y)
				minZ = math.min(minZ, pos.Z)
				maxX = math.max(maxX, pos.X)
				maxY = math.max(maxY, pos.Y)
				maxZ = math.max(maxZ, pos.Z)
			end
		end
	end

	-- Create the covering part
	local coverPart = Instance.new("Part")
	coverPart.Name = "GlassBridgeCover"
	coverPart.Anchored = true
	coverPart.CanCollide = true
	coverPart.Material = Enum.Material.SmoothPlastic
	coverPart.Color = Color3.fromRGB(100, 100, 255)
	coverPart.Transparency = 0.3

	-- Calculate size and position
	local sizeX = maxX - minX + 2 -- Add 2 studs padding
	local sizeY = maxY - minY + 2
	local sizeZ = maxZ - minZ + 2

	local centerX = (minX + maxX) / 2
	local centerY = (minY + maxY) / 2
	local centerZ = (minZ + maxZ) / 2

	coverPart.Size = Vector3.new(sizeX, sizeY, sizeZ)
	coverPart.CFrame = CFrame.new(centerX, centerY, centerZ)
	coverPart.Parent = workspace

	print("Glass Bridge Cover created!")
	print("Size:", coverPart.Size)
	print("Position:", coverPart.Position)

	return coverPart
end

local function getPlayerList()
	local playerList = {}
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= localPlayer then
			table.insert(playerList, player.DisplayName)
		end
	end
	return #playerList > 0 and playerList or {"No Players"}
end

-- Function to get player by display name
local function getPlayerByDisplayName(displayName)
	for _, player in pairs(Players:GetPlayers()) do
		if player.DisplayName == displayName then
			return player
		end
	end
	return nil
end

-- Function to teleport to selected player
local function teleportToPlayer(targetPlayer)
	if not targetPlayer or not targetPlayer.Character then
		return
	end

	local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
	local localRoot = localPlayer.Character and localPlayer.Character:FindFirstChild("HumanoidRootPart")

	if targetRoot and localRoot then
		localRoot.CFrame = targetRoot.CFrame * CFrame.new(0, 0, 3)
	end
end

-- Function to teleport to random player
local function teleportToRandomPlayer()
	local players = {}
	for _, player in pairs(Players:GetPlayers()) do
		if player ~= localPlayer and player.Character then
			table.insert(players, player)
		end
	end

	if #players > 0 then
		local randomPlayer = players[math.random(1, #players)]
		teleportToPlayer(randomPlayer)
	end
end

MainTab:NewButton("Custom Emotes", function()
	loadstring(game:HttpGet("https://pastebin.com/raw/1p6xnBNf"))()
	loadstring(game:HttpGet("https://raw.githubusercontent.com/GoldDoomOwner/Gold-Doom-Script/refs/heads/main/jerk"))()
end)

MainTab:NewButton("Custom Emotes 2", function()
	-- Feel free to modify, contact pystyt on discord if u want to show me the modifications you did to the script, thanks alot
	-- Detect R6 or R15
	local player = game.Players.LocalPlayer
	local character = player.Character or player.CharacterAdded:Wait()
	local isR6 = character:FindFirstChild("Torso") ~= nil

	-- Notification Function
	local function showNotification(message)
		local notificationGui = Instance.new("ScreenGui")
		notificationGui.Name = "NotificationGui"
		notificationGui.Parent = game.CoreGui

		local notificationFrame = Instance.new("Frame")
		notificationFrame.Size = UDim2.new(0, 300, 0, 50)
		notificationFrame.Position = UDim2.new(0.5, -150, 1, -60)
		notificationFrame.AnchorPoint = Vector2.new(0.5, 1)
		notificationFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
		notificationFrame.BorderSizePixel = 0
		notificationFrame.Parent = notificationGui

		local uicorner = Instance.new("UICorner")
		uicorner.CornerRadius = UDim.new(0, 10)
		uicorner.Parent = notificationFrame

		local textLabel = Instance.new("TextLabel")
		textLabel.Size = UDim2.new(1, -20, 1, 0)
		textLabel.Position = UDim2.new(0, 10, 0, 0)
		textLabel.BackgroundTransparency = 1
		textLabel.Text = message .. " | by nikos_YT7"
		textLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
		textLabel.Font = Enum.Font.SourceSansSemibold
		textLabel.TextSize = 18
		textLabel.TextXAlignment = Enum.TextXAlignment.Left
		textLabel.Parent = notificationFrame

		notificationFrame.BackgroundTransparency = 1
		textLabel.TextTransparency = 1

		game:GetService("TweenService"):Create(
			notificationFrame,
			TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.Out),
			{BackgroundTransparency = 0}
		):Play()

		game:GetService("TweenService"):Create(
			textLabel,
			TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.Out),
			{TextTransparency = 0}
		):Play()

		task.delay(5, function()
			game:GetService("TweenService"):Create(
				notificationFrame,
				TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.In),
				{BackgroundTransparency = 1}
			):Play()

			game:GetService("TweenService"):Create(
				textLabel,
				TweenInfo.new(0.5, Enum.EasingStyle.Quint, Enum.EasingDirection.In),
				{TextTransparency = 1}
			):Play()

			task.delay(0.5, function()
				notificationGui:Destroy()
			end)
		end)
	end

	-- Show notification based on rig type
	if isR6 then
		showNotification("R6 detected")
	else
		showNotification("R15 detected")
	end

	-- Create Screen GUI
	local gui = Instance.new("ScreenGui")
	gui.Name = "BangGui"
	gui.Parent = game.CoreGui

	-- Main Frame
	local mainFrame = Instance.new("Frame")
	mainFrame.Size = UDim2.new(0, 300, 0, 300)
	mainFrame.AnchorPoint = Vector2.new(0.5, 0.5)
	mainFrame.Position = UDim2.new(0.5, 0, 0.5, 0)
	mainFrame.BackgroundColor3 = Color3.fromRGB(40, 40, 40)
	mainFrame.BorderSizePixel = 0
	mainFrame.Parent = gui

	local uicorner = Instance.new("UICorner")
	uicorner.CornerRadius = UDim.new(0, 20)
	uicorner.Parent = mainFrame

	-- Title
	local title = Instance.new("TextLabel")
	title.Size = UDim2.new(1, -60, 0, 30)
	title.Position = UDim2.new(0, 10, 0, 0)
	title.BackgroundTransparency = 1
	title.Text = "Choose"
	title.TextColor3 = Color3.fromRGB(255, 255, 255)
	title.Font = Enum.Font.SourceSansSemibold
	title.TextSize = 24
	title.TextXAlignment = Enum.TextXAlignment.Left
	title.Parent = mainFrame

    -- Dahen Hub Minimize/Restore System (Fixed)
local minimized = false

-- Main Dahen Hub restore button (appears when minimized)
local restoreBtn = Instance.new("TextButton")
restoreBtn.Size = UDim2.new(0, 120, 0, 36)
restoreBtn.Position = UDim2.new(0, 12, 0, 12)
restoreBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
restoreBtn.Text = "Dahen Hub"
restoreBtn.Font = Enum.Font.SourceSansBold
restoreBtn.TextSize = 18
restoreBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
restoreBtn.Visible = false
restoreBtn.Parent = screenGui

Instance.new("UICorner", restoreBtn).CornerRadius = UDim.new(0, 8)

-- Existing minimize button setup
local miniBtn = Instance.new("TextButton")
miniBtn.Size = UDim2.new(0, 36, 0, 36)
miniBtn.Position = UDim2.new(1, -76, 0, 12)
miniBtn.BackgroundColor3 = Color3.fromRGB(255, 215, 0)
miniBtn.Text = "-"
miniBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
miniBtn.TextScaled = true
miniBtn.Parent = mainFrame

Instance.new("UICorner", miniBtn).CornerRadius = UDim.new(0, 8)

-- Minimize behavior
miniBtn.MouseButton1Click:Connect(function()
	if minimized then return end
	minimized = true

	-- Tween out smoothly
	mainFrame:TweenSize(UDim2.new(0, 300, 0, 0), Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.3, true, function()
		mainFrame.Visible = false
		restoreBtn.Visible = true
	end)
end)

-- Restore behavior
restoreBtn.MouseButton1Click:Connect(function()
	if not minimized then return end
	minimized = false

	restoreBtn.Visible = false
	mainFrame.Visible = true

	-- Tween back to normal size
	mainFrame:TweenSize(UDim2.new(0, 300, 0, 300), Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.3, true)
end)

	-- Close Button
	local closeButton = Instance.new("TextButton")
	closeButton.Size = UDim2.new(0, 30, 0, 30)
	closeButton.Position = UDim2.new(1, -40, 0, 0)
	closeButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
	closeButton.Text = "X"
	closeButton.Font = Enum.Font.SourceSansBold
	closeButton.TextSize = 20
	closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
	closeButton.Parent = mainFrame

	local closeCorner = Instance.new("UICorner")
	closeCorner.CornerRadius = UDim.new(0, 10)
	closeCorner.Parent = closeButton

	closeButton.MouseButton1Click:Connect(function()
		gui:Destroy()
	end)

-- Dahen Hub Minimize/Restore System

-- MainFrame, minimizeButton, and closeButton should already exist
local player = game.Players.LocalPlayer
local gui = player:WaitForChild("PlayerGui")

-- Create the Dahen Hub restore button
local restoreButton = Instance.new("TextButton")
restoreButton.Name = "RestoreButton"
restoreButton.Text = "Dahen Hub"
restoreButton.Font = Enum.Font.SourceSansBold
restoreButton.TextSize = 20
restoreButton.TextColor3 = Color3.fromRGB(255, 255, 255)
restoreButton.BackgroundColor3 = Color3.fromRGB(25, 25, 25)
restoreButton.Size = UDim2.new(0, 150, 0, 40)
restoreButton.Position = UDim2.new(0.5, -75, 0, 10) -- top center
restoreButton.Visible = false
restoreButton.Parent = gui

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 10)
corner.Parent = restoreButton

local minimized = false

minimizeButton.MouseButton1Click:Connect(function()
	minimized = true
	mainFrame.Visible = false
	restoreButton.Visible = true
end)

restoreButton.MouseButton1Click:Connect(function()
	minimized = false
	mainFrame.Visible = true
	restoreButton.Visible = false
end)

closeButton.MouseButton1Click:Connect(function()
	mainFrame.Visible = false
	restoreButton.Visible = false
end)

-- optional: close button behavior (keeps it visible and reliable)
closeButton.MouseButton1Click:Connect(function()
    mainFrame.Visible = false
end)

-- Example Content
local content = Instance.new("Frame")
content.Size = UDim2.new(1, 0, 1, -30)
content.Position = UDim2.new(0, 0, 0, 30)
content.BackgroundColor3 = Color3.fromRGB(55, 55, 55)
content.Parent = mainFrame

local label = Instance.new("TextLabel")
label.Size = UDim2.new(1, 0, 0, 40)
label.Position = UDim2.new(0, 0, 0, 10)
label.BackgroundTransparency = 1
label.Text = "Welcome to Dahen Hub!"
label.Font = Enum.Font.SourceSansBold
label.TextSize = 22
label.TextColor3 = Color3.fromRGB(255, 255, 255)
label.Parent = content

-- Fixed Minimize Function (Shrink Only)
local minimized = false
local fullSize = UDim2.new(0, 300, 0, 300)
local minimizedSize = UDim2.new(0, 300, 0, 30)

minimizeButton.MouseButton1Click:Connect(function()
	minimized = not minimized

	if minimized then
		content.Visible = false
		mainFrame:TweenSize(minimizedSize, Enum.EasingDirection.In, Enum.EasingStyle.Quint, 0.4, true)
	else
		mainFrame:TweenSize(fullSize, Enum.EasingDirection.Out, Enum.EasingStyle.Quint, 0.4, true)
		task.wait(0.4)
		content.Visible = true
	end
end)

	-- Dragging Functionality
	local dragging, dragStart, startPos
	mainFrame.InputBegan:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = true
			dragStart = input.Position
			startPos = mainFrame.Position
		end
	end)

	mainFrame.InputChanged:Connect(function(input)
		if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
			local delta = input.Position - dragStart
			mainFrame.Position = UDim2.new(
				startPos.X.Scale,
				startPos.X.Offset + delta.X,
				startPos.Y.Scale,
				startPos.Y.Offset + delta.Y
			)
		end
	end)

	mainFrame.InputEnded:Connect(function(input)
		if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
			dragging = false
		end
	end)

	-- Scrolling Frame
	local scrollingFrame = Instance.new("ScrollingFrame")
	scrollingFrame.Size = UDim2.new(1, -20, 1, -50)
	scrollingFrame.Position = UDim2.new(0, 10, 0, 40)
	scrollingFrame.BackgroundTransparency = 1
	scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 300)
	scrollingFrame.ScrollBarThickness = 6
	scrollingFrame.Parent = mainFrame

	local layout = Instance.new("UIListLayout")
	layout.Padding = UDim.new(0, 10)
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.Parent = scrollingFrame

	-- Buttons Data
	local buttons = {
		{name = "Bang V2", r6 = "https://pastebin.com/raw/aPSHMV6K", r15 = "https://pastebin.com/raw/1ePMTt9n"},
		{name = "Get Banged", r6 = "https://pastebin.com/raw/zHbw7ND1", r15 = "https://pastebin.com/raw/7hvcjDnW"},
		{name = "Suck", r6 = "https://pastebin.com/raw/SymCfnAW", r15 = "https://pastebin.com/raw/p8yxRfr4"},
		{name = "Get Suc", r6 = "https://pastebin.com/raw/FPu4e2Qh", r15 = "https://pastebin.com/raw/DyPP2tAF"},
	}

	for _, buttonData in pairs(buttons) do
		local button = Instance.new("TextButton")
		button.Size = UDim2.new(0.8, 0, 0, 40)
		button.BackgroundColor3 = Color3.fromRGB(50, 150, 255)
		button.Text = buttonData.name
		button.Font = Enum.Font.SourceSansBold
		button.TextSize = 20
		button.TextColor3 = Color3.fromRGB(255, 255, 255)
		button.Parent = scrollingFrame

		local uicorner = Instance.new("UICorner")
		uicorner.CornerRadius = UDim.new(0, 10)
		uicorner.Parent = button

		button.MouseButton1Click:Connect(function()
			if isR6 then
				loadstring(game:HttpGet(buttonData.r6))()
			else
				loadstring(game:HttpGet(buttonData.r15))()
			end
		end)
	end
end)

GameTab:NewDivider()


-- Create first dropdown for tool selection
local selectedTool1 = "Awaken"
local toolDropdown1 = MainTab:NewDropdown(
	"Select Tool 1",
	Custom_PowerTools,
	"Awaken",
	function(selected)
		selectedTool1 = selected
		print("Selected tool 1:", selectedTool1)
	end
)

-- Create second dropdown for tool selection
local selectedTool2 = "Oblivious"
local toolDropdown2 = MainTab:NewDropdown(
	"Select Tool 2",
	Custom_PowerTools,
	"Oblivious",
	function(selected)
		selectedTool2 = selected
		print("Selected tool 2:", selectedTool2)
	end
)

-- Create text input for custom name
local customNameInput = MainTab:NewTextInput(
	"Custom Powers Name",
	"Enter custom name...",
	function(text)
		print("Custom name entered:", text)
	end
)

-- Create button to get tools and change shop UI text
local getToolButton = MainTab:NewButton(
	"Equip Custom Power",
	function()
		-- Get both tools using ToolModule
		ToolModule:GetTools(selectedTool1, selectedTool2)

		-- Get the custom name from the text input
		local customName = customNameInput.GetText()

		-- Change the shop UI text
		local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Powers
		spawn(function()
			while true do
				ui.CurrentlyEquipped.Text = "Currently Equipped: " .. (customName or "")
				task.wait()
			end
		end)
	end)

MainTab:NewDivider()

MainTab:NewButton("Enable Dash", function()
	localPlayer.Boosts["Faster Sprint"].Value = 5
	local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Boosts
	local Speed = ui["Faster Sprint"]

	spawn(function()
		while true do
			task.wait()
			Speed.BuyButtonRobux.Visible = false
			Speed.BuyButtonCoin.Visible = false
			Speed.ItemLevel.Text = "Current Level (5)"
		end
	end)
end)

MainTab:NewButton("Won Boost", function()
	localPlayer.Boosts["Won Boost"].Value = 5
	local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Boosts
	local Speed = ui["Won Boost"]

	spawn(function()
		while true do
			task.wait()
			Speed.BuyButtonRobux.Visible = false
			Speed.BuyButtonCoin.Visible = false
			Speed.ItemLevel.Text = "Current Level (5)"
		end
	end)
end)

MainTab:NewButton("Strength Boost", function()
	localPlayer.Boosts["Damage Boost"].Value = 5
	local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Boosts
	local Speed = ui["Damage Boost"]

	spawn(function()
		while true do
			task.wait()
			Speed.BuyButtonRobux.Visible = false
			Speed.BuyButtonCoin.Visible = false
			Speed.ItemLevel.Text = "Current Level (5)"
		end
	end)
end)

MainTab:NewButton("Equip Phantom Step", function()
	localPlayer:SetAttribute("_EquippedPower", "PHANTOM STEP")
end)

MainTab:NewButton("Remove Power", function()
	localPlayer:SetAttribute("_EquippedPower", "")
end)

MainTab:NewButton("Enable Powers", function()
	game.Workspace.Values.PowersDisabled.Value = false
end)

MainTab:NewDivider()

MainTab:NewButton("Enable All Gamepasses", function()
	Library:Notify("Enabling All Gamepasses", "Loading Script", 4, "Info")
	localPlayer:SetAttribute("HasLighter", true)
	localPlayer:SetAttribute("HasPush", true)
	game.Workspace.Values.CanPush.Value = true
	local ui = localPlayer.PlayerGui.ShopGui.StoreHolder.Store.PAGES.Gamepass
	game.Workspace.Values.CanPush.Value = true

	for i, v in pairs(ui:GetChildren()) do
		if v:IsA("TextButton") then
			spawn(function()
				if v.ItemName.Text == "Revive All" or v.ItemName.Text == "One Time Playable Guard" then
					print("["..v.ItemName.Text.."] Has Been Blocked")
					Library:Notify(v.ItemName.Text, "Blocked To Look Legit", 4, "Info")
				else
					v.BuyButton.Content.TextLabel.Text = "OWNED"
					Library:Notify(v.ItemName.Text, "Giving Gamepass", 4, "Info")
					print("Done ["..v.ItemName.Text.."]")
				end
			end)
		end
	end
end)

MainTab:NewButton("Select Fork", function()
	localPlayer:SetAttribute("WeaponSelected", "Fork")
end)

MainTab:NewButton("Show All Buttons", function()
	local ui = localPlayer.PlayerGui.Buttons.LeftButtons

	for i, v in pairs(ui:GetChildren()) do
		if v:IsA("ImageButton") then
			v.Visible = true
		end
	end
end)

-- PLAYER TAB CONTENT
PlayerTab:NewText("=== PLAYER TELEPORTS ===")

-- Create player dropdown
local playerOptions = getPlayerList()
local playerDropdown = PlayerTab:NewDropdown("Player Selector", playerOptions, playerOptions[1], function(selectedName)
	selectedPlayer = getPlayerByDisplayName(selectedName)
end)

PlayerTab:NewButton("Refresh Players", function()
	-- Note: GoldField dropdown refresh would need to be implemented in the library
	print("Player list refreshed")
end)

PlayerTab:NewButton("Teleport To Selected Player", function()
	if selectedPlayer then
		teleportToPlayer(selectedPlayer)
	else
		print("No player selected!")
	end
end)

local goatersa = false

PlayerTab:NewToggle("Attach to player", false, function(state)
	if selectedPlayer then
		goatersa = state
		spawn(function()
			while true do
				if goatersa == true then
					teleportToPlayer(selectedPlayer)
				else
					-- ignore
				end
				task.wait(0.1) -- for preformance without there will be lag
			end
		end)
	else
		print("No player selected!")
	end
end)


PlayerTab:NewButton("Teleport To Random Player", function()
	teleportToRandomPlayer()
end)

PlayerTab:NewDivider()

PlayerTab:NewButton("Hitbox multiplier", function()
	if game.Workspace.Values.HitboxMultiplier.Value == 50 then
		Library:Notify("[HITBOX]", "is 1x", 4, "Info")
		game.Workspace.Values.HitboxMultiplier.Value = 1
	else
		Library:Notify("[HITBOX]", "is 50x", 4, "Info")
		game.Workspace.Values.HitboxMultiplier.Value = 50
	end
end)

-- HITBOX EXPANDER - Extended Attack Range with Visuals
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Hitbox Expander variables
local isHitboxExpanderActive = false
local expandedHitboxes = {}
local visualHitboxes = {}
local hitboxSize = 15
local hitboxRange = 30
local attackCooldown = 0.2
local lastAttackTime = 0

-- Add toggle to PlayerTab
PlayerTab:NewToggle("Hitbox Expander", "Extend attack range with invisible hitboxes", function(state)
    isHitboxExpanderActive = state
    
    if state then
        createExpandedHitboxes()
    else
        removeExpandedHitboxes()
    end
end)

-- Range input
PlayerTab:NewTextInput("Hitbox Range", "Set hitbox range (1-100)", "30", function(text)
    local newRange = tonumber(text)
    if newRange and newRange >= 1 and newRange <= 100 then
        hitboxRange = newRange
        if isHitboxExpanderActive then
            removeExpandedHitboxes()
            createExpandedHitboxes()
        end
        Library:Notify("HITBOX EXPANDER", "Range set to: " .. hitboxRange .. " studs", 3)
    else
        Library:Notify("HITBOX EXPANDER", "Invalid range! Use 1-100", 3)
    end
end)

-- Create expanded hitboxes around player
local function createExpandedHitboxes()
    removeExpandedHitboxes()
    
    local character = localPlayer.Character
    if not character then return end
    
    -- Create hitboxes in all directions
    local hitboxPositions = {
        Vector3.new(0, 0, hitboxRange),  -- Front
        Vector3.new(hitboxRange, 0, 0),  -- Right
        Vector3.new(-hitboxRange, 0, 0), -- Left
        Vector3.new(0, 0, -hitboxRange), -- Back
        Vector3.new(0, hitboxRange, 0),  -- Top
    }
    
    for i, offset in ipairs(hitboxPositions) do
        local hitbox = createSingleHitbox(character, offset, "Hitbox_" .. i)
        table.insert(expandedHitboxes, hitbox)
        
        -- Create visual indicator
        local visual = createVisualHitbox(character, offset, "Visual_" .. i)
        table.insert(visualHitboxes, visual)
    end
    
    -- Create rotating sphere for 360 coverage
    local sphereHitbox = createSphereHitbox(character)
    table.insert(expandedHitboxes, sphereHitbox)
    
    -- Create visual for rotating sphere
    local sphereVisual = createSphereVisual(character)
    table.insert(visualHitboxes, sphereVisual)
end

-- Create a single hitbox part
local function createSingleHitbox(character, offset, name)
    local hitbox = Instance.new("Part")
    hitbox.Name = name
    hitbox.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    hitbox.Transparency = 1
    hitbox.CanCollide = false
    hitbox.Anchored = false
    hitbox.Massless = true
    
    -- Create TouchTransmitter
    local touchInterest = Instance.new("TouchTransmitter")
    touchInterest.Parent = hitbox
    
    -- Weld to character
    local weld = Instance.new("Weld")
    weld.Part0 = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head") or character.PrimaryPart
    weld.Part1 = hitbox
    weld.C0 = CFrame.new(offset)
    weld.Parent = hitbox
    
    hitbox.Parent = character
    
    -- Connect touched event
    hitbox.Touched:Connect(function(otherPart)
        onHitboxTouched(otherPart)
    end)
    
    return hitbox
end

-- Create visual indicator for hitbox
local function createVisualHitbox(character, offset, name)
    local visual = Instance.new("Part")
    visual.Name = name
    visual.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    visual.Material = Enum.Material.Neon
    visual.BrickColor = BrickColor.new("Bright red")
    visual.Transparency = 0.7
    visual.CanCollide = false
    visual.Anchored = false
    visual.Massless = true
    
    -- Weld to character
    local weld = Instance.new("Weld")
    weld.Part0 = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head") or character.PrimaryPart
    weld.Part1 = visual
    weld.C0 = CFrame.new(offset)
    weld.Parent = visual
    
    visual.Parent = character
    
    return visual
end

-- Create sphere hitbox that rotates around player
local function createSphereHitbox(character)
    local sphere = Instance.new("Part")
    sphere.Name = "RotatingSphereHitbox"
    sphere.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    sphere.Transparency = 1
    sphere.CanCollide = false
    sphere.Anchored = false
    sphere.Massless = true
    
    -- Create TouchTransmitter
    local touchInterest = Instance.new("TouchTransmitter")
    touchInterest.Parent = sphere
    
    -- Weld with rotation
    local weld = Instance.new("Weld")
    weld.Part0 = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head") or character.PrimaryPart
    weld.Part1 = sphere
    weld.Parent = sphere
    
    sphere.Parent = character
    
    -- Connect touched event
    sphere.Touched:Connect(function(otherPart)
        onHitboxTouched(otherPart)
    end)
    
    -- Make it rotate
    if isHitboxExpanderActive then
        coroutine.wrap(function()
            local angle = 0
            while isHitboxExpanderActive and sphere and sphere.Parent do
                angle = angle + 0.1
                local x = math.cos(angle) * hitboxRange
                local z = math.sin(angle) * hitboxRange
                weld.C0 = CFrame.new(x, 0, z)
                RunService.Heartbeat:Wait()
            end
        end)()
    end
    
    return sphere
end

-- Create visual for rotating sphere
local function createSphereVisual(character)
    local visual = Instance.new("Part")
    visual.Name = "RotatingSphereVisual"
    visual.Size = Vector3.new(hitboxSize, hitboxSize, hitboxSize)
    visual.Material = Enum.Material.Neon
    visual.BrickColor = BrickColor.new("Bright blue")
    visual.Transparency = 0.7
    visual.CanCollide = false
    visual.Anchored = false
    visual.Massless = true
    
    -- Weld with rotation
    local weld = Instance.new("Weld")
    weld.Part0 = character:FindFirstChild("HumanoidRootPart") or character:FindFirstChild("Head") or character.PrimaryPart
    weld.Part1 = visual
    weld.Parent = visual
    
    visual.Parent = character
    
    -- Make it rotate
    if isHitboxExpanderActive then
        coroutine.wrap(function()
            local angle = 0
            while isHitboxExpanderActive and visual and visual.Parent do
                angle = angle + 0.1
                local x = math.cos(angle) * hitboxRange
                local z = math.sin(angle) * hitboxRange
                weld.C0 = CFrame.new(x, 0, z)
                RunService.Heartbeat:Wait()
            end
        end)()
    end
    
    return visual
end

-- Handle when hitbox touches something
local function onHitboxTouched(otherPart)
    if not isHitboxExpanderActive then return end
    
    local currentTime = tick()
    if currentTime - lastAttackTime < attackCooldown then return end
    
    -- Check if touched part belongs to a player
    local touchedPlayer = getPlayerFromPart(otherPart)
    if touchedPlayer and touchedPlayer ~= localPlayer then
        -- Check if player is alive
        local character = touchedPlayer.Character
        if character then
            local humanoid = character:FindFirstChildOfClass("Humanoid")
            if humanoid and humanoid.Health > 0 then
                -- Perform attack
                performAttack()
                lastAttackTime = currentTime
                
                -- Flash the hitbox that was touched
                flashHitboxVisual(otherPart)
            end
        end
    end
end

-- Flash hitbox visual when it hits something
local function flashHitboxVisual(touchedPart)
    for _, visual in pairs(visualHitboxes) do
        if visual and visual.Parent then
            local originalColor = visual.BrickColor
            visual.BrickColor = BrickColor.new("Bright green")
            
            -- Reset color after short delay
            delay(0.2, function()
                if visual and visual.Parent then
                    if visual.Name == "RotatingSphereVisual" then
                        visual.BrickColor = BrickColor.new("Bright blue")
                    else
                        visual.BrickColor = BrickColor.new("Bright red")
                    end
                end
            end)
        end
    end
end

-- Get player from touched part
local function getPlayerFromPart(part)
    local character = part:FindFirstAncestorOfClass("Model")
    if character then
        return Players:GetPlayerFromCharacter(character)
    end
    return nil
end

-- Perform attack (mobile-friendly)
local function performAttack()
    local currentTime = tick()
    if currentTime - lastAttackTime >= attackCooldown then
        -- Use screen tap for mobile compatibility
        local screenCenter = Vector2.new(workspace.CurrentCamera.ViewportSize.X / 2, workspace.CurrentCamera.ViewportSize.Y / 2)
        
        VirtualInputManager:SendTouchEvent(0, screenCenter, Enum.TouchState.Began, nil, 0, 0)
        task.wait(0.05)
        VirtualInputManager:SendTouchEvent(0, screenCenter, Enum.TouchState.Ended, nil, 0, 0)
        
        lastAttackTime = currentTime
    end
end

-- Remove all expanded hitboxes
local function removeExpandedHitboxes()
    for _, hitbox in pairs(expandedHitboxes) do
        if hitbox and hitbox.Parent then
            hitbox:Destroy()
        end
    end
    expandedHitboxes = {}
    
    for _, visual in pairs(visualHitboxes) do
        if visual and visual.Parent then
            visual:Destroy()
        end
    end
    visualHitboxes = {}
end

-- Handle character respawning
localPlayer.CharacterAdded:Connect(function(character)
    if isHitboxExpanderActive then
        task.wait(1)
        createExpandedHitboxes()
    end
end)

-- Clean up when character is removed
localPlayer.CharacterRemoving:Connect(function()
    removeExpandedHitboxes()
end)

-- Status button to show current range
PlayerTab:NewButton("Hitbox Status", "Show current hitbox range", function()
    Library:Notify("HITBOX EXPANDER", "Current range: " .. hitboxRange .. " studs", 4)
end)

PlayerTab:NewToggle("Infinite Jump", false, function(value)
	infiniteJumpEnabled = value

	if infiniteJumpEnabled then
		-- Connect to UserInputService to detect jump input
		local UserInputService = game:GetService("UserInputService")

		jumpConnection = game:GetService("UserInputService").JumpRequest:Connect(function()
			local character = localPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				end
			end
		end)
	else
		-- Disable infinite jump
		if jumpConnection then
			jumpConnection:Disconnect()
			jumpConnection = nil
		end
	end
end)

-- Noclip Toggle
local noclipEnabled = false
local noclipConnection = nil

PlayerTab:NewToggle("Noclip", false, function(state)
	noclipEnabled = state

	if noclipEnabled then
		noclipConnection = RunService.Stepped:Connect(function()
			if localPlayer.Character then
				for _, part in pairs(localPlayer.Character:GetDescendants()) do
					if part:IsA("BasePart") then
						-- Only disable collision on main body parts, not accessories
						if part.Name == "Head" or part.Name == "Torso" or part.Name == "HumanoidRootPart" or 
							part.Name == "Left Arm" or part.Name == "Right Arm" or 
							part.Name == "Left Leg" or part.Name == "Right Leg" or
							part.Name == "UpperTorso" or part.Name == "LowerTorso" or
							part.Name == "LeftUpperArm" or part.Name == "LeftLowerArm" or part.Name == "LeftHand" or
							part.Name == "RightUpperArm" or part.Name == "RightLowerArm" or part.Name == "RightHand" or
							part.Name == "LeftUpperLeg" or part.Name == "LeftLowerLeg" or part.Name == "LeftFoot" or
							part.Name == "RightUpperLeg" or part.Name == "RightLowerLeg" or part.Name == "RightFoot" then
							part.CanCollide = false
						end
					end
				end
			end
		end)
	else
		if noclipConnection then
			noclipConnection:Disconnect()
			noclipConnection = nil
		end

		-- Re-enable collision only on parts we disabled
		if localPlayer.Character then
			for _, part in pairs(localPlayer.Character:GetDescendants()) do
				if part:IsA("BasePart") then
					if part.Name == "Head" or part.Name == "Torso" or 
						part.Name == "Left Arm" or part.Name == "Right Arm" or 
						part.Name == "Left Leg" or part.Name == "Right Leg" or
						part.Name == "UpperTorso" or part.Name == "LowerTorso" or
						part.Name == "LeftUpperArm" or part.Name == "LeftLowerArm" or part.Name == "LeftHand" or
						part.Name == "RightUpperArm" or part.Name == "RightLowerArm" or part.Name == "RightHand" or
						part.Name == "LeftUpperLeg" or part.Name == "LeftLowerLeg" or part.Name == "LeftFoot" or
						part.Name == "RightUpperLeg" or part.Name == "RightLowerLeg" or part.Name == "RightFoot" then
						part.CanCollide = true
					end
				end
			end
		end
	end
end)

-- Ultra Cool Auto Dodge with Visual Effects
local isDodgeActive = false
local dodgeLoop = nil
local lastDodgeTime = 0
local dodgeCooldown = 0.5 -- Half second cooldown

-- Add the toggle button to your existing tab
PlayerTab:NewToggle("‚ú® Auto Dodge", "Epic dodge with cool visuals", function(state)
    isDodgeActive = state
    
    if state then
        -- ENABLE
        Library:Notify("‚ú® ULTRA DODGE", "ACTIVE - Epic visuals ready!", 3, "Success")
        
        if dodgeLoop then
            dodgeLoop:Disconnect()
        end
        
        dodgeLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if not isDodgeActive then return end
            ultraDodgeDetection()
        end)
        
    else
        -- DISABLE
        Library:Notify("‚ú® ULTRA DODGE", "INACTIVE", 3, "Warning")
        
        if dodgeLoop then
            dodgeLoop:Disconnect()
            dodgeLoop = nil
        end
    end
end)

function ultraDodgeDetection()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local myRoot = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not myRoot or not humanoid or humanoid.Health <= 0 then return end
    
    -- Cooldown check (HALF SECOND)
    if tick() - lastDodgeTime < dodgeCooldown then return end
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            if otherRoot then
                local distance = (myRoot.Position - otherRoot.Position).Magnitude
                
                if distance < 18 then
                    local toMe = (myRoot.Position - otherRoot.Position).Unit
                    local lookDir = otherRoot.CFrame.LookVector
                    
                    if toMe:Dot(lookDir) > 0.6 then
                        local tool = otherPlayer.Character:FindFirstChildOfClass("Tool")
                        if tool then
                            epicDodge(otherRoot.Position)
                            lastDodgeTime = tick() -- Update cooldown timer
                            break
                        end
                    end
                end
            end
        end
    end
end

function epicDodge(attackerPos)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not rootPart or not humanoid then return end
    
    -- Calculate dodge direction
    local threatDir = (rootPart.Position - attackerPos).Unit
    local dodgeDistance = 25
    
    -- Try multiple safe directions
    local directions = {
        threatDir, -- Direct away
        threatDir:Cross(Vector3.new(0, 1, 0)), -- Left
        -threatDir:Cross(Vector3.new(0, 1, 0)), -- Right
        (threatDir + Vector3.new(0, 0.5, 0)).Unit -- Up and away
    }
    
    local foundSafeSpot = false
    local safePosition = rootPart.Position
    
    for _, dir in ipairs(directions) do
        local testPos = rootPart.Position + (dir * dodgeDistance)
        local groundRay = Ray.new(testPos + Vector3.new(0, 5, 0), Vector3.new(0, -20, 0))
        local groundHit, groundPos = workspace:FindPartOnRay(groundRay, character)
        
        if groundHit then
            safePosition = groundPos + Vector3.new(0, 3, 0)
            foundSafeSpot = true
            break
        end
    end
    
    if foundSafeSpot then
        -- Create EPIC DODGE EFFECTS
        createDodgeEffects(rootPart.Position, safePosition)
        
        -- Teleport after a brief delay for dramatic effect
        spawn(function()
            wait(0.1) -- Small delay for animation
            rootPart.CFrame = CFrame.new(safePosition)
        end)
        
        Library:Notify("üöÄ EPIC DODGE!", "Cooldown: 0.5s", 2, "Success")
    else
        Library:Notify("‚ö†Ô∏è DODGE FAILED", "No safe spot found", 2, "Warning")
    end
end

function createDodgeEffects(startPos, endPos)
    local TweenService = game:GetService("TweenService")
    
    -- 1. DASH TRAIL EFFECT
    spawn(function()
        local trailPart = Instance.new("Part")
        trailPart.Size = Vector3.new(2, 2, 2)
        trailPart.Position = startPos
        trailPart.BrickColor = BrickColor.new("Bright blue")
        trailPart.Material = Enum.Material.Neon
        trailPart.Anchored = true
        trailPart.CanCollide = false
        trailPart.Parent = workspace
        
        local trailTween = TweenService:Create(trailPart, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Position = endPos,
            Transparency = 1
        })
        
        trailTween:Play()
        game:GetService("Debris"):AddItem(trailPart, 1)
    end)
    
    -- 2. AFTERIMAGE EFFECT (Multiple ghost copies)
    spawn(function()
        for i = 1, 3 do
            local afterImage = Instance.new("Part")
            afterImage.Size = Vector3.new(4, 6, 2)
            afterImage.Position = startPos + Vector3.new(0, 1, 0)
            afterImage.BrickColor = BrickColor.new("Bright violet")
            afterImage.Material = Enum.Material.Glass
            afterImage.Transparency = 0.7
            afterImage.Anchored = true
            afterImage.CanCollide = false
            afterImage.Parent = workspace
            
            local tweenInfo = TweenInfo.new(
                0.4, 
                Enum.EasingStyle.Quad, 
                Enum.EasingDirection.Out,
                0, -- RepeatCount
                false, -- Reverses
                i * 0.1 -- Delay
            )
            
            local afterTween = TweenService:Create(afterImage, tweenInfo, {
                Position = endPos + Vector3.new(0, 1, 0),
                Transparency = 1,
                Size = Vector3.new(2, 3, 1)
            })
            
            afterTween:Play()
            game:GetService("Debris"):AddItem(afterImage, 2)
        end
    end)
    
    -- 3. RING EXPLOSION EFFECT at start position
    spawn(function()
        for i = 1, 8 do
            local ringPart = Instance.new("Part")
            ringPart.Size = Vector3.new(0.5, 0.5, 0.5)
            ringPart.Position = startPos
            ringPart.BrickColor = BrickColor.new("Bright yellow")
            ringPart.Material = Enum.Material.Neon
            ringPart.Anchored = true
            ringPart.CanCollide = false
            ringPart.Parent = workspace
            
            local angle = (i / 8) * math.pi * 2
            local ringTween = TweenService:Create(ringPart, TweenInfo.new(0.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
                Position = startPos + Vector3.new(
                    math.cos(angle) * 10,
                    math.sin(angle) * 2,
                    math.sin(angle) * 10
                ),
                Transparency = 1
            })
            
            ringTween:Play()
            game:GetService("Debris"):AddItem(ringPart, 2)
        end
    end)
    
    -- 4. SPEED LINES EFFECT
    spawn(function()
        local speedLines = Instance.new("Part")
        speedLines.Size = Vector3.new(10, 10, 10)
        speedLines.Position = startPos
        speedLines.Transparency = 1
        speedLines.Anchored = true
        speedLines.CanCollide = false
        speedLines.Parent = workspace
        
        local particleEmitter = Instance.new("ParticleEmitter")
        particleEmitter.Texture = "rbxasset://textures/particles/sparkles_main.dds"
        particleEmitter.Lifetime = NumberRange.new(0.3, 0.8)
        particleEmitter.Rate = 100
        particleEmitter.SpreadAngle = Vector2.new(45, 45)
        particleEmitter.Speed = NumberRange.new(10, 20)
        particleEmitter.Color = ColorSequence.new({
            ColorSequenceKeypoint.new(0, Color3.fromRGB(0, 255, 255)),
            ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 0, 255))
        })
        particleEmitter.Parent = speedLines
        
        game:GetService("Debris"):AddItem(speedLines, 1)
    end)
    
    -- 5. IMPACT EFFECT at destination
    spawn(function()
        wait(0.2) -- Delay for arrival
        
        local impactRing = Instance.new("Part")
        impactRing.Size = Vector3.new(1, 0.2, 1)
        impactRing.Position = endPos
        impactRing.BrickColor = BrickColor.new("Lime green")
        impactRing.Material = Enum.Material.Neon
        impactRing.Anchored = true
        impactRing.CanCollide = false
        impactRing.Parent = workspace
        
        local impactTween = TweenService:Create(impactRing, TweenInfo.new(0.5, Enum.EasingStyle.Back, Enum.EasingDirection.Out), {
            Size = Vector3.new(15, 0.2, 15),
            Transparency = 1
        })
        
        impactTween:Play()
        game:GetService("Debris"):AddItem(impactRing, 2)
    end)
    
    -- 6. FLASH EFFECT
    spawn(function()
        local flash = Instance.new("Part")
        flash.Size = Vector3.new(20, 20, 20)
        flash.Position = startPos
        flash.BrickColor = BrickColor.new("Institutional white")
        flash.Material = Enum.Material.Neon
        flash.Transparency = 0.5
        flash.Anchored = true
        flash.CanCollide = false
        flash.Parent = workspace
        
        local flashTween = TweenService:Create(flash, TweenInfo.new(0.3, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {
            Transparency = 1,
            Size = Vector3.new(30, 30, 30)
        })
        
        flashTween:Play()
        game:GetService("Debris"):AddItem(flash, 1)
    end)
end

-- Auto Dash Script - No Visuals
local isAutoDashActive = false
local autoDashLoop = nil
local lastDashTime = 0
local dashCooldown = 2
local isHoldingShift = false
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Add the toggle button
PlayerTab:NewToggle("üåÄ Auto Dodge Legit", "Auto dash away from attacks", function(state)
    isAutoDashActive = state
    
    if state then
        Library:Notify("üåÄ AUTO DODGE LEGIT", "ACTIVE - Will dash from attacks!", 3, "Success")
        
        if autoDashLoop then
            autoDashLoop:Disconnect()
        end
        
        autoDashLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if not isAutoDashActive then return end
            autoDashRoutine()
        end)
        
    else
        Library:Notify("üåÄ AUTO DODGE LEGIT", "INACTIVE", 3, "Warning")
        releaseShift()
        if autoDashLoop then
            autoDashLoop:Disconnect()
            autoDashLoop = nil
        end
    end
end)

-- Shift holding functions
function holdShift()
    if not isHoldingShift then
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
        isHoldingShift = true
    end
end

function releaseShift()
    if isHoldingShift then
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
        isHoldingShift = false
    end
end

-- Main detection routine
function autoDashRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        releaseShift()
        return 
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart or humanoid.Health <= 0 then 
        releaseShift()
        return 
    end
    
    -- Check cooldown
    if tick() - lastDashTime < dashCooldown then return end
    
    -- Detect if any player is attacking us
    local attacker, attackDirection, attackSide = detectAttackDirection()
    
    if attacker and attackSide then
        performDirectionalDash(attackSide, attackDirection)
        lastDashTime = tick()
    end
end

-- Detect which direction the attack is coming from
function detectAttackDirection()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil, nil, nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil, nil, nil end
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
            
            if otherRoot and otherHumanoid and otherHumanoid.Health > 0 then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                
                if distance <= 20 then
                    -- Calculate relative position
                    local attackerPos = otherRoot.Position
                    local myPos = rootPart.Position
                    local relativePos = attackerPos - myPos
                    
                    -- Get local space direction
                    local lookVector = rootPart.CFrame.LookVector
                    local rightVector = rootPart.CFrame.RightVector
                    
                    -- Convert to local space
                    local localX = relativePos:Dot(rightVector)
                    local localZ = relativePos:Dot(lookVector)
                    
                    -- Determine attack direction
                    local attackSide = getAttackDirection(localX, localZ)
                    local attackDirection = (attackerPos - myPos).Unit
                    
                    -- Check if attacker is actually attacking
                    local tool = otherPlayer.Character:FindFirstChildOfClass("Tool")
                    local lookDirection = otherRoot.CFrame.LookVector
                    local directionToMe = (myPos - attackerPos).Unit
                    
                    if tool and directionToMe:Dot(lookDirection) > 0.6 then
                        return otherPlayer, attackDirection, attackSide
                    end
                    
                    -- Also check animations
                    if isPlayerAnimatingAttack(otherPlayer) then
                        return otherPlayer, attackDirection, attackSide
                    end
                end
            end
        end
    end
    
    return nil, nil, nil
end

-- Determine which side the attack is coming from
function getAttackDirection(localX, localZ)
    local angle = math.atan2(localX, localZ)
    local degrees = math.deg(angle)
    
    if degrees < 0 then degrees = degrees + 360 end
    
    if degrees >= 315 or degrees < 45 then
        return "FRONT"
    elseif degrees >= 45 and degrees < 135 then
        return "RIGHT"
    elseif degrees >= 135 and degrees < 225 then
        return "BACK"
    else
        return "LEFT"
    end
end

-- Perform dash based on attack direction
function performDirectionalDash(attackSide, attackDirection)
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart then return end
    
    -- HOLD SHIFT TO RUN
    holdShift()
    
    local dashVector = Vector3.new(0, 0, 0)
    
    -- Calculate dash direction based on attack side
    if attackSide == "FRONT" then
        -- Attack from front - dash backward
        dashVector = -rootPart.CFrame.LookVector
        
    elseif attackSide == "BACK" then
        -- Attack from back - dash forward
        dashVector = rootPart.CFrame.LookVector
        
    elseif attackSide == "LEFT" then
        -- Attack from left - dash right
        dashVector = rootPart.CFrame.RightVector
        
    elseif attackSide == "RIGHT" then
        -- Attack from right - dash left
        dashVector = -rootPart.CFrame.RightVector
    end
    
    -- Execute the dash
    if dashVector.Magnitude > 0 then
        -- Press Q to dash
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Q, false, game)
        wait(0.1)
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Q, false, game)
        
        -- Move in dash direction while holding shift
        local dashDistance = 25
        local dashPosition = rootPart.Position + (dashVector * dashDistance)
        
        -- Move to dash position
        humanoid:MoveTo(dashPosition)
        
        -- Release shift after dash
        spawn(function()
            wait(0.5)
            releaseShift()
        end)
    end
end

-- Check if player is performing attack animations
function isPlayerAnimatingAttack(targetPlayer)
    if not targetPlayer or not targetPlayer.Character then return false end
    
    local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    if not humanoid then return false end
    
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then return false end
    
    for _, track in pairs(animator:GetPlayingAnimationTracks()) do
        local animName = track.Animation.Name:lower()
        if animName:find("attack") or animName:find("swing") or animName:find("slash") or 
           animName:find("punch") or animName:find("kick") or animName:find("shoot") then
            return true
        end
    end
    
    return false
end

-- Clean up when script stops
game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
    releaseShift()
end)

-- Initial notification
Library:Notify("üåÄ AUTO DASH", "Directional dodging enabled!", 4, "Info")

-- DAHENBOT - Working Chat Command System
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local TextChatService = game:GetService("TextChatService")
local RunService = game:GetService("RunService")

-- Bot state
local isDahenBotActive = false
local lastMessageTime = 0
local messageCooldown = 2 -- seconds between bot messages

-- Add toggle to PlayerTab
PlayerTab:NewToggle("DAHENBOT", "Enable chat commands", function(state)
    isDahenBotActive = state
    
    if state then
        Library:Notify("DAHENBOT", "ACTIVE - Say: find [thing], hitbox, help", 5)
        startMessageMonitor()
    else
        Library:Notify("DAHENBOT", "INACTIVE", 3)
        stopMessageMonitor()
    end
end)

-- Monitor chat messages by reading the chat UI
local chatMonitor = nil
local function startMessageMonitor()
    if chatMonitor then return end
    
    chatMonitor = RunService.Heartbeat:Connect(function()
        if not isDahenBotActive then return end
        
        -- Try to find chat messages in the UI
        local success, result = pcall(function()
            -- Method 1: Check TextChatService
            if TextChatService and TextChatService.TextChannels then
                local channel = TextChatService.TextChannels.RBXGeneral
                if channel then
                    local messages = channel:GetMessageHistory()
                    if messages and #messages > 0 then
                        local latest = messages[#messages]
                        if latest and latest.Text then
                            local text = latest.Text
                            local timestamp = latest.Timestamp
                            
                            -- Check if this is a new message for our bot
                            if timestamp > lastMessageTime and (string.find(text:lower(), "dahenbot") or string.find(text:lower(), "bot")) then
                                lastMessageTime = timestamp
                                processChatCommand(text)
                            end
                        end
                    end
                end
            end
        end)
        
        -- If TextChatService method fails, try alternative method
        if not success then
            checkChatAlternative()
        end
    end)
end

local function stopMessageMonitor()
    if chatMonitor then
        chatMonitor:Disconnect()
        chatMonitor = nil
    end
end

-- Alternative chat checking method
local function checkChatAlternative()
    -- This is a backup method - we'll use the old chat system
    local chatUI = game:GetService("CoreGui"):FindFirstChild("Chat")
    if chatUI then
        local channel = chatUI:FindFirstChild("ChannelWindowFrame")
        if channel then
            local messages = channel:GetChildren()
            for _, msgFrame in pairs(messages) do
                if msgFrame:IsA("Frame") and msgFrame:FindFirstChild("MessageLabel") then
                    local label = msgFrame.MessageLabel
                    local text = label.Text
                    if text and (string.find(text:lower(), "dahenbot") or string.find(text:lower(), "bot")) then
                        processChatCommand(text)
                    end
                end
            end
        end
    end
end

-- Process chat commands
local function processChatCommand(message)
    local lowerMsg = message:lower()
    
    -- Find command
    if string.find(lowerMsg, "find") then
        local searchTerm = extractSearchTerm(lowerMsg)
        if searchTerm then
            local results = quickSearch(searchTerm)
            sendBotResponse("üîç " .. results)
        end
    end
    
    -- Hitbox command
    if string.find(lowerMsg, "hitbox") and not string.find(lowerMsg, "find") then
        local results = searchHitboxes()
        sendBotResponse("üéØ " .. results)
    end
    
    -- Help command
    if string.find(lowerMsg, "help") then
        sendBotResponse("ü§ñ Commands: 'find [thing]', 'hitbox', 'help' - Say with 'dahenbot' or 'bot'")
    end
end

-- Extract search term from message
local function extractSearchTerm(message)
    local patterns = {
        "dahenbot find (.+)",
        "bot find (.+)",
        "find (.+) dahenbot",
        "find (.+) bot"
    }
    
    for _, pattern in ipairs(patterns) do
        local match = string.match(message, pattern)
        if match then
            return match:gsub(" dahenbot", ""):gsub(" bot", ""):gsub("^%s*(.-)%s*$", "%1")
        end
    end
    
    return nil
end

-- Send bot response
local function sendBotResponse(message)
    -- Try to send in chat
    local success = pcall(function()
        if TextChatService and TextChatService.TextChannels then
            local channel = TextChatService.TextChannels.RBXGeneral
            if channel then
                channel:SendAsync("ü§ñ DAHENBOT: " .. message)
                return true
            end
        end
        return false
    end)
    
    -- If chat fails, use notification
    if not success then
        Library:Notify("DAHENBOT", message, 8)
    end
end

-- Quick search function
local function quickSearch(searchTerm)
    searchTerm = searchTerm:lower()
    local results = {}
    local count = 0
    
    -- Search in common locations
    local locations = {
        workspace,
        ReplicatedStorage,
        game:GetService("ServerScriptService"),
        game:GetService("StarterPack"),
        game:GetService("StarterPlayer")
    }
    
    for _, location in pairs(locations) do
        if count >= 8 then break end
        
        for _, obj in pairs(location:GetDescendants()) do
            if count >= 8 then break end
            
            -- Check name match
            if string.find(obj.Name:lower(), searchTerm) then
                table.insert(results, obj.Name)
                count = count + 1
            end
        end
    end
    
    if #results > 0 then
        return "Found " .. count .. " items: " .. table.concat(results, ", ")
    else
        return "No results for '" .. searchTerm .. "'"
    end
end

-- Search for hitbox-related objects
local function searchHitboxes()
    local results = {}
    local count = 0
    
    local hitboxTerms = {
        "hitbox", "hit", "damage", "attack", "sword", "weapon", 
        "tool", "handle", "part", "collision", "bounding", "melee"
    }
    
    -- Search workspace
    for _, obj in pairs(workspace:GetDescendants()) do
        if count >= 10 then break end
        
        local objName = obj.Name:lower()
        
        -- Check hitbox terms
        for _, term in pairs(hitboxTerms) do
            if string.find(objName, term) then
                table.insert(results, obj.Name)
                count = count + 1
                break
            end
        end
    end
    
    -- Search tools
    if localPlayer:FindFirstChild("Backpack") then
        for _, tool in pairs(localPlayer.Backpack:GetChildren()) do
            if tool:IsA("Tool") then
                table.insert(results, "Tool:" .. tool.Name)
                count = count + 1
                if count >= 10 then break end
            end
        end
    end
    
    if #results > 0 then
        return "Hitbox objects: " .. table.concat(results, ", ")
    else
        return "No hitbox objects found"
    end
end

-- Manual command buttons (backup method)
PlayerTab:NewTextInput("DAHENBOT Command", "Type commands manually", "find hitbox", function(command)
    if command and command ~= "" then
        processChatCommand("dahenbot " .. command)
    end
end)

PlayerTab:NewButton("Find Hitboxes", "Search for hitbox objects", function()
    processChatCommand("dahenbot hitbox")
end)

PlayerTab:NewButton("DAHENBOT Help", "Show commands", function()
    sendBotResponse("Commands: Type in chat - 'dahenbot find [thing]' or 'dahenbot hitbox'")
end)

-- Test button
PlayerTab:NewButton("Test Search", "Test the search function", function()
    local results = quickSearch("tool")
    sendBotResponse("TEST: " .. results)
end)

-- Initialize
Library:Notify("DAHENBOT", "Toggle ON and say 'dahenbot help' in chat", 5)

-- Auto Attack Script - Moves to nearest player and auto-attacks WITH RUNNING (Shift Hold)
local isAutoAttackActive = false
local autoAttackLoop = nil
local lastAttackTime = 0
local attackCooldown = 0.1
local isHoldingShift = false
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Add the first toggle button
PlayerTab:NewToggle("‚öîÔ∏è Auto Attack", "Auto move to nearest player and attack", function(state)
    isAutoAttackActive = state
    
    if state then
        Library:Notify("‚öîÔ∏è AUTO ATTACK", "ACTIVE - Hunting enemies!", 3, "Success")
        
        if autoAttackLoop then
            autoAttackLoop:Disconnect()
        end
        
        autoAttackLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if not isAutoAttackActive then return end
            autoAttackRoutine()
        end)
        
    else
        Library:Notify("‚öîÔ∏è AUTO ATTACK", "INACTIVE", 3, "Warning")
        releaseShift() -- Release shift when disabled
        if autoAttackLoop then
            autoAttackLoop:Disconnect()
            autoAttackLoop = nil
        end
    end
end)

-- Add the second toggle button (Smart Attack)
local isSmartAttackActive = false
local smartAttackLoop = nil

PlayerTab:NewToggle("üéØ Smart Auto Attack", "Advanced targeting with weapon detection", function(state)
    isSmartAttackActive = state
    
    if state then
        Library:Notify("üéØ SMART ATTACK", "ACTIVE - Weapon-based combat!", 3, "Success")
        
        if smartAttackLoop then
            smartAttackLoop:Disconnect()
        end
        
        smartAttackLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if not isSmartAttackActive then return end
            smartAttackRoutine()
        end)
        
    else
        Library:Notify("üéØ SMART ATTACK", "INACTIVE", 3, "Warning")
        releaseShift() -- Release shift when disabled
        if smartAttackLoop then
            smartAttackLoop:Disconnect()
            smartAttackLoop = nil
        end
    end
end)

-- Shift holding functions
function holdShift()
    if not isHoldingShift then
        -- Press and hold Shift
        VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.LeftShift, false, game)
        isHoldingShift = true
    end
end

function releaseShift()
    if isHoldingShift then
        -- Release Shift
        VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.LeftShift, false, game)
        isHoldingShift = false
    end
end

-- Shared functions for both toggles
function autoAttackRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        releaseShift()
        return 
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart or humanoid.Health <= 0 then 
        releaseShift()
        return 
    end
    
    -- Find nearest player
    local nearestPlayer, nearestDistance = findNearestPlayer()
    
    if nearestPlayer and nearestDistance then
        if nearestDistance <= 8 then
            -- Player is in attack range - ATTACK!
            releaseShift() -- Release shift when attacking
            if tick() - lastAttackTime >= attackCooldown then
                performAttack()
                lastAttackTime = tick()
            end
        else
            -- Player is out of range - RUN TO PLAYER!
            holdShift() -- Hold shift when chasing
            moveToPlayer(nearestPlayer, rootPart, humanoid)
        end
    else
        releaseShift()
        Library:Notify("üéØ SEARCHING", "No targets found", 2, "Warning")
    end
end

function smartAttackRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then 
        releaseShift()
        return 
    end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart or humanoid.Health <= 0 then 
        releaseShift()
        return 
    end
    
    -- Check if player has a weapon
    local weapon = character:FindFirstChildOfClass("Tool")
    local attackRange = weapon and 10 or 5 -- Longer range if has weapon
    
    local nearestPlayer, nearestDistance = findNearestPlayer()
    
    if nearestPlayer and nearestDistance then
        if nearestDistance <= attackRange then
            -- In attack range
            releaseShift() -- Release shift when attacking
            if tick() - lastAttackTime >= attackCooldown then
                if weapon then
                    useWeaponAttack(weapon)
                else
                    performMeleeAttack()
                end
                lastAttackTime = tick()
            end
        else
            -- Move to target - RUN FAST!
            holdShift() -- Hold shift when chasing
            moveToPlayer(nearestPlayer, rootPart, humanoid)
            
            -- Show distance indicator
            Library:Notify("üéØ TARGET", "Distance: " .. math.floor(nearestDistance) .. " studs", 1, "Info")
        end
    else
        releaseShift()
        Library:Notify("üéØ SEARCHING", "No targets found", 2, "Warning")
    end
end

function findNearestPlayer()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil, math.huge end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil, math.huge end
    
    local nearestPlayer = nil
    local nearestDistance = math.huge
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
            
            if otherRoot and otherHumanoid and otherHumanoid.Health > 0 then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end
    
    return nearestPlayer, nearestDistance
end

function moveToPlayer(targetPlayer, rootPart, humanoid)
    if not targetPlayer or not targetPlayer.Character then 
        releaseShift()
        return 
    end
    
    local targetRoot = targetPlayer.Character:FindFirstChild("HumanoidRootPart")
    if not targetRoot then 
        releaseShift()
        return 
    end
    
    -- Calculate direction to target
    local direction = (targetRoot.Position - rootPart.Position).Unit
    
    -- Move towards target (character will run because Shift is held)
    humanoid:MoveTo(targetRoot.Position)
    
    -- Face the target
    rootPart.CFrame = CFrame.new(rootPart.Position, Vector3.new(targetRoot.Position.X, rootPart.Position.Y, targetRoot.Position.Z))
    
    -- Visual effect for movement (different color when running)
    spawn(function()
        local moveEffect = Instance.new("Part")
        moveEffect.Size = Vector3.new(1, 0.2, 1)
        moveEffect.Position = rootPart.Position - Vector3.new(0, 2.5, 0)
        moveEffect.BrickColor = BrickColor.new("Bright blue") -- Blue when running
        moveEffect.Material = Enum.Material.Neon
        moveEffect.Anchored = true
        moveEffect.CanCollide = false
        moveEffect.Transparency = 0.7
        moveEffect.Parent = workspace
        
        game:GetService("Debris"):AddItem(moveEffect, 0.3)
    end)
    
    -- Stop running if very close to target
    local distance = (rootPart.Position - targetRoot.Position).Magnitude
    if distance <= 6 then
        releaseShift()
    end
end

function performAttack()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoid then return end
    
    -- Make sure shift is released
    releaseShift()
    
    -- Method 1: Simulate mouse click (works for most combat systems)
    -- Left click (primary attack)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.05)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    
    -- Method 2: Press attack keys (E, F, Q, R, Space)
    local attackKeys = {Enum.KeyCode.E, Enum.KeyCode.F, Enum.KeyCode.Q, Enum.KeyCode.R, Enum.KeyCode.Space}
    
    for _, key in pairs(attackKeys) do
        VirtualInputManager:SendKeyEvent(true, key, false, game)
        wait(0.03)
        VirtualInputManager:SendKeyEvent(false, key, false, game)
        wait(0.02)
    end
    
    -- Visual effect for attack
    createAttackEffects(character)
    
    Library:Notify("üó°Ô∏è ATTACKING!", "Auto-attack executed!", 1, "Info")
end

function useWeaponAttack(weapon)
    -- Make sure shift is released
    releaseShift()
    
    -- Activate the weapon
    if weapon:FindFirstChild("Handle") then
        -- Simulate clicking the weapon
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
        wait(0.1)
        VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
        
        -- Weapon-specific visual effect
        createWeaponEffects(weapon)
        
        Library:Notify("üî´ WEAPON ATTACK", "Fired " .. weapon.Name, 1, "Success")
    end
end

function performMeleeAttack()
    -- Make sure shift is released
    releaseShift()
    
    -- Melee combo: Click + Space
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.05)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    
    VirtualInputManager:SendKeyEvent(true, Enum.KeyCode.Space, false, game)
    wait(0.05)
    VirtualInputManager:SendKeyEvent(false, Enum.KeyCode.Space, false, game)
    
    Library:Notify("ü•ä MELEE ATTACK", "Punch/Kick combo!", 1, "Info")
end

function createAttackEffects(character)
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    local TweenService = game:GetService("TweenService")
    
    -- SWING EFFECT
    spawn(function()
        for i = 1, 3 do
            local swingPart = Instance.new("Part")
            swingPart.Size = Vector3.new(2, 2, 0.5)
            swingPart.Position = rootPart.Position + (rootPart.CFrame.LookVector * 3)
            swingPart.BrickColor = BrickColor.new("Bright orange")
            swingPart.Material = Enum.Material.Neon
            swingPart.Anchored = true
            swingPart.CanCollide = false
            swingPart.Parent = workspace
            
            local angle = math.rad(i * 45)
            local swingTween = TweenService:Create(swingPart, TweenInfo.new(0.2, Enum.EasingStyle.Quad), {
                Position = rootPart.Position + Vector3.new(
                    math.cos(angle) * 5,
                    0,
                    math.sin(angle) * 5
                ),
                Transparency = 1
            })
            
            swingTween:Play()
            game:GetService("Debris"):AddItem(swingPart, 1)
        end
    end)
    
    -- IMPACT WAVE
    spawn(function()
        local wave = Instance.new("Part")
        wave.Shape = Enum.PartType.Cylinder
        wave.Size = Vector3.new(0.2, 2, 2)
        wave.Position = rootPart.Position
        wave.Orientation = Vector3.new(0, 0, 90)
        wave.BrickColor = BrickColor.new("Bright red")
        wave.Material = Enum.Material.Neon
        wave.Anchored = true
        wave.CanCollide = false
        wave.Parent = workspace
        
        local waveTween = TweenService:Create(wave, TweenInfo.new(0.4, Enum.EasingStyle.Quad), {
            Size = Vector3.new(0.2, 10, 10),
            Transparency = 1
        })
        
        waveTween:Play()
        game:GetService("Debris"):AddItem(wave, 1)
    end)
end

function createWeaponEffects(weapon)
    local character = game.Players.LocalPlayer.Character
    if not character then return end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return end
    
    -- Muzzle flash effect for weapons
    local muzzle = Instance.new("Part")
    muzzle.Size = Vector3.new(1, 1, 1)
    muzzle.Position = rootPart.Position + (rootPart.CFrame.LookVector * 4)
    muzzle.BrickColor = BrickColor.new("Bright yellow")
    muzzle.Material = Enum.Material.Neon
    muzzle.Anchored = true
    muzzle.CanCollide = false
    muzzle.Parent = workspace
    
    game:GetService("Debris"):AddItem(muzzle, 0.2)
end

-- Clean up when script stops
game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
    releaseShift()
end)

-- Initial notification
Library:Notify("‚öîÔ∏è AUTO ATTACK", "Now with Shift running enabled!", 4, "Info")

-- Auto TP Attack - Loop TP to nearest player with spam attacks
local isAutoTPAttackActive = false
local autoTPAttackLoop = nil
local currentTarget = nil
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Add the toggle button
PlayerTab:NewToggle("üîÅ KILLAURA RAGE", "Loop TP to nearest player with spam attacks", function(state)
    isAutoTPAttackActive = state
    
    if state then
        Library:Notify("üîÅ KILLAURA RAGE", "ACTIVE - Teleporting and attacking!", 3, "Success")
        
        if autoTPAttackLoop then
            autoTPAttackLoop:Disconnect()
        end
        
        autoTPAttackLoop = game:GetService("RunService").Heartbeat:Connect(function()
            if not isAutoTPAttackActive then return end
            autoTPAttackRoutine()
        end)
        
    else
        Library:Notify("üîÅ KILLAURA RAGE", "INACTIVE", 3, "Warning")
        currentTarget = nil
        if autoTPAttackLoop then
            autoTPAttackLoop:Disconnect()
            autoTPAttackLoop = nil
        end
    end
end)

-- Main TP attack routine
function autoTPAttackRoutine()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return end
    
    local humanoid = character:FindFirstChild("Humanoid")
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoid or not rootPart or humanoid.Health <= 0 then return end
    
    -- Check if current target is still valid
    if currentTarget then
        if not isTargetValid(currentTarget) then
            -- Target died or became invalid, find new one
            currentTarget = nil
            Library:Notify("üéØ TARGET DOWN", "Finding new target...", 2, "Info")
        end
    end
    
    -- Find new target if needed
    if not currentTarget then
        currentTarget = findNearestPlayer()
        if currentTarget then
            Library:Notify("üéØ NEW TARGET", "Targeting: " .. currentTarget.Name, 2, "Success")
        else
            return -- No targets found
        end
    end
    
    -- TP to target and attack
    if currentTarget and currentTarget.Character then
        local targetRoot = currentTarget.Character:FindFirstChild("HumanoidRootPart")
        if targetRoot then
            -- Teleport behind the target
            local behindOffset = -targetRoot.CFrame.LookVector * 3
            local tpPosition = targetRoot.Position + behindOffset + Vector3.new(0, 3, 0)
            
            -- Teleport to target
            rootPart.CFrame = CFrame.new(tpPosition)
            
            -- Face the target
            rootPart.CFrame = CFrame.new(rootPart.Position, Vector3.new(targetRoot.Position.X, rootPart.Position.Y, targetRoot.Position.Z))
            
            -- Spam attacks
            performSpamAttacks()
        end
    end
end

-- Check if target is still valid (alive and in game)
function isTargetValid(targetPlayer)
    if not targetPlayer then return false end
    if not targetPlayer.Character then return false end
    
    local humanoid = targetPlayer.Character:FindFirstChild("Humanoid")
    if not humanoid then return false end
    
    return humanoid.Health > 0
end

-- Find nearest player (excluding current target if any)
function findNearestPlayer()
    local player = game.Players.LocalPlayer
    local character = player.Character
    if not character then return nil end
    
    local rootPart = character:FindFirstChild("HumanoidRootPart")
    if not rootPart then return nil end
    
    local nearestPlayer = nil
    local nearestDistance = math.huge
    
    for _, otherPlayer in pairs(game.Players:GetPlayers()) do
        if otherPlayer ~= player and otherPlayer.Character then
            local otherRoot = otherPlayer.Character:FindFirstChild("HumanoidRootPart")
            local otherHumanoid = otherPlayer.Character:FindFirstChild("Humanoid")
            
            if otherRoot and otherHumanoid and otherHumanoid.Health > 0 then
                local distance = (rootPart.Position - otherRoot.Position).Magnitude
                
                if distance < nearestDistance then
                    nearestDistance = distance
                    nearestPlayer = otherPlayer
                end
            end
        end
    end
    
    return nearestPlayer
end

-- Perform spam attacks
function performSpamAttacks()
    -- Rapid mouse clicks for spam
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.01)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
    
    -- Additional rapid clicks for more spam
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, true, game, 1)
    wait(0.01)
    VirtualInputManager:SendMouseButtonEvent(0, 0, 0, false, game, 1)
end

-- Monitor target health to auto-switch
local targetMonitorLoop = nil

-- Start monitoring target health when toggle is enabled
game:GetService("Players").LocalPlayer.Chatted:Connect(function(message)
    if message:lower() == "start target monitor" and isAutoTPAttackActive and not targetMonitorLoop then
        startTargetMonitor()
    end
end)

function startTargetMonitor()
    if targetMonitorLoop then
        targetMonitorLoop:Disconnect()
    end
    
    targetMonitorLoop = game:GetService("RunService").Heartbeat:Connect(function()
        if not isAutoTPAttackActive then
            if targetMonitorLoop then
                targetMonitorLoop:Disconnect()
                targetMonitorLoop = nil
            end
            return
        end
        
        if currentTarget and currentTarget.Character then
            local humanoid = currentTarget.Character:FindFirstChild("Humanoid")
            if humanoid and humanoid.Health <= 0 then
                Library:Notify("üíÄ TARGET ELIMINATED", "Moving to next target...", 2, "Warning")
                currentTarget = nil
            end
        end
    end)
end

-- Clean up when script stops
game:GetService("Players").LocalPlayer.CharacterRemoving:Connect(function()
    currentTarget = nil
    if targetMonitorLoop then
        targetMonitorLoop:Disconnect()
        targetMonitorLoop = nil
    end
end)

-- Initial notification
Library:Notify("üîÅ AUTO TP ATTACK", "Will TP to nearest player and spam attacks!", 4, "Info")

-- Raycast Hitbox Expander
local Players = game:GetService("Players")
local localPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")
local VirtualInputManager = game:GetService("VirtualInputManager")

-- Hitbox variables
local isHitboxExpanderActive = false
local raycastRange = 50
local originalRaycast = nil
local isAttacking = false

-- Add toggle to PlayerTab
PlayerTab:NewToggle("Raycast Expander", "Extend attack range using raycasts", function(state)
    isHitboxExpanderActive = state
    
    if state then
        enableRaycastExpansion()
        Library:Notify("RAYCAST", "Enabled - Range: " .. raycastRange, 3)
    else
        disableRaycastExpansion()
        Library:Notify("RAYCAST", "Disabled", 3)
    end
end)

-- Range input
PlayerTab:NewTextInput("Raycast Range", "Set range (10-100)", "50", function(text)
    local newRange = tonumber(text)
    if newRange and newRange >= 10 and newRange <= 100 then
        raycastRange = newRange
        Library:Notify("RAYCAST", "Range: " .. raycastRange, 3)
    else
        Library:Notify("RAYCAST", "Use 10-100", 3)
    end
end)

-- Hook raycast functions
local function enableRaycastExpansion()
    if originalRaycast then return end
    
    -- Store original raycast function
    originalRaycast = workspace.Raycast
    
    -- Hook the raycast method
    workspace.Raycast = function(workspace, origin, direction, params, ...)
        if isHitboxExpanderActive and isAttacking then
            -- Extend the raycast range
            local extendedDirection = direction.Unit * raycastRange
            return originalRaycast(workspace, origin, extendedDirection, params, ...)
        end
        
        return originalRaycast(workspace, origin, direction, params, ...)
    end
    
    -- Also hook Ray.new for additional coverage
    local originalRayNew = Ray.new
    Ray.new = function(origin, direction)
        if isHitboxExpanderActive and isAttacking then
            local extendedDirection = direction.Unit * raycastRange
            return originalRayNew(origin, extendedDirection)
        end
        return originalRayNew(origin, direction)
    end
end

-- Restore original functions
local function disableRaycastExpansion()
    if originalRaycast then
        workspace.Raycast = originalRaycast
        originalRaycast = nil
    end
end

-- Track when player is attacking
local function trackAttackState()
    local character = localPlayer.Character
    if not character then return end
    
    -- Check for tool usage (attacking)
    local tool = character:FindFirstChildOfClass("Tool")
    if tool then
        -- Check for mouse clicks or attack inputs
        isAttacking = true
        delay(0.5, function() isAttacking = false end)
    end
    
    -- Check animations
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if humanoid then
        for _, track in pairs(humanoid:GetPlayingAnimationTracks()) do
            local name = track.Name:lower()
            if string.find(name, "attack") or string.find(name, "swing") or string.find(name, "hit") then
                isAttacking = true
                delay(1, function() isAttacking = false end)
                break
            end
        end
    end
end

-- Monitor attack state
RunService.Heartbeat:Connect(trackAttackState)

-- Manual attack detection for mobile
local function setupMobileAttackDetection()
    -- Listen for screen taps (mobile attacks)
    local UIS = game:GetService("UserInputService")
    
    UIS.InputBegan:Connect(function(input, gameProcessed)
        if gameProcessed then return end
        
        if input.UserInputType == Enum.UserInputType.Touch then
            isAttacking = true
            delay(0.5, function() isAttacking = false end)
        elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
            isAttacking = true
            delay(0.5, function() isAttacking = false end)
        end
    end)
end

setupMobileAttackDetection()

-- Enhanced: Hook specific combat modules that use raycasts
local function hookCombatModules()
    if not isHitboxExpanderActive then return end
    
    -- Search for combat-related modules
    for _, obj in pairs(game:GetDescendants()) do
        if obj:IsA("ModuleScript") then
            local success, module = pcall(require, obj)
            if success and type(module) == "table" then
                -- Look for functions that might use raycasts
                for funcName, func in pairs(module) do
                    if type(func) == "function" then
                        -- Check if function name suggests raycast usage
                        if string.find(funcName:lower(), "raycast") or
                           string.find(funcName:lower(), "cast") or
                           string.find(funcName:lower(), "checkhit") then
                           
                            module[funcName] = function(...)
                                local args = {...}
                                -- Modify raycast parameters in the arguments
                                for i, arg in pairs(args) do
                                    if type(arg) == "number" and arg > 0 and arg < 100 then
                                        -- This might be a raycast distance
                                        args[i] = arg * (raycastRange / 50)
                                    end
                                end
                                return func(unpack(args))
                            end
                        end
                    end
                end
            end
        end
    end
end

-- Test function to verify raycast expansion
local function testRaycastExpansion()
    local character = localPlayer.Character
    if not character then return end
    
    local root = character:FindFirstChild("HumanoidRootPart")
    if not root then return end
    
    -- Perform a test raycast
    local origin = root.Position
    local direction = root.CFrame.LookVector
    
    local params = RaycastParams.new()
    params.FilterType = Enum.RaycastFilterType.Blacklist
    params.FilterDescendantsInstances = {character}
    
    local result = workspace:Raycast(origin, direction * raycastRange, params)
    
    if result then
        Library:Notify("RAYCAST TEST", "Hit: " .. result.Instance.Name, 4)
    else
        Library:Notify("RAYCAST TEST", "No hit at " .. raycastRange .. " studs", 4)
    end
end

-- Manual combat module hooking
PlayerTab:NewButton("Hook Combat Modules", "Hook game combat systems", function()
    if isHitboxExpanderActive then
        hookCombatModules()
        Library:Notify("RAYCAST", "Combat modules hooked", 3)
    else
        Library:Notify("RAYCAST", "Enable expander first", 3)
    end
end)

-- Test button
PlayerTab:NewButton("Test Raycast", "Test current raycast range", function()
    testRaycastExpansion()
end)

-- Status button
PlayerTab:NewButton("Raycast Status", "Check current settings", function()
    if isHitboxExpanderActive then
        Library:Notify("RAYCAST", "Active - Range: " .. raycastRange, 4)
    else
        Library:Notify("RAYCAST", "Inactive", 3)
    end
end)

-- Handle character changes
localPlayer.CharacterAdded:Connect(function()
    if isHitboxExpanderActive then
        task.wait(2)
        hookCombatModules()
    end
end)

-- Clean up
localPlayer.CharacterRemoving:Connect(function()
    disableRaycastExpansion()
end)

game:BindToClose(function()
    disableRaycastExpansion()
end)

Library:Notify("RAYCAST", "Raycast Expander Loaded!", 4)    

-- GAME TAB CONTENT
GameTab:NewText("=== GAME TELEPORTS ===")

GameTab:NewText("Red Light Green Light")

GameTab:NewButton("RLGL - Teleport To End", function()
	local char = localPlayer.Character
	char.HumanoidRootPart.CFrame = CFrame.new(-46.0587921, 1025.23352, 108.6353122)
end)

GameTab:NewButton("RLGL - Teleport To Start", function()
	local char = localPlayer.Character
	char.HumanoidRootPart.CFrame = CFrame.new(-48.5137215, 1024.521, -492.023163)
end)

-- Get all player usernames
local function getPlayerList()
	local playerList = {}
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= localPlayer then
			table.insert(playerList, player.Name)
		end
	end
	return playerList
end

-- Find player by username
local function getPlayerByName(name)
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Name == name then
			return player
		end
	end
	return nil
end
-- Auto help function
local function autoHelp()
	local playerList = getPlayerList()
	local targetPlayer = nil
	local targetPlayerName = nil
	local to = Players:GetAttribute("InjuredPlayer")
end

local NEVERAURA = false
local MAYBEAURA = false

GameTab:NewToggle("ANTI SHOT!!", false, function()
	MAYBEAURA = not MAYBEAURA
	local char = localPlayer.Character
	while true do
		if MAYBEAURA == true then
			char.Parent = workspace.Live.GreenPlayers
			if char:FindFirstChild("MovedRecentlyRedLight") then
				char.SafeRedLightGreenLight:Destroy()
			end
			if char:FindFirstChild("SafeRedLightGreenLight") then
				char.SafeRedLightGreenLight:Destroy()
			end

			local folder = Instance.new("Folder")
			folder.Parent = char
			folder.Name = "SafeRedLightGreenLight"
		end
		task.wait()
	end
end)

GameTab:NewToggle("RLGL - Auto Help", false, function()
	NEVERAURA = not NEVERAURA
end)

GameTab:NewDivider()

GameTab:NewText("Dalgona")

local NOTDELETEABLE = {"Lighting", "Won", "PickModelCacheFix"}

local shapes = {"Star", "Circle", "Umbrella", "MonaLisa", "Triangle", "SackBoy"}
local outlineParts = {}
local connection = nil
local clickConnections = {}

local function createOutline(shape)
	-- Clear existing outline
	for _, part in pairs(outlineParts) do
		part:Destroy()
	end
	outlineParts = {}

	if not shape then return end

	local cf, size = shape:GetBoundingBox()
	local thickness = 0.3
	local padding = 0.5
	local outlineSize = size + Vector3.new(padding * 2, padding * 2, padding * 2)

	local edges = {
		{pos = Vector3.new(outlineSize.X/2, -outlineSize.Y/2, 0), size = Vector3.new(thickness, thickness, outlineSize.Z)},
		{pos = Vector3.new(-outlineSize.X/2, -outlineSize.Y/2, 0), size = Vector3.new(thickness, thickness, outlineSize.Z)},
		{pos = Vector3.new(0, -outlineSize.Y/2, outlineSize.Z/2), size = Vector3.new(outlineSize.X, thickness, thickness)},
		{pos = Vector3.new(0, -outlineSize.Y/2, -outlineSize.Z/2), size = Vector3.new(outlineSize.X, thickness, thickness)},
		{pos = Vector3.new(outlineSize.X/2, outlineSize.Y/2, 0), size = Vector3.new(thickness, thickness, outlineSize.Z)},
		{pos = Vector3.new(-outlineSize.X/2, outlineSize.Y/2, 0), size = Vector3.new(thickness, thickness, outlineSize.Z)},
		{pos = Vector3.new(0, outlineSize.Y/2, outlineSize.Z/2), size = Vector3.new(outlineSize.X, thickness, thickness)},
		{pos = Vector3.new(0, outlineSize.Y/2, -outlineSize.Z/2), size = Vector3.new(outlineSize.X, thickness, thickness)},
		{pos = Vector3.new(outlineSize.X/2, 0, outlineSize.Z/2), size = Vector3.new(thickness, outlineSize.Y, thickness)},
		{pos = Vector3.new(-outlineSize.X/2, 0, outlineSize.Z/2), size = Vector3.new(thickness, outlineSize.Y, thickness)},
		{pos = Vector3.new(outlineSize.X/2, 0, -outlineSize.Z/2), size = Vector3.new(thickness, outlineSize.Y, thickness)},
		{pos = Vector3.new(-outlineSize.X/2, 0, -outlineSize.Z/2), size = Vector3.new(thickness, outlineSize.Y, thickness)},
	}

	for _, edge in pairs(edges) do
		local part = Instance.new("Part")
		part.Size = edge.size
		part.Anchored = true
		part.CanCollide = false
		part.Material = Enum.Material.Neon
		part.Color = Color3.fromRGB(0, 255, 0)
		part.Transparency = 0
		part.Parent = workspace
		table.insert(outlineParts, part)
	end

	if connection then connection:Disconnect() end
	connection = RunService.RenderStepped:Connect(function()
		if not shape or not shape.Parent then
			for _, part in pairs(outlineParts) do
				part:Destroy()
			end
			outlineParts = {}
			if connection then connection:Disconnect() end
			return
		end

		local newCf = shape:GetBoundingBox()
		for i, part in pairs(outlineParts) do
			part.CFrame = newCf * CFrame.new(edges[i].pos)
		end
	end)

	print("Outline created!")
end

GameTab:NewButton("Auto Cookie", function()
	local Module = game.ReplicatedStorage.Modules.Games.DalgonaClient
	for _, f in ipairs(getreg()) do
		if typeof(f) == "function" and islclosure(f) then
			if getfenv(f).script == Module then
				if getinfo(f).nups == 76 then
					setupvalue(f, 33, 9e9)
					setupvalue(f, 34, 9e9)
					break
				end
			end
		end
	end
end)

-- ESP Configuration
local espSeekersEnabled = false
local espHidersEnabled = false

-- Function to check if player has a knife (is a seeker)
local function isSeeker(player)
	if not player then return false end

	-- Check character for knife
	if player.Character and player.Character:FindFirstChild("Knife") then
		return true
	end

	-- Check backpack for knife
	local backpack = player:FindFirstChild("Backpack")
	if backpack and backpack:FindFirstChild("Knife") then
		return true
	end

	return false
end

-- Create simple box ESP
local function createBox(character, color)
	if not character or not character:FindFirstChild("HumanoidRootPart") then return end

	-- Remove existing box
	local existingBox = character:FindFirstChild("ESPBox")
	if existingBox then
		existingBox:Destroy()
	end

	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	local humanoid = character:FindFirstChild("Humanoid")

	-- Determine target part based on rig type
	local targetPart = humanoidRootPart
	if humanoid then
		if humanoid.RigType == Enum.HumanoidRigType.R6 then
			targetPart = character:FindFirstChild("Torso") or humanoidRootPart
		else
			targetPart = character:FindFirstChild("LowerTorso") or humanoidRootPart
		end
	end

	-- Create BillboardGui for box
	local boxGui = Instance.new("BillboardGui")
	boxGui.Name = "ESPBox"
	boxGui.Parent = character
	boxGui.Size = UDim2.new(4, 0, 6, 0)
	boxGui.StudsOffset = Vector3.new(0, 0, 0)
	boxGui.Adornee = targetPart
	boxGui.AlwaysOnTop = true
	boxGui.ZIndexBehavior = Enum.ZIndexBehavior.Global

	-- Container frame
	local containerFrame = Instance.new("Frame")
	containerFrame.Parent = boxGui
	containerFrame.Size = UDim2.new(1, 0, 1, 0)
	containerFrame.BackgroundTransparency = 1

	-- Create box edges (Top, Bottom, Left, Right)
	local edges = {
		{UDim2.new(1, 0, 0, 2), UDim2.new(0, 0, 0, 0)}, -- Top
		{UDim2.new(1, 0, 0, 2), UDim2.new(0, 0, 1, -2)}, -- Bottom
		{UDim2.new(0, 2, 1, 0), UDim2.new(0, 0, 0, 0)}, -- Left
		{UDim2.new(0, 2, 1, 0), UDim2.new(1, -2, 0, 0)} -- Right
	}

	for _, data in ipairs(edges) do
		local edge = Instance.new("Frame")
		edge.Parent = containerFrame
		edge.Size = data[1]
		edge.Position = data[2]
		edge.BackgroundColor3 = color
		edge.BorderSizePixel = 0
	end
end

-- Remove box from character
local function removeBox(character)
	if not character then return end
	local box = character:FindFirstChild("ESPBox")
	if box then
		box:Destroy()
	end
end

-- Update ESP for a single player
local function updatePlayerESP(player)
	if not player or player == localPlayer then return end
	if not player.Character then return end

	local isSeekerRole = isSeeker(player)

	-- Check if we should show ESP
	if (isSeekerRole and espSeekersEnabled) then
		createBox(player.Character, Color3.new(1, 0, 0)) -- Red for seeker
	elseif (not isSeekerRole and espHidersEnabled) then
		createBox(player.Character, Color3.new(0, 0, 1)) -- Blue for hider
	else
		removeBox(player.Character)
	end
end

-- Update all players ESP
local function updateAllESP()
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= localPlayer then
			updatePlayerESP(player)
		end
	end
end

-- Remove all ESP boxes
local function removeAllESP()
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Character then
			removeBox(player.Character)
		end
	end
end

-- Setup player monitoring
local function setupPlayer(player)
	if player == localPlayer then return end

	-- Monitor character added
	player.CharacterAdded:Connect(function(character)
		task.wait(0.5) -- Wait for character to fully load
		updatePlayerESP(player)
	end)

	-- Monitor existing character
	if player.Character then
		-- Monitor for knife changes
		player.Character.ChildAdded:Connect(function(child)
			if child.Name == "Knife" then
				task.wait(0.1)
				updatePlayerESP(player)
			end
		end)

		player.Character.ChildRemoved:Connect(function(child)
			if child.Name == "Knife" then
				task.wait(0.1)
				updatePlayerESP(player)
			end
		end)
	end

	-- Monitor backpack
	local backpack = player:FindFirstChild("Backpack")
	if backpack then
		backpack.ChildAdded:Connect(function(child)
			if child.Name == "Knife" then
				task.wait(0.1)
				updatePlayerESP(player)
			end
		end)

		backpack.ChildRemoved:Connect(function(child)
			if child.Name == "Knife" then
				task.wait(0.1)
				updatePlayerESP(player)
			end
		end)
	end
end

-- Initialize ESP system
local function initializeESP()
	-- Setup existing players
	for _, player in ipairs(Players:GetPlayers()) do
		setupPlayer(player)
	end

	-- Setup new players
	Players.PlayerAdded:Connect(setupPlayer)

	-- Cleanup when players leave
	Players.PlayerRemoving:Connect(function(player)
		if player.Character then
			removeBox(player.Character)
		end
	end)
end

-- Start the ESP system
initializeESP()

GameTab:NewDivider()

GameTab:NewText("Final Dinner / HNS")

GameTab:NewButton("Final Dinner - Teleport To Safe Spot", function()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	if char and char:FindFirstChild("HumanoidRootPart") then
		char.HumanoidRootPart.CFrame = CFrame.new(182.413818, 121.033997, -93.8286514)
	end
end)

GameTab:NewToggle("ESP Seekers", false, function(state)
	espSeekersEnabled = state
	updateAllESP()
	print("ESP Seekers:", state and "Enabled" or "Disabled")
end)

GameTab:NewToggle("ESP Hiders", false, function(state)
	espHidersEnabled = state
	updateAllESP()
	print("ESP Hiders:", state and "Enabled" or "Disabled")
end)

GameTab:NewButton("HNS - ESP Exit", function()
	for i, floor1doors in pairs(game.Workspace.HideAndSeekMap.NEWFIXEDDOORS.Floor1.EXITDOORS:GetChildren()) do
		Instance.new("Highlight", floor1doors)
	end
	for i, floor2doors in pairs(game.Workspace.HideAndSeekMap.NEWFIXEDDOORS.Floor2.EXITDOORS:GetChildren()) do
		Instance.new("Highlight", floor2doors)
	end
	for i, floor3doors in pairs(game.Workspace.HideAndSeekMap.NEWFIXEDDOORS.Floor3.EXITDOORS:GetChildren()) do
		Instance.new("Highlight", floor3doors)
	end
end)

GameTab:NewButton("HNS - Delete The Spikes", function()
	game.Workspace.HideAndSeekMap.KillingParts:Destroy()
end)

-- Loopkill Variables
local selectedTarget = nil
local loopkillEnabled = false
local loopkillConnection = nil
local lastAttackTime = 0
local attackCooldown = 0.3

-- Get all player usernames
local function getPlayerList()
	local playerList = {}
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= localPlayer then
			table.insert(playerList, player.Name)
		end
	end
	return playerList
end

-- Find player by username
local function getPlayerByName(name)
	for _, player in ipairs(Players:GetPlayers()) do
		if player.Name == name then
			return player
		end
	end
	return nil
end

-- Get damage tool (Knife, Fork, or Bottle)
local function getDamageTool()
	local character = localPlayer.Character
	if not character then return nil end

	-- Check if tool is equipped in character
	local knife = character:FindFirstChild("Knife")
	if knife and knife:IsA("Tool") then return knife end

	local fork = character:FindFirstChild("Fork")
	if fork and fork:IsA("Tool") then return fork end

	local bottle = character:FindFirstChild("Bottle")
	if bottle and bottle:IsA("Tool") then return bottle end

	-- Check backpack
	local backpack = localPlayer:FindFirstChild("Backpack")
	if backpack then
		knife = backpack:FindFirstChild("Knife")
		if knife and knife:IsA("Tool") then return knife end

		fork = backpack:FindFirstChild("Fork")
		if fork and fork:IsA("Tool") then return fork end

		bottle = backpack:FindFirstChild("Bottle")
		if bottle and bottle:IsA("Tool") then return bottle end
	end

	return nil
end

-- Equip the damage tool
local function equipDamageTool()
	local tool = getDamageTool()
	if not tool then return false end

	-- If tool is in backpack, equip it
	if tool.Parent == localPlayer.Backpack then
		localPlayer.Character.Humanoid:EquipTool(tool)
		task.wait(0.1)
	end

	return true
end

-- Calculate orbit position around target
local function getOrbitPosition(targetPosition, angle, radius)
	local x = targetPosition.X + math.cos(angle) * radius
	local z = targetPosition.Z + math.sin(angle) * radius
	return Vector3.new(x, targetPosition.Y, z)
end

local function performLoopkill()
	if not loopkillEnabled or not selectedTarget then return end
	local targetPlayer = getPlayerByName(selectedTarget)
	if not targetPlayer or not targetPlayer.Character then return end
	local targetChar = targetPlayer.Character
	local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
	local targetHumanoid = targetChar:FindFirstChild("Humanoid")
	if not targetRoot or not targetHumanoid or targetHumanoid.Health <= 0 then return end
	local character = localPlayer.Character
	if not character then return end
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end
	-- Equip damage tool
	if not equipDamageTool() then
		warn("No damage tool found (Knife, Fork, or Bottle)")
		return
	end
	local tool = getDamageTool()
	if not tool or tool.Parent ~= character then return end
	-- Calculate orbit angle based on time
	local currentTime = tick()
	local angle = (currentTime * 3) % (math.pi * 2) -- Rotate around target
	local radius = 1 -- Distance from target (closer)
	-- Get orbit position
	local orbitPos = getOrbitPosition(targetRoot.Position, angle, radius)
	-- Teleport to orbit position
	humanoidRootPart.CFrame = CFrame.new(orbitPos, targetRoot.Position)
	-- Attack every 0.1 seconds
	if currentTime - lastAttackTime >= 0.1 then
		-- Activate the tool to damage
		if tool:FindFirstChild("Handle") then
			-- Fire remote or activate tool
			local remoteEvent = tool:FindFirstChildWhichIsA("RemoteEvent")
			local remoteFunction = tool:FindFirstChildWhichIsA("RemoteFunction")
			if remoteEvent then
				pcall(function()
					remoteEvent:FireServer()
				end)
			end
			if remoteFunction then
				pcall(function()
					remoteFunction:InvokeServer()
				end)
			end
			-- Try to activate tool
			pcall(function()
				tool:Activate()
			end)
		end
		lastAttackTime = currentTime
	end
end

GameTab:NewDivider()
GameTab:NewText("Tug of War")

local tugOfWarAutoEnabled = false
local tugOfWarAutoThread = nil
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Remote = ReplicatedStorage.Remotes:WaitForChild("TemporaryReachedBindable")
local VALID_PULL_DATA = { { IHateYou = true } }

GameTab:NewToggle("Tug of War Auto", false, function(Value)
	tugOfWarAutoEnabled = Value
	if Value then
		if tugOfWarAutoThread then return end
		tugOfWarAutoThread = task.spawn(function()
			while tugOfWarAutoEnabled do
				Remote:FireServer(unpack(VALID_PULL_DATA))
				task.wait(0.025)
			end
			tugOfWarAutoThread = nil
		end)
	else
		tugOfWarAutoEnabled = false
		if tugOfWarAutoThread then
			task.cancel(tugOfWarAutoThread)
			tugOfWarAutoThread = nil
		end
	end
end)
--[[
REBEL:
THE GUARDS CONTAIN: "RebelGuard"
Folder: game.Workspace.Live
]]

-- Start loopkill
local function startLoopkill()
	if loopkillConnection then
		loopkillConnection:Disconnect()
	end

	loopkillConnection = RunService.Heartbeat:Connect(function()
		if loopkillEnabled and selectedTarget then
			pcall(performLoopkill)
		end
	end)

	print("Loopkill started on:", selectedTarget)
end

-- Stop loopkill
local function stopLoopkill()
	if loopkillConnection then
		loopkillConnection:Disconnect()
		loopkillConnection = nil
	end

	print("Loopkill stopped")
end

-- Player dropdown
local playerDropdown = GameTab:NewDropdown("Select Target", getPlayerList(), nil, function(selected)
	selectedTarget = selected
	print("Target selected:", selectedTarget)

	-- If loopkill is already enabled, restart with new target
	if loopkillEnabled then
		stopLoopkill()
		startLoopkill()
	end
end)

-- Loopkill toggle
local aura = GameTab:NewToggle("Kill aura", false, function(state)
	loopkillEnabled = state

	if state then
		if not selectedTarget then
			warn("Please select a target first!")
			loopkillEnabled = false
			return
		end

		if not getDamageTool() then
			warn("You need a Knife, Fork, or Bottle to use loopkill!")
			loopkillEnabled = false
			return
		end

		startLoopkill()
	else
		stopLoopkill()
	end
end)

-- Update player list when players join/leave
Players.PlayerAdded:Connect(function()
	task.wait(0.5)
	-- Note: You'd need to manually refresh the dropdown or add an update function
	print("Player joined - consider refreshing target list")
end)

Players.PlayerRemoving:Connect(function(player)
	if selectedTarget == player.Name then
		selectedTarget = nil
		loopkillEnabled = false
		stopLoopkill()
		print("Target left the game - loopkill disabled")
	end
end)

-- Clean up on death
localPlayer.CharacterAdded:Connect(function()
	task.wait(1)
	if loopkillEnabled then
		print("Respawned - restarting loopkill")
	end
end)

GameTab:NewDivider()

GameTab:NewText("Jump Rope")
GameTab:NewButton("Jump Rope - Teleport To End", function()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	if char and char:FindFirstChild("HumanoidRootPart") then
		char.HumanoidRootPart.CFrame = CFrame.new(720.896057, 198.628311, 921.170654)
	end
end)

GameTab:NewButton("Jump Rope - Delete The Rope", function()
	game.Workspace.Effects.rope:Destroy()
end)

GameTab:NewDivider()

GameTab:NewText("Glass Bridge")
GameTab:NewButton("Glass Bridge - Teleport To End", function()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	if char and char:FindFirstChild("HumanoidRootPart") then
		char.HumanoidRootPart.CFrame = CFrame.new(-196.372467, 522.192139, -1534.20984)
	end
end)

GameTab:NewButton("Glass Bridge Fake Glass", function()
	CreateGlassBridgeCover()
end)

GameTab:NewButton("Glass Esp", function()
	local GlassHolder = workspace:WaitForChild("GlassBridge"):WaitForChild("GlassHolder")

	for i, v in pairs(GlassHolder:GetChildren()) do
		for g, j in pairs(v:GetChildren()) do
			if j:IsA("Model") and j.PrimaryPart then
				local Color = j.PrimaryPart:GetAttribute("exploitingisevil") 
					and Color3.fromRGB(248, 87, 87) 
					or Color3.fromRGB(28, 235, 87)
				j.PrimaryPart.Color = Color
				j.PrimaryPart.Transparency = 0
				j.PrimaryPart.Material = Enum.Material.Neon
			end
		end
	end
end)

local RebelBring = false
local guardConnection = nil

local function bringGuardsRebel()
	RebelBring = not RebelBring

	if RebelBring then
		local Players = game:GetService("Players")
		local localPlayer = Players.LocalPlayer

		-- Function to teleport a single guard
		local function teleportGuard(guard)
			local character = localPlayer.Character
			if not character then return end

			local rootPart = character:FindFirstChild("HumanoidRootPart")
			if not rootPart then return end

			local guardRoot = guard:FindFirstChild("HumanoidRootPart") or guard:FindFirstChild("Torso")

			if guardRoot and guardRoot:IsA("BasePart") then
				guardRoot.CFrame = rootPart.CFrame * CFrame.new(0, 0, -10)
			elseif guard:IsA("Model") then
				guard:MoveTo((rootPart.CFrame * CFrame.new(0, 0, -10)).Position)
			end
		end

		-- Teleport all existing guards
		local liveFolder = game.Workspace:FindFirstChild("Live")
		if liveFolder then
			for _, child in ipairs(liveFolder:GetChildren()) do
				if string.find(child.Name, "RebelGuard") then
					teleportGuard(child)
				end
			end

			-- Monitor for new guards and auto-teleport them
			guardConnection = liveFolder.ChildAdded:Connect(function(child)
				if RebelBring and string.find(child.Name, "RebelGuard") then
					task.wait(0.5)
					teleportGuard(child)
				end
			end)

			print("RebelGuard auto-bring enabled")
		end
	else
		-- Disconnect the monitoring when disabled
		if guardConnection then
			guardConnection:Disconnect()
			guardConnection = nil
		end
		print("RebelGuard auto-bring disabled")
	end
end

local function aimbotRebelGuards()
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")
	local localPlayer = Players.LocalPlayer
	local camera = workspace.CurrentCamera

	local aimbotConnection = nil
	local isAimbotActive = false

	return function(toggle)
		isAimbotActive = toggle

		if isAimbotActive then
			aimbotConnection = RunService.RenderStepped:Connect(function()
				if not isAimbotActive then return end

				local character = localPlayer.Character
				if not character then return end

				local rootPart = character:FindFirstChild("HumanoidRootPart")
				if not rootPart then return end

				local liveFolder = game.Workspace:FindFirstChild("Live")
				if not liveFolder then return end

				-- Find closest RebelGuard
				local closestGuard = nil
				local shortestDistance = math.huge

				for _, child in ipairs(liveFolder:GetChildren()) do
					if string.find(child.Name, "RebelGuard") then
						local guardHead = child:FindFirstChild("Head")
						local guardHumanoid = child:FindFirstChild("Humanoid")

						if guardHead and guardHumanoid and guardHumanoid.Health > 0 then
							local distance = (rootPart.Position - guardHead.Position).Magnitude

							if distance < shortestDistance then
								shortestDistance = distance
								closestGuard = guardHead
							end
						end
					end
				end

				-- Aim at closest guard
				if closestGuard then
					camera.CFrame = CFrame.new(camera.CFrame.Position, closestGuard.Position)
				end
			end)

			print("RebelGuard aimbot enabled")
		else
			if aimbotConnection then
				aimbotConnection:Disconnect()
				aimbotConnection = nil
			end
			print("RebelGuard aimbot disabled")
		end
	end
end

GameTab:NewDivider()
GameTab:NewText("Rebel")

GameTab:NewToggle("Bring Guards", false, function(state)
	while true do
		task.wait()
		if state then
			bringGuardsRebel()
		else
			bringGuardsRebel()
		end
	end
end)

GameTab:NewToggle("Aimbot Guards", false, function(state)
	if state then
		aimbotRebelGuards(true)
	else
		aimbotRebelGuards(false)
	end
end)

GameTab:NewDivider()
GameTab:NewText("Mingle [coming soon]")

GameTab:NewButton("Teleport To Room", function()
	local char = localPlayer.Character
	char.HumanoidRootPart.CFrame = CFrame.new(1170.68262, 403.950592, -486.154968)
end)

GameTab:NewDivider()
GameTab:NewText("Final Sky squid Game[SKY SQUID]")

GameTab:NewButton("Anti fall", function()
	local Players = game:GetService("Players")
	local RunService = game:GetService("RunService")

	local player = Players.LocalPlayer
	repeat task.wait() until player.Character and player.Character:FindFirstChild("HumanoidRootPart")
	local character = player.Character
	local rootPart = character:WaitForChild("HumanoidRootPart")
	local startingY = rootPart.Position.Y
	local fallLimit = startingY - 5
	local teleported = false

	RunService.RenderStepped:Connect(function()
		if not rootPart or not rootPart.Parent then return end
		if rootPart.Position.Y < fallLimit and not teleported then
			teleported = true
			local nearestPlayer
			local nearestDist = math.huge
			for _, other in ipairs(Players:GetPlayers()) do
				if other ~= player and other.Character and other.Character:FindFirstChild("HumanoidRootPart") then
					local hum = other.Character:FindFirstChild("Humanoid")
					if hum and hum.Health > 0 then
						local dist = (rootPart.Position - other.Character.HumanoidRootPart.Position).Magnitude
						if dist < nearestDist then
							nearestDist = dist
							nearestPlayer = other
						end
					end
				end
			end
			if nearestPlayer and nearestPlayer.Character and nearestPlayer.Character:FindFirstChild("HumanoidRootPart") then
				local targetRoot = nearestPlayer.Character.HumanoidRootPart
				local direction = (rootPart.Position - targetRoot.Position).Unit
				rootPart.CFrame = CFrame.new(targetRoot.Position + direction * 3)
			else
				rootPart.CFrame = CFrame.new(rootPart.Position.X, startingY, rootPart.Position.Z)
			end
		end
		if rootPart.Position.Y >= startingY - 1 then
			teleported = false
		end
	end)
end)

-- Auto QTE for Specific Game (E,F,Q,R + Mobile)
GameTab:NewToggle("Auto QTE universal", "Automatically complete E,F,Q,R QTEs for PC and Mobile", function(state)
    local Players = game:GetService("Players")
    local RunService = game:GetService("RunService")
    local UserInputService = game:GetService("UserInputService")
    local VirtualInputManager = game:GetService("VirtualInputManager")
    local ReplicatedStorage = game:GetService("ReplicatedStorage")
    local player = Players.LocalPlayer
    local autoQTEConnection = nil
    
    local isMobile = UserInputService.TouchEnabled
    local lastQTE = 0
    local qteCooldown = 0.1
    
    -- Game-specific QTE detection
    local function detectGameQTEs()
        -- Method 1: Look for QTE GUI elements (from your images)
        local gui = player:FindFirstChild("PlayerGui")
        if gui then
            -- Look for specific QTE GUI names from your images
            local qteGUIs = {
                "QTEGui", "GuiQTE", "ScreenGuiBotones", "FrameContenedorQTE",
                "FrameQTE", "FramePermisosYMas", "TextButtonQTE"
            }
            
            for _, guiName in pairs(qteGUIs) do
                local qteGui = gui:FindFirstChild(guiName, true)
                if qteGui and qteGui.Visible then
                    return true
                end
            end
            
            -- Look for QTE text (E, F, Q, R, TAP)
            local function searchForQTE(obj)
                if obj:IsA("TextLabel") or obj:IsA("TextButton") then
                    local text = obj.Text:upper()
                    if text == "E" or text == "F" or text == "Q" or text == "R" or text == "TAP" then
                        if obj.Visible and obj.Size ~= UDim2.new(0, 0, 0, 0) then
                            return true
                        end
                    end
                end
                
                for _, child in pairs(obj:GetChildren()) do
                    if searchForQTE(child) then
                        return true
                    end
                end
                return false
            end
            
            for _, screenGui in pairs(gui:GetChildren()) do
                if screenGui:IsA("ScreenGui") and screenGui.Enabled then
                    if searchForQTE(screenGui) then
                        return true
                    end
                end
            end
        end
        
        -- Method 2: Check QTE stats (from your leaderstats images)
        local character = player.Character
        if character then
            local leaderstats = character:FindFirstChild("leaderstats")
            if leaderstats then
                local qteStats = leaderstats:FindFirstChild("QTEAvgPercent") or leaderstats:FindFirstChild("QTESuccesses")
                if qteStats then
                    -- If QTE stats exist, there might be active QTEs
                    return true
                end
            end
        end
        
        -- Method 3: Check ReplicatedStorage for QTE events (from your images)
        local qteConfig = ReplicatedStorage:FindFirstChild("QTEConfig")
        local qteSaveEvent = ReplicatedStorage:FindFirstChild("QTESaveEvent")
        local qteSession = ReplicatedStorage:FindFirstChild("QTESESSION")
        
        if qteConfig or qteSaveEvent or qteSession then
            -- QTE system is present in the game
            return true
        end
        
        return false
    end
    
    -- Function to press specific QTE keys (E, F, Q, R)
    local function pressQTEEFQR()
        if tick() - lastQTE < qteCooldown then
            return
        end
        
        lastQTE = tick()
        
        if isMobile then
            -- MOBILE: Simulate tap for E,F,Q,R buttons
            local gui = player:FindFirstChild("PlayerGui")
            if gui then
                -- Look for specific QTE buttons to tap
                local buttonsToTap = {"E", "F", "Q", "R", "TAP"}
                
                for _, buttonText in pairs(buttonsToTap) do
                    local function findButton(obj)
                        if obj:IsA("TextButton") and obj.Text:upper() == buttonText then
                            if obj.Visible and obj.Active then
                                local absPos = obj.AbsolutePosition
                                local absSize = obj.AbsoluteSize
                                
                                if absPos and absSize then
                                    local centerX = absPos.X + (absSize.X / 2)
                                    local centerY = absPos.Y + (absSize.Y / 2)
                                    
                                    -- Simulate tap on the button
                                    VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, true, game, 1)
                                    wait(0.05)
                                    VirtualInputManager:SendMouseButtonEvent(centerX, centerY, 0, false, game, 1)
                                    
                                    Library:Notify("[AUTO QTE]", "Tapped: " .. buttonText, 1, "Success")
                                    return true
                                end
                            end
                        end
                        
                        for _, child in pairs(obj:GetChildren()) do
                            if findButton(child) then
                                return true
                            end
                        end
                        return false
                    end
                    
                    for _, screenGui in pairs(gui:GetChildren()) do
                        if screenGui:IsA("ScreenGui") then
                            if findButton(screenGui) then
                                return
                            end
                        end
                    end
                end
            end
            
            -- Fallback: tap center screen
            local screenSize = workspace.CurrentCamera.ViewportSize
            VirtualInputManager:SendMouseButtonEvent(
                screenSize.X / 2, 
                screenSize.Y / 2, 
                0, true, game, 1
            )
            wait(0.05)
            VirtualInputManager:SendMouseButtonEvent(
                screenSize.X / 2, 
                screenSize.Y / 2, 
                0, false, game, 1
            )
            
            Library:Notify("[AUTO QTE]", "Mobile Tap (Fallback)", 1, "Info")
            
        else
            -- PC: Press E, F, Q, R keys in sequence (from your game config)
            local keysToPress = {
                Enum.KeyCode.E,
                Enum.KeyCode.F, 
                Enum.KeyCode.Q,
                Enum.KeyCode.R
            }
            
            local pressedKeys = {}
            
            for _, key in pairs(keysToPress) do
                VirtualInputManager:SendKeyEvent(true, key, false, game)
                wait(0.03)
                VirtualInputManager:SendKeyEvent(false, key, false, game)
                wait(0.05)
                
                table.insert(pressedKeys, key.Name)
            end
            
            Library:Notify("[AUTO QTE]", "Pressed: " .. table.concat(pressedKeys, ", "), 1, "Success")
        end
    end
    
    -- Handle timeout buffer (from your game config)
    local function handleTimeoutBuffer()
        -- Your game has timeout buffer of 0.25 seconds
        -- We need to be faster than this
        local timeoutBuffer = 0.25
        local reactionTime = 0.05 -- Our reaction time
        
        if reactionTime < timeoutBuffer then
            return true
        end
        return false
    end
    
    -- Main QTE detection loop optimized for your game
    local function gameQTECheck()
        if detectGameQTEs() then
            if handleTimeoutBuffer() then
                pressQTEEFQR()
            end
        end
    end
    
    -- Toggle functionality
    if state then
        if isMobile then
            Library:Notify("[AUTO QTE]", "Mobile E,F,Q,R Auto-Tap Enabled", 4, "Success")
        else
            Library:Notify("[AUTO QTE]", "PC E,F,Q,R Auto-Press Enabled", 4, "Success")
        end
        
        if not autoQTEConnection then
            autoQTEConnection = RunService.Heartbeat:Connect(gameQTECheck)
        end
    else
        Library:Notify("[AUTO QTE]", "Disabled", 3, "Warning")
        if autoQTEConnection then
            autoQTEConnection:Disconnect()
            autoQTEConnection = nil
        end
    end
end)

GameTab:NewDivider()
GameTab:NewText("ALL")

local AURAGAINER = false -- LOL U GUYS GOT NO AURA

GameTab:NewToggle("Auto Win", false, function()
	local values = game.Workspace.Values
	local char = localPlayer.Character

	AURAGAINER = not AURAGAINER

	while true do
		if AURAGAINER == true then
			task.wait(0.05) -- anti lag
			if values.CurrentGame.Value == "RedLightGreenLight" then
				char.HumanoidRootPart.CFrame = CFrame.new(-46.0587921, 1025.23352, 108.6353122)
			elseif values.CurrentGame.Value == "Dalgona" then

			elseif values.CurrentGame.Value == "TugOfWar" then

			elseif values.CurrentGame.Value == "LightsOut" then
				char.HumanoidRootPart.CFrame = CFrame.new(294.185852, 55.7636185, -3.9290698)
			elseif values.CurrentGame.Value == "HideAndSeek" then
				if localPlayer.Backpack:FindFirstChild("Knife") or char:FindFirstChild("Knife") then
					local Splayer = math.random(1, #Players)
					local Selected = Players[Splayer]

					while Selected.Backpack:FindFirstChild("Knife") or char:FindFirstChild("Knife") do
						Splayer = math.random(1, #Players)
						Selected = Players[Splayer]
					end
					performLoopkill(Splayer)
				else
					char.HumanoidRootPart.CFrame = CFrame.new(196.83342, 55.9547985, -90.4745865)
				end
			elseif values.CurrentGame.Value == "JumpRope" then
				char.HumanoidRootPart.CFrame = CFrame.new(720.896057, 198.628311, 921.170654)
			elseif values.CurrentGame.Value == "GlassBridge" then
				char.HumanoidRootPart.CFrame = CFrame.new(-196.372467, 522.192139, -1534.20984)
			elseif values.CurrentGame.Value == "Mingle" then
				char.HumanoidRootPart.CFrame = CFrame.new(1170.68262, 403.950592, -486.154968)
			elseif values.CurrentGame.Value == "SkySquidGame" then
				char.HumanoidRootPart.CFrame = CFrame.new(2730.44263,1043.33435,800.130554)
			elseif values.CurrentGame.Value == "SquidGame" then

			end
		else
			task.wait(0.05)
		end
	end
end)

GameTab:NewDivider()
GameTab:NewText("Game Entrances")

GameTab:NewButton("Dalgona Entrance", function()
	local char = localPlayer.Character
	char.PrimaryPart.CFrame = CFrame.new(-222.226, 230.93, 406.97)
end)

GameTab:NewButton("HNS/TUG Entrance", function()
	local char = localPlayer.Character
	char.PrimaryPart.CFrame = CFrame.new(-469.221, 245.556, 448.558)
end)

GameTab:NewButton("Jump Rope Entrance", function()
	local char = localPlayer.Character
	char.PrimaryPart.CFrame = CFrame.new(-435.823, 245.556, 504.708)
end)

GameTab:NewButton("Glass Bridge Entrance", function()
	local char = localPlayer.Character
	char.PrimaryPart.CFrame = CFrame.new(-372.466, 259.659, 482.508)
end)

GameTab:NewButton("Mingle Entrance", function()
	local char = localPlayer.Character
	char.PrimaryPart.CFrame = CFrame.new(-382.445, 288.554, 436.898)
end)

GameTab:NewButton("Last Game Entrance", function()
	local char = localPlayer.Character
	char.PrimaryPart.CFrame = CFrame.new(-430.687, 251.535, 791.952)
end)

-- MISC TAB CONTENT
MiscTab:NewText("=== TELEPORTS ===")

MiscTab:NewButton("Teleport To Spawn", function()
	local char = localPlayer.Character
	if char and char:FindFirstChild("HumanoidRootPart") then
		char.HumanoidRootPart.CFrame = CFrame.new(196.83342, 55.9547985, -90.4745865)
	end
end)

MiscTab:NewButton("Teleport To Safe Spot", function()
	local char = localPlayer.Character or localPlayer.CharacterAdded:Wait()
	if char and char:FindFirstChild("HumanoidRootPart") then
		char.HumanoidRootPart.CFrame = CFrame.new(179.030807, 57.9083214, 49.8269196)
	end
end)

MiscTab:NewDivider()

MiscTab:NewText("=== SpamX TITLES ===")

MiscTab:NewButton("[DAHEN HUB] Black Title", function()
	localPlayer:SetAttribute("_CurrentTitle", "Him")
	spawn(function()
		while task.wait() do
			localPlayer.Character.Torso.Player_Nametag.TitleText.Text = "[DAHEN SCRIPT]"
		end
	end)
end)

MiscTab:NewButton("[DAHEN HUB] Gold Title", function()
	localPlayer:SetAttribute("_CurrentTitle", "Rich Millionaire")
	spawn(function()
		while task.wait() do
			localPlayer.Character.Torso.Player_Nametag.TitleText.Text = "[SpamX USER]"
		end
	end)
end)

MiscTab:NewButton("[DAHEN HUB] Purple Title", function()
	localPlayer:SetAttribute("_CurrentTitle", "Tanos")
	spawn(function()
		while task.wait() do
			localPlayer.Character.Torso.Player_Nametag.TitleText.Text = "[SpamX USER]"
		end
	end)
end)

MiscTab:NewButton("[DAHEN HUB] Red Title", function()
	localPlayer:SetAttribute("_CurrentTitle", "The Chosen One")
	spawn(function()
		while task.wait() do
			localPlayer.Character.Torso.Player_Nametag.TitleText.Text = "[DAHEN SCRIPT ]"
		end
	end)
end)

MiscTab:NewDivider()

MiscTab:NewText("=== ITEM TELEPORTS ===")

MiscTab:NewButton("Teleport To Dropped Bandage", function()
	local char = localPlayer.Character
	if char and char:FindFirstChild("HumanoidRootPart") then
		for i = 1, 10 do
			char.HumanoidRootPart.CFrame = game.Workspace.Effects:FindFirstChild("DroppedBandage").PrimaryPart.CFrame
			task.wait(0.125)
		end
	end
end)

MiscTab:NewButton("Teleport To Dropped Grenade", function()
	local char = localPlayer.Character
	if char and char:FindFirstChild("HumanoidRootPart") then
		for i = 1, 10 do
			char.HumanoidRootPart.CFrame = game.Workspace.Effects:FindFirstChild("DroppedGrenade").PrimaryPart.CFrame
			task.wait(0.125)
		end
	end
end)

MiscTab:NewButton("Teleport To Dropped FlashBang", function()
	local char = localPlayer.Character
	if char and char:FindFirstChild("HumanoidRootPart") then
		for i = 1, 10 do
			char.HumanoidRootPart.CFrame = game.Workspace.Effects:FindFirstChild("DroppedFlashbang").PrimaryPart.CFrame
			task.wait(0.125)
		end
	end
end)

MiscTab:NewDivider()

local teleportEnabled = false
local teleportConnection = nil

-- Teleport to Dropped Bandage Toggle
MiscTab:NewToggle("Auto Grab Dropped Bandage", false, function(state)
	teleportEnabled = state

	if teleportEnabled then
		-- Start the teleport loop
		teleportConnection = game:GetService("RunService").Heartbeat:Connect(function()
			if not teleportEnabled then return end

			local char = localPlayer.Character
			if char and char:FindFirstChild("HumanoidRootPart") then
				local droppedBandage = game.Workspace.Effects:FindFirstChild("DroppedBandage")
				if droppedBandage and droppedBandage.PrimaryPart then
					char.HumanoidRootPart.CFrame = droppedBandage.PrimaryPart.CFrame
				end
			end
		end)
	else
		-- Stop the teleport loop
		if teleportConnection then
			teleportConnection:Disconnect()
			teleportConnection = nil
		end
	end
end)

-- Teleport to Dropped Grenade Toggle
local grenadeEnabled = false
local grenadeConnection = nil

MiscTab:NewToggle("Auto Grab Dropped Grenade", false, function(state)
	grenadeEnabled = state

	if grenadeEnabled then
		-- Start the teleport loop
		grenadeConnection = game:GetService("RunService").Heartbeat:Connect(function()
			if not grenadeEnabled then return end

			local char = localPlayer.Character
			if char and char:FindFirstChild("HumanoidRootPart") then
				local droppedGrenade = game.Workspace.Effects:FindFirstChild("DroppedGrenade")
				if droppedGrenade and droppedGrenade.PrimaryPart then
					char.HumanoidRootPart.CFrame = droppedGrenade.PrimaryPart.CFrame
				end
			end
		end)
	else
		-- Stop the teleport loop
		if grenadeConnection then
			grenadeConnection:Disconnect()
			grenadeConnection = nil
		end
	end
end)

-- Teleport to Dropped FlashBang Toggle
local flashbangEnabled = false
local flashbangConnection = nil

MiscTab:NewToggle("Auto Grab Dropped FlashBang", false, function(state)
	flashbangEnabled = state

	if flashbangEnabled then
		-- Start the teleport loop
		flashbangConnection = game:GetService("RunService").Heartbeat:Connect(function()
			if not flashbangEnabled then return end

			local char = localPlayer.Character
			if char and char:FindFirstChild("HumanoidRootPart") then
				local droppedFlashbang = game.Workspace.Effects:FindFirstChild("DroppedFlashbang")
				if droppedFlashbang and droppedFlashbang.PrimaryPart then
					char.HumanoidRootPart.CFrame = droppedFlashbang.PrimaryPart.CFrame
				end
			end
		end)
	else
		-- Stop the teleport loop
		if flashbangConnection then
			flashbangConnection:Disconnect()
			flashbangConnection = nil
		end
	end
end)

MiscTab:NewDivider()

MiscTab:NewToggle("Enable Spectate", false, function(state)
	game.Workspace.Values.CanSpectateIfWonGame.Value = state
end)

MiscTab:NewTextInput("Custom Player Number", "Put Tag Here", function(value)
	local char = localPlayer.Character
	local ui = localPlayer.PlayerGui.Leaderboard.Leaderboard.MainLeaderboard.Content:FindFirstChild(localPlayer.UserId)
	local Tags = char:FindFirstChild("PlayerTags")

	spawn(function()
		while true do
			task.wait()
			for i, tag in pairs(Tags:GetChildren()) do
				tag.SurfaceGui.TextLabel.Text = value
				ui.PlayerNumber.Text = "#"..value
			end
		end
	end)
end)

MiscTab:NewDivider()

MiscTab:NewButton("FPS Boost", function()
	-- Example FPS Booster Script
	local Lighting = game:GetService("Lighting")
	Lighting.GlobalShadows = false
	Lighting.FogEnd = 100000
	Lighting.Brightness = 1

	for _, v in pairs(workspace:GetDescendants()) do
		if v:IsA("BasePart") then
			v.Material = Enum.Material.SmoothPlastic
		end
	end
end)

-- Auto-refresh player list when players join/leave
Players.PlayerAdded:Connect(function()
	task.wait(1)
	-- Would need to refresh dropdown here
end)

Players.PlayerRemoving:Connect(function(player)
	if selectedPlayer == player then
		selectedPlayer = nil
	end
	-- Would need to refresh dropdown here
end)

-- Clean up speed boost and noclip on character respawn
localPlayer.CharacterAdded:Connect(function()
	speedBoostEnabled = false
	if speedConnection then
		speedConnection:Disconnect()
		speedConnection = nil
	end

	noclipEnabled = false
	if noclipConnection then
		noclipConnection:Disconnect()
		noclipConnection = nil
	end
end)

print("DAHEN HUB LOADED")
